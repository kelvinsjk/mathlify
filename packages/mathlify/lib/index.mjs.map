{"mappings":"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","sources":["src/index.ts","src/core/index.ts","src/core/fractionClass.ts","src/core/utils/gcd.ts","src/core/utils/numberToFraction.ts","src/core/basic/index.ts","src/core/basic/basicTermClass.ts","src/core/basic/imaginaryClass.ts","src/core/basic/variableTermClass.ts","src/core/basic/mathSymbol.ts","src/core/basic/surd.ts","src/core/algebra/mathSymbolClass.ts","src/core/utils/index.ts","src/core/utils/factorize.ts","src/core/utils/numberToNthRoot.ts","src/core/algebra/sqrt.ts","src/core/utils/numberToSquareRoot.ts","src/core/algebra/term.ts","src/core/basic/imaginary.ts","src/core/algebra/index.ts","src/core/algebra/expression.ts","src/core/algebra/polynomialClass.ts","src/vectors/index.ts","src/vectors/vectorClass.ts","src/vectors/lineClass.ts","src/numerical/index.ts","src/numerical/cramers.ts","src/numerical/determinant.ts","src/numerical/bisection.ts","src/vectors/planeClass.ts","src/vectors/extendedVectorClass.ts","src/vectors/unknownVectorClass.ts","src/random/index.ts","src/random/getRandomInt.ts","src/random/getRandomVec.ts","src/random/shuffle.ts","src/random/coinFlip.ts","src/misc/index.ts","src/misc/factors.ts","src/misc/JSONParse.ts","src/calculus/index.ts","src/calculus/classes/index.ts","src/calculus/classes/classes.ts","src/algebra/index.ts","src/algebra/rationalClass.ts","src/polynomialMethods/index.ts","src/polynomialMethods/expressionToPolynomial.ts","src/polynomialMethods/polynomials.ts","src/polynomialMethods/solveQuadraticComplex.ts","src/complex/index.ts","src/complex/complexClass.ts","src/complex/complexExpClass.ts","src/trigo/index.ts","src/trigo/angleClass.ts","src/trigo/trigoFns.ts","src/trigo/arcFns.ts","src/complex/extendedComplexClass.ts","src/complex/utils/index.ts","src/complex/utils/expToCartesian.ts","src/complex/utils/complexToQuadratic.ts","src/complex/utils/subInComplex.ts","src/polynomialMethods/longDivide.ts","src/polynomialMethods/linear.ts","src/polynomialMethods/polynomialsAndSurds.ts","src/algebra/solveRational.ts","src/algebra/partialFractions.ts","src/algebra/extendedPolynomialClass.ts","src/calculus/classes/laurent.ts","src/calculus/parametricClass.ts","src/calculus/rationalToPower.ts","src/calculus/integrate/index.ts","src/calculus/integrate/trigo.ts","src/calculus/integrate/mf26.ts","src/calculus/integrate/byParts.ts","src/calculus/simpsons.ts","src/calculus/finiteDifference.ts","src/calculus/differential_equations/index.ts","src/calculus/differential_equations/type1.ts","src/misc/unsimplifiedExpression.ts","src/random/getRandomFrac.ts","src/random/sample.ts","src/random/getRandomAngle.ts","src/sequences/index.ts","src/sequences/apClass.ts","src/sequences/gpClass.ts","src/sequences/utils/index.ts","src/sequences/utils/solveGpSN.ts","src/maclaurin/index.ts","src/maclaurin/maclaurin.ts","src/stats/simple-statistics/factorial.ts","src/maclaurin/xMaclaurin.ts","src/stats/index.ts","src/stats/binomial.ts","src/stats/nCr.ts","src/stats/normalFns.ts","src/stats/simple-statistics/errorFunction.ts","src/stats/math-erfinv/math-erfinv.ts","src/stats/normalClass.ts","src/stats/regression.ts"],"sourcesContent":["export {\n\tFraction,\n\tSquareRoot,\n\tNthRoot,\n\tVariableTerm,\n\tImaginary,\n\tBasicTerm,\n\tTerm,\n\tExpression,\n\tPolynomial,\n\tgcd,\n\tlcm,\n\tfactorize,\n\tnumberToFraction,\n\tnumberToSquareRoot,\n\tMathSymbol,\n\tImaginarySymbol,\n\ttype ImaginarySymbolJSON,\n\tSurd,\n\ttype SurdJSON,\n\tRootSymbol,\n\ttype RootSymbolJSON,\n} from './core';\n\nexport { Vector, Line, Plane, xVector, uVector, uxVector, uVectorExpression, uxVectorExpression } from './vectors';\n\nexport {\n\tgetRandomInt,\n\tgetRandomInts,\n\tgetRandomVec,\n\tgetNiceVec,\n\tgetRandomPerps,\n\tgetRandomPerp,\n\tgetRandomLine,\n\tgetRandomFrac,\n\tshuffle,\n\theads,\n\tgetRandomAngle,\n\tsample,\n\tsampleN,\n} from './random';\n\nexport { JSONParse, factorPairs, UnsimplifiedExpression, BracketedTerm } from './misc';\n\nexport {\n\texpToPoly,\n\tsimplifyPoly,\n\tfactorizeQuadratic,\n\tfactorizeCubic,\n\tsolveQuadratic,\n\tsolveQuadraticSurd,\n\tsolveQuadraticComplex,\n\tsolveLinear,\n\tshiftPoly,\n\tcompleteSquare,\n\tlongDivide,\n\tlinear,\n\tsubSurdInPoly,\n} from './polynomialMethods';\n\nexport { cramers, cramersFrac, determinantFrac, bisection } from './numerical';\n\nexport { Complex, ComplexExp, xComplex, expToCartesian, complexToQuadratic, subComplexIntoPoly } from './complex';\nexport { Angle, sin, cos, tan, asin, acos, atan } from './trigo';\nexport { AP, GP, solveGpSN, solveGpSNNumber } from './sequences';\n\nexport { Rational, solveRational, partialFractions, xPolynomial } from './algebra';\nexport {\n\tPowerFn,\n\tSinFn,\n\tCosFn,\n\tExpFn,\n\tLnFn,\n\tRationalFn,\n\tLaurent,\n\tParametric,\n\tintegrate,\n\tdefiniteIntegral,\n\trationalToPowerFn,\n\tsimpsons,\n\tfiniteDifference,\n\tde,\n} from './calculus';\n\nexport { Maclaurin, xMaclaurin } from './maclaurin';\n\nexport {\n\tbinomPdf,\n\tbinomCdf,\n\tbinomCdfRange,\n\tnormCdf,\n\tinvNorm,\n\tzTest,\n\tfactorial,\n\tNormal,\n\tnCr,\n\tNCR,\n\tRegression,\n} from './stats';\n\nexport type {\n\tNumberArray2x2,\n\tFractionArray2x2,\n\tNumberArray3x3,\n\tFractionArray3x3,\n\tNumberArray4x4,\n\tFractionArray4x4,\n} from './numerical';\n","export { Fraction, type FractionJSON } from './fractionClass';\nexport {\n\t//NthRoot, SquareRoot,\n\tVariableTerm,\n\tImaginary,\n\tBasicTerm,\n} from './basic';\nexport { Term, Expression, Polynomial, SquareRoot, NthRoot } from './algebra';\n\nexport {\n\tMathSymbol,\n\tImaginarySymbol,\n\ttype ImaginarySymbolJSON,\n\tSurd,\n\ttype SurdJSON,\n\tRootSymbol,\n\ttype RootSymbolJSON,\n} from './basic';\n\nexport { gcd, lcm, numberToFraction, numberToSquareRoot, factorize } from './utils';\n","import { gcd } from './utils/gcd';\nimport { numberToFraction } from './utils/numberToFraction';\n\n/**\n * Fraction class `{num: numerator, den: denominator}`\n *\n * `num` represents the numerator and is an integer\n *\n * `den` represents the denominator and is a positive integer (any negative signs are \"hoisted\" to `num`)\n */\nexport class Fraction {\n\t/** numerator of the fraction (integer) */\n\tnum: number;\n\t/** denominator of the fraction (positive integer) */\n\tden: number;\n\n\t/**\n\t * Creates a new `Fraction` instance, 'simplifying' the fraction to the form a/b such that a is an integer, b is a positive integer and gcd(a,b)=1.\n\t * @param num numerator\n\t * @param den denominator defaults to `1`\n\t */\n\tconstructor(num: number, den: number = 1) {\n\t\tif (!Number.isInteger(den) || !Number.isInteger(num)) {\n\t\t\tthrow new RangeError('Fraction error: parameters must be integers');\n\t\t}\n\t\tif (den === 0) {\n\t\t\tthrow new RangeError('Fraction error: denominator must be non-zero');\n\t\t}\n\t\tconst divisor = gcd(num, den);\n\t\tconst sign = Math.sign(num) * Math.sign(den); // signs hoisted to top\n\t\tthis.num = (sign * Math.abs(num)) / divisor;\n\t\tthis.den = Math.abs(den) / divisor;\n\t}\n\n\t/**\n\t * addition\n\t * @param f2 the number/fraction to be added\n\t * @returns the sum of this fraction and `f2`\n\t */\n\tplus(f2: number | Fraction): Fraction {\n\t\tf2 = numberToFraction(f2);\n\t\treturn new Fraction(this.num * f2.den + f2.num * this.den, this.den * f2.den);\n\t}\n\n\t/**\n\t * multiplication\n\t * @param f2 the number/fraction to be multiplied\n\t * @returns the product of this fraction and `f2`\n\t */\n\ttimes(f2: number | Fraction): Fraction {\n\t\tf2 = numberToFraction(f2);\n\t\treturn new Fraction(this.num * f2.num, this.den * f2.den);\n\t}\n\n\t/**\n\t * @returns negative of this fraction\n\t */\n\tnegative(): Fraction {\n\t\treturn this.times(-1);\n\t}\n\n\t/**\n\t * @returns the absolute value of this Fraction\n\t */\n\tabs(): Fraction {\n\t\treturn new Fraction(Math.abs(this.num), this.den);\n\t}\n\n\t/**\n\t * subtraction\n\t * @param f2 the number/fraction to be subtracted\n\t * @returns this fraction minus `f2`\n\t */\n\tminus(f2: number | Fraction): Fraction {\n\t\tf2 = numberToFraction(f2);\n\t\treturn this.plus(f2.negative());\n\t}\n\n\t/**\n\t * reciprocal\n\t * @returns this 1/(this fraction), provided that this fraction is non-zero\n\t */\n\treciprocal(): Fraction {\n\t\treturn new Fraction(this.den, this.num);\n\t}\n\n\t/**\n\t * division\n\t * @param f2 the number/fraction to be divided by. Cannot be zero.\n\t * @returns this fraction divided by `f2`\n\t */\n\tdivide(f2: number | Fraction): Fraction {\n\t\tf2 = numberToFraction(f2);\n\t\treturn this.times(f2.reciprocal());\n\t}\n\n\t/**\n\t * exponentiation\n\t * @param n integer\n\t * @returns this fraction to the power of `n`\n\t */\n\tpow(n: number | Fraction): Fraction {\n\t\tif (n instanceof Fraction) {\n\t\t\tif (n.den !== 1) {\n\t\t\t\tthrow new RangeError(`only integral n are allowed for fraction.pow at the moment. ${n} received`);\n\t\t\t}\n\t\t\tn = n.valueOf();\n\t\t}\n\t\tif (!Number.isInteger(n)) {\n\t\t\tthrow new RangeError(`only integral n are allowed for fraction.pow(n). ${n} received`);\n\t\t}\n\t\tconst modN = Math.abs(n);\n\t\tconst thisPowerModN = new Fraction(Math.pow(this.num, modN), Math.pow(this.den, modN));\n\t\treturn n >= 0 ? thisPowerModN : thisPowerModN.reciprocal();\n\t}\n\n\t/**\n\t * square\n\t * @returns the square of this fraction\n\t */\n\tsquare(): Fraction {\n\t\treturn this.pow(2);\n\t}\n\n\t/**\n\t * checks if this fraction is equal to `f2`\n\t */\n\tisEqualTo(f2: number | Fraction): boolean {\n\t\tf2 = numberToFraction(f2);\n\t\treturn this.num === f2.num && this.den == f2.den;\n\t}\n\n\t/**\n\t * checks if this fraction not is equal to `f2`\n\t */\n\tisNotEqualTo(f2: number | Fraction): boolean {\n\t\treturn !this.isEqualTo(f2);\n\t}\n\n\t/**\n\t * checks if this fraction is an integer\n\t */\n\tisInteger(): boolean {\n\t\treturn this.den === 1;\n\t}\n\n\t/**\n\t * checks if this fraction is larger than f2\n\t * @param f2 number or fraction to compare against\n\t */\n\tisGreaterThan(f2: number | Fraction): boolean {\n\t\treturn this.valueOf() > f2.valueOf();\n\t}\n\n\t/**\n\t * checks if this fraction is smaller than f2\n\t * @param f2 number or fraction to compare against\n\t */\n\tisLessThan(f2: number | Fraction): boolean {\n\t\treturn this.valueOf() < f2.valueOf();\n\t}\n\n\t/**\n\t * checks if this fraction is greater than or equal to f2\n\t * @param f2 number or fraction to compare against\n\t */\n\tisAtLeast(f2: number | Fraction): boolean {\n\t\treturn this.isGreaterThan(f2) || this.isEqualTo(f2);\n\t}\n\n\t/**\n\t * checks if this fraction is less than or equal to f2\n\t * @param f2 number or fraction to compare against\n\t */\n\tisAtMost(f2: number | Fraction): boolean {\n\t\treturn this.isLessThan(f2) || this.isEqualTo(f2);\n\t}\n\n\t/**\n\t * ceiling function\n\t * @returns the least integer greater than or equal to this fraction in Fraction form\n\t */\n\tceil(): Fraction {\n\t\treturn new Fraction(Math.ceil(this.valueOf()));\n\t}\n\t/**\n\t * floor function\n\t * @returns the greatest integer less than or equal to this fraction in Fraction form\n\t */\n\tfloor(): Fraction {\n\t\treturn new Fraction(Math.floor(this.valueOf()));\n\t}\n\t/**\n\t * rounding function\n\t *\n\t * round off this fraction to the nearest integer, and\n\t * @returns the value in Fraction form\n\t */\n\tround(): Fraction {\n\t\treturn new Fraction(Math.round(this.valueOf()));\n\t}\n\t/**\n\t * sign function\n\t *\n\t * @returns the sign of this fraction\n\t */\n\tsign(): number {\n\t\treturn Math.sign(this.valueOf());\n\t}\n\n\t/**\n\t * converts to Javascript built-in Number type\n\t * @returns the float representation of this fraction in the JavaScript number format\n\t */\n\tvalueOf(): number {\n\t\treturn this.num / this.den;\n\t}\n\n\t/**\n\t * invokes the JavaScript `Number.prototype.toFixed()` method\n\t */\n\ttoFixed(digits?: number): string {\n\t\treturn this.valueOf().toFixed(digits);\n\t}\n\t/**\n\t * invokes the JavaScript `Number.prototype.toPrecision()` method\n\t * before passing it back as a number (to avoid exponential notation)\n\t */\n\ttoPrecision(precision?: number): string {\n\t\treturn Number(this.valueOf().toPrecision(precision)).toString();\n\t}\n\n\t/**\n\t * `toString()` method\n\t *\n\t * @returns the LaTeX string representation of the fraction\n\t */\n\ttoString(): string {\n\t\tif (this.isInteger()) {\n\t\t\treturn this.num < 0 ? `- ${Math.abs(this.num)}` : `${this.num}`;\n\t\t}\n\t\t// fraction\n\t\tconst sign = this.num < 0 ? '- ' : '';\n\t\treturn `${sign}\\\\frac{${Math.abs(this.num)}}{${this.den}}`;\n\t}\n\n\t/**\n\t * toJSON method that allows for quick reconstruction of class instance\n\t * by storing its constructor arguments\n\t */\n\ttoJSON(): FractionJSON {\n\t\treturn {\n\t\t\ttype: 'fraction',\n\t\t\targs: [this.num, this.den],\n\t\t};\n\t}\n\n\t/**\n\t * clones the Fraction: creating a new Fraction instance\n\t */\n\tclone(): Fraction {\n\t\treturn new Fraction(this.num, this.den);\n\t}\n\n\t/**\n\t * the fraction class instance of 1\n\t */\n\tstatic ONE = new Fraction(1);\n\t/**\n\t * the fraction class instance of 0\n\t */\n\tstatic ZERO = new Fraction(0);\n\n\t/**\n\t * @returns gcd of given fractions\n\t */\n\tstatic gcd(...fractions: (number | Fraction)[]): Fraction {\n\t\tif (fractions.length === 0) {\n\t\t\tthrow new Error('Fraction ERROR: gcd function must have at least one argument');\n\t\t} else if (fractions.length === 1) {\n\t\t\tconst fraction = numberToFraction(fractions[0]);\n\t\t\treturn fraction;\n\t\t} else if (fractions.length === 2) {\n\t\t\tconst fraction1 = numberToFraction(fractions[0]);\n\t\t\tconst fraction2 = numberToFraction(fractions[1]);\n\t\t\tconst gcdNum = gcd(fraction1.num, fraction2.num);\n\t\t\tconst gcdDen = gcd(fraction1.den, fraction2.den);\n\t\t\tconst lcmDen = Math.abs(fraction1.den * fraction2.den) / gcdDen;\n\t\t\treturn new Fraction(gcdNum, lcmDen);\n\t\t} else {\n\t\t\t// recursively call this method\n\t\t\tconst [fraction1, fraction2, ...restOfFractions] = fractions;\n\t\t\treturn fraction1.valueOf() === 0 && fraction2.valueOf() === 0\n\t\t\t\t? Fraction.gcd(0, ...restOfFractions)\n\t\t\t\t: Fraction.gcd(Fraction.gcd(fraction1, fraction2), ...restOfFractions);\n\t\t}\n\t}\n\n\t/**\n\t * given a set of fractions (a, b, c, ..., n)\n\t * @returns an array `[[A, B, C, ..., N], k ]`,\n\t * where k(A, B, C, ..., N) = (a, b, c, ..., n)\n\t */\n\tstatic factorize(...fractions: (number | Fraction)[]): [Fraction[], Fraction] {\n\t\tlet gcd = Fraction.gcd(...fractions);\n\t\tlet simplifiedArray = fractions.map((fraction) => {\n\t\t\tfraction = numberToFraction(fraction);\n\t\t\treturn fraction.divide(gcd);\n\t\t});\n\t\tif (simplifiedArray.reduce((acc, current) => acc && current.valueOf() <= 0, true)) {\n\t\t\tsimplifiedArray = simplifiedArray.map((fraction) => fraction.negative());\n\t\t\tgcd = gcd.negative();\n\t\t}\n\t\treturn [simplifiedArray, gcd];\n\t}\n}\n\nexport interface FractionJSON {\n\ttype: string;\n\targs: [number, number];\n}\n","/**\n * Finds greatest common divisor of n **integers**\n * of which at least one is non-zero\n *\n * @returns the (positive) gcd of the given numbers\n */\nexport function gcd(...integers: number[]): number {\n\tif (integers.length === 0) {\n\t\tthrow new RangeError('gcd ERROR: gcd function must have at least one argument');\n\t} else if (integers.length === 1) {\n\t\treturn Math.abs(integers[0]);\n\t} else if (integers.length === 2) {\n\t\treturn gcdTwo(integers[0], integers[1]);\n\t} else {\n\t\t// recursively call this method\n\t\tconst [integer1, integer2, ...restOfIntegers] = integers;\n\t\treturn integer1 === 0 && integer2 === 0\n\t\t\t? gcd(0, ...restOfIntegers)\n\t\t\t: gcd(gcdTwo(integer1, integer2), ...restOfIntegers);\n\t}\n}\n\nexport function lcm(...integers: number[]): number {\n\tif (integers.length === 0) {\n\t\tthrow new RangeError('lcm function must have at least one argument');\n\t} else if (integers.length === 1) {\n\t\treturn Math.abs(integers[0]);\n\t} else if (integers.length === 2) {\n\t\treturn lcmTwo(integers[0], integers[1]);\n\t} else {\n\t\t// recursively call this method\n\t\tconst [integer1, integer2, ...restOfIntegers] = integers;\n\t\treturn lcm(lcmTwo(integer1, integer2), ...restOfIntegers);\n\t}\n}\n\n/**\n * Greatest common divisor of two integers\n *\n * @returns the (positive) gcd of two integers\n */\nfunction gcdTwo(a: number, b: number): number {\n\ta = Math.abs(a);\n\tb = Math.abs(b);\n\tif (a === 0 && b === 0) {\n\t\tthrow new RangeError('gcd(0,0) not defined');\n\t}\n\tif (!Number.isInteger(a) || !Number.isInteger(b)) {\n\t\tthrow new TypeError('gcd not defined for non-integers');\n\t}\n\tif (a === 0 || b === 0) {\n\t\t// at least one non-zero due to earlier check\n\t\treturn Math.max(a, b);\n\t}\n\twhile (b !== 0) {\n\t\t[a, b] = [b, a % b];\n\t}\n\treturn a;\n}\n\nfunction lcmTwo(a: number, b: number): number {\n\treturn Math.abs(a * b) / gcdTwo(a, b);\n}\n","import { Fraction } from '../fractionClass';\n\n/**\n * takes an integer and/or Fraction, and returns a new Fraction instance\n * representing the number\n */\nexport function numberToFraction(x: number | Fraction): Fraction {\n\tif (typeof x === 'number') {\n\t\treturn new Fraction(x);\n\t} else {\n\t\treturn new Fraction(x.num, x.den);\n\t}\n}\n","export { BasicTerm } from './basicTermClass';\nexport { Imaginary, type ImaginaryJSON } from './imaginaryClass';\n//export { NthRoot, SquareRoot, type SquareRootJSON } from './rootClasses';\nexport { VariableTerm, type VariableTermJSON } from './variableTermClass';\n\nexport { MathSymbol, type MathSymbolJSON } from './mathSymbol';\nexport { Surd, type SurdJSON, RootSymbol, type RootSymbolJSON } from './surd';\nexport { ImaginarySymbol, type ImaginarySymbolJSON } from './imaginary';\n","import { Fraction } from '../fractionClass';\nimport { numberToFraction } from '../utils/numberToFraction';\n\n/**\n * Basic Term class `{coeff: Fraction, variable: string }`\n * handles edge cases in typesetting:\n * 0x = 0, 1x = x, -1x = -x, \\pm 1 = \\pm 1\n */\nexport class BasicTerm {\n\t/** Coefficient of the term */\n\tcoeff: Fraction;\n\t/**\n\t * String representation of the variable.\n\t *\n\t * An empty string here will represent the \"constant term\"\n\t */\n\tvariableString: string;\n\n\t/**\n\t * Creates a new term instance\n\t * @param coeff coefficient of the term\n\t * @param variable string representation of the term/'variable'.\n\t * An empty string (default) means we are working with the constant term\n\t */\n\tconstructor(coeff: Fraction | number, variable = '') {\n\t\tcoeff = numberToFraction(coeff);\n\t\tthis.coeff = coeff;\n\t\tthis.variableString = variable;\n\t}\n\n\t/**\n\t * `toString()` method\n\t *\n\t * @returns the LaTeX string representation of the term\n\t */\n\ttoString(): string {\n\t\tif (this.coeff.isEqualTo(0)) {\n\t\t\treturn '0';\n\t\t}\n\t\tif (this.coeff.isEqualTo(1)) {\n\t\t\treturn this.variableString === '' ? '1' : `${this.variableString}`;\n\t\t}\n\t\tif (this.coeff.isEqualTo(-1)) {\n\t\t\treturn this.variableString === '' ? '- 1' : `- ${this.variableString}`;\n\t\t}\n\t\t// non 0/1/-1 coefficient\n\t\tif (this.variableString === '') {\n\t\t\t// constant term\n\t\t\treturn `${this.coeff}`;\n\t\t}\n\t\t// variable term and non 0/1/-1 coefficient\n\t\treturn `${this.coeff} ${this.variableString}`;\n\t}\n}\n","import { Fraction, FractionJSON } from '../fractionClass';\nimport { BasicTerm } from './basicTermClass';\n\n/**\n * Imaginary class representing 'ki', where i is the complex unit\n */\nexport class Imaginary extends BasicTerm {\n\tconstructor(coeff: number | Fraction = 1) {\n\t\tsuper(coeff, '\\\\mathrm{i}');\n\t}\n\n\tplus(x: Imaginary): Imaginary {\n\t\treturn new Imaginary(this.coeff.plus(x.coeff));\n\t}\n\tnegative(): Imaginary {\n\t\treturn new Imaginary(this.coeff.negative());\n\t}\n\tminus(x: Imaginary): Imaginary {\n\t\treturn new Imaginary(this.coeff.minus(x.coeff));\n\t}\n\ttimes(x: Imaginary | Fraction): Fraction | Imaginary {\n\t\treturn x instanceof Fraction ? new Imaginary(this.coeff.times(x)) : this.coeff.times(x.coeff).times(-1);\n\t}\n\n\tpow(n: number): Fraction | Imaginary {\n\t\tif (!Number.isInteger(n) || n < 0) {\n\t\t\tthrow new Error('Exponent must be a non-negative integer');\n\t\t}\n\t\tlet result: Fraction | Imaginary = new Fraction(1);\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tresult = this.times(result);\n\t\t}\n\t\treturn result;\n\t}\n\tsquare(): Fraction {\n\t\tconst x = this.times(this) as Fraction;\n\t\treturn x;\n\t}\n\n\tclone(): Imaginary {\n\t\treturn new Imaginary(this.coeff);\n\t}\n\n\ttoJSON(): ImaginaryJSON {\n\t\treturn {\n\t\t\ttype: 'imaginary',\n\t\t\targs: [this.coeff.toJSON()],\n\t\t};\n\t}\n}\n\nexport interface ImaginaryJSON {\n\ttype: 'imaginary';\n\targs: [FractionJSON];\n}\n","import { Fraction, FractionJSON } from '../fractionClass';\nimport { numberToFraction } from '../utils/numberToFraction';\nimport { BasicTerm } from './basicTermClass';\n\n/**\n * `Unknown` class representing \"k x^n\"\n */\nexport class VariableTerm extends BasicTerm {\n\t/** variable string (before taking powers) */\n\tvariable: string;\n\t/** degree of the polynomial term: must be a non-negative integer */\n\tn: Fraction;\n\n\t/**\n\t * Creates a new polynomial term instance\n\t * @param coeff coefficient of the term. If a string is passed, we will use that as the unknown and let the coefficient and power be 1\n\t * @param options defaults to `{ unknown: 'x', n: 1, }`;\n\t */\n\tconstructor(coeff: Fraction | number | string = 1, options?: { variable?: string; n?: number | Fraction }) {\n\t\tconst { variable, n: nNumber } = {\n\t\t\tvariable: 'x',\n\t\t\tn: 1,\n\t\t\t...options,\n\t\t};\n\t\tif (typeof coeff === 'string') {\n\t\t\t// edge case\n\t\t\tsuper(1, coeff);\n\t\t\tthis.variable = coeff;\n\t\t\tthis.n = new Fraction(1);\n\t\t} else {\n\t\t\tcoeff = numberToFraction(coeff);\n\t\t\tconst n = numberToFraction(nNumber);\n\t\t\tlet variableString: string; // x^n\n\t\t\tif (n.isEqualTo(1) || n.isEqualTo(0)) {\n\t\t\t\tvariableString = n.isEqualTo(1) ? variable : '';\n\t\t\t} else {\n\t\t\t\tconst powerString = `${n}`.length > 1 ? `{${n}}` : `${n}`;\n\t\t\t\tvariableString = `${variable}^${powerString}`;\n\t\t\t}\n\t\t\tsuper(coeff, variableString);\n\t\t\tthis.variable = variable;\n\t\t\tthis.n = n;\n\t\t}\n\t}\n\n\t/**\n\t * Multiplication\n\t */\n\ttimes(k: number | Fraction | VariableTerm): VariableTerm {\n\t\tif (k instanceof VariableTerm) {\n\t\t\tif (k.variable !== this.variable) {\n\t\t\t\tthrow new Error('Cannot multiply two power terms with different unknowns');\n\t\t\t}\n\t\t\treturn new VariableTerm(this.coeff.times(k.coeff), { variable: this.variable, n: this.n.plus(k.n) });\n\t\t}\n\t\treturn new VariableTerm(this.coeff.times(k), { variable: this.variable, n: this.n });\n\t}\n\t/**\n\t * Division\n\t */\n\tdivide(k: number | Fraction | VariableTerm): VariableTerm {\n\t\tif (k instanceof VariableTerm) {\n\t\t\tif (k.variable !== this.variable) {\n\t\t\t\tthrow new Error('Cannot multiply two power terms with different unknowns');\n\t\t\t}\n\t\t\treturn new VariableTerm(this.coeff.divide(k.coeff), { variable: this.variable, n: this.n.minus(k.n) });\n\t\t}\n\t\treturn new VariableTerm(this.coeff.divide(k), { variable: this.variable, n: this.n });\n\t}\n\n\t/**\n\t * @returns the negative of this `Term`. Equivalent to `term.multiply(-1)`.\n\t */\n\tnegative(): VariableTerm {\n\t\treturn this.times(-1);\n\t}\n\n\tpow(n: number): VariableTerm {\n\t\treturn new VariableTerm(this.coeff.pow(n), { variable: this.variable, n: this.n.times(n) });\n\t}\n\n\t/**\n\t * substitutes the unknown in and returns a fraction\n\t *\n\t * only supports fraction when n is an integer at the moment\n\t */\n\tsubIn(x: number | Fraction): Fraction {\n\t\tx = numberToFraction(x);\n\t\tif (!this.n.isInteger()) {\n\t\t\tthrow new Error(`Cannot substitute in a non-integer power ${this.n}`);\n\t\t}\n\t\treturn this.coeff.times(x.pow(this.n.num));\n\t}\n\n\t/**\n\t * substitutes the unknown in and returns a number type\n\t */\n\tsubInNumber(x: number): number {\n\t\treturn this.coeff.valueOf() * Math.pow(x, this.n.valueOf());\n\t}\n\n\t/** clones and creates a new instance */\n\tclone(): VariableTerm {\n\t\treturn new VariableTerm(this.coeff.clone(), { variable: this.variable, n: this.n });\n\t}\n\n\ttoJSON(): VariableTermJSON {\n\t\treturn {\n\t\t\ttype: 'variable',\n\t\t\targs: [this.coeff.toJSON(), { variable: this.variable, n: this.n.toJSON() }],\n\t\t};\n\t}\n}\n\nexport interface VariableTermJSON {\n\ttype: 'variable';\n\targs: [FractionJSON, { variable: string; n: FractionJSON }];\n}\n","import { FractionJSON } from '../fractionClass';\n\nexport class MathSymbol {\n\tkind: string;\n\tsymbol: string;\n\n\tconstructor(symbol: string, options?: { kind?: string }) {\n\t\tconst { kind } = {\n\t\t\tkind: 'symbol',\n\t\t\t...options,\n\t\t};\n\t\tthis.kind = kind;\n\t\tthis.symbol = symbol;\n\t}\n\n\ttoString(): string {\n\t\treturn this.symbol;\n\t}\n\n\t/**\n\t * toJSON method that allows for quick reconstruction of class instance\n\t * by storing its constructor arguments\n\t */\n\ttoJSON(): MathSymbolJSON {\n\t\treturn {\n\t\t\ttype: 'mathSymbol',\n\t\t\targs: [this.symbol, { kind: this.kind }],\n\t\t};\n\t}\n}\n\nexport interface MathSymbolJSON {\n\ttype: string;\n\targs: [string, { kind: string }] | [] | [number] | [number, FractionJSON];\n}\n","import { Fraction, FractionJSON } from '../fractionClass';\nimport { MathSymbol } from '../algebra/mathSymbolClass';\nimport { numberToFraction } from '../utils';\n\n/**\n * Surd class representing \\\\sqrt{x}\n */\nexport class Surd extends MathSymbol {\n\tkind: 'surd';\n\tradicand: number;\n\n\tconstructor(radicand: number) {\n\t\tif (!(radicand >= 0 && Number.isInteger(radicand))) {\n\t\t\tthrow new RangeError(`${radicand} must be a non-negative integer for the Surd class`);\n\t\t}\n\t\tsuper(`\\\\sqrt{${radicand}}`);\n\t\tthis.kind = 'surd';\n\t\tthis.radicand = radicand;\n\t}\n\n\ttoJSON(): SurdJSON {\n\t\treturn {\n\t\t\ttype: 'surd',\n\t\t\targs: [this.radicand],\n\t\t};\n\t}\n}\n\nexport interface SurdJSON {\n\ttype: 'surd';\n\targs: [number];\n}\n\n/**\n * NthRootSymbol class representing \\\\sqrt[n]{x}\n */\nexport class RootSymbol extends MathSymbol {\n\tkind: 'rootSymbol';\n\tradicand: Fraction;\n\tn: number;\n\n\tconstructor(n: number, radicand: number | Fraction) {\n\t\tif (!(n >= 2 && Number.isInteger(n))) {\n\t\t\tthrow new RangeError(`${n} must be a integer >= 2 for the NthRootSymbol class`);\n\t\t}\n\t\tradicand = numberToFraction(radicand);\n\t\tsuper(`\\\\sqrt[${n}]{${radicand}}`);\n\t\tthis.kind = 'rootSymbol';\n\t\tthis.radicand = radicand;\n\t\tthis.n = n;\n\t}\n\n\ttoJSON(): RootSymbolJSON {\n\t\treturn {\n\t\t\ttype: 'rootSymbol',\n\t\t\targs: [this.n, this.radicand.toJSON()],\n\t\t};\n\t}\n}\n\nexport interface RootSymbolJSON {\n\ttype: 'rootSymbol';\n\targs: [number, FractionJSON];\n}\n","import { FractionJSON } from '../fractionClass';\n\nexport class MathSymbol {\n\tkind: string;\n\tsymbol: string;\n\n\tconstructor(symbol: string, options?: { kind?: string }) {\n\t\tconst { kind } = {\n\t\t\tkind: 'symbol',\n\t\t\t...options,\n\t\t};\n\t\tthis.kind = kind;\n\t\tthis.symbol = symbol;\n\t}\n\n\ttoString(): string {\n\t\treturn this.symbol;\n\t}\n\n\t/**\n\t * toJSON method that allows for quick reconstruction of class instance\n\t * by storing its constructor arguments\n\t */\n\ttoJSON(): MathSymbolJSON {\n\t\treturn {\n\t\t\ttype: 'mathSymbol',\n\t\t\targs: [this.symbol, { kind: this.kind }],\n\t\t};\n\t}\n}\n\nexport interface MathSymbolJSON {\n\ttype: string;\n\targs: [string, { kind: string }] | [] | [number] | [number, FractionJSON];\n}\n","export { gcd, lcm } from './gcd';\nexport { factorize } from './factorize';\nexport { numberToFraction } from './numberToFraction';\nexport { numberToNthRoot } from './numberToNthRoot';\nexport { numberToSquareRoot } from './numberToSquareRoot';\n","import { gcd } from './gcd';\n\n/**\n * Given a,b,...n,\n * returns\n * `{ k: sign*gcd(a,b,...,n), numbers: [a1,b1,...n1]}`\n * such that a+b+...+n = k(a1+b1+...+n1)\n */\nexport function factorize(...args: number[]): { k: number; numbers: number[] } {\n\tlet k = gcd(...args);\n\tif (args.filter((e) => e > 0).length === 0) {\n\t\tk = -k;\n\t}\n\treturn {\n\t\tk,\n\t\tnumbers: args.map((x) => x / k),\n\t};\n}\n","import { Fraction } from '../fractionClass';\n// import { NthRoot } from '../basic/rootClasses';\nimport { NthRoot } from '../algebra/sqrt';\n\n/**\n * takes an integer and/or Fraction, and returns a new Fraction instance\n * representing the number\n */\nexport function numberToNthRoot(n: number, x: number | Fraction | NthRoot): NthRoot {\n\tif (typeof x === 'number' || x instanceof Fraction) {\n\t\treturn new NthRoot(n, 1, x);\n\t}\n\treturn x.clone();\n}\n","import { Surd, RootSymbol } from '../basic';\nimport { Fraction, FractionJSON } from '../fractionClass';\n//import { BasicTerm } from './basicTermClass';\nimport { numberToFraction } from '../utils/numberToFraction';\nimport { numberToNthRoot } from '../utils/numberToNthRoot';\nimport { numberToSquareRoot } from '../utils/numberToSquareRoot';\nimport { Term } from './term';\n\n/**\n * the NthRoot class\n * `${coeff: Fraction, n: positive integer, radicand: non-negative fraction}`\n * representing $a \\sqrt[n]{b}$ where $a$ is the coefficient and $b$ is the radicand.\n *\n * Note that we do not support negative radicands at this point.\n * For odd `n`, you may want to consider 'hoisting' the negative sign to the coefficient)\n *\n * Simplification of perfect Nth-powers are only done if the radicand is made up of\n * prime factors less than 100.\n *\n * It is recommended to use the `SquareRoot` class instead of `NthRoot` for square roots.\n */\nexport class NthRoot extends Term {\n\t/** the n-th root */\n\tn: number;\n\t/** the non-negative integer inside the radical */\n\tradicand: Fraction;\n\tkind: 'nthRootTerm' | 'sqrtTerm';\n\tcoeff: Fraction;\n\n\t//// constructor\n\t/**\n\t * creates a new NthRoot instance representing $a \\sqrt[n]{b}$.\n\t * @param radicand only non-negative integers or Fractions are supported at this moment.\n\t * @param coeff coefficient of the radical (defaults to 1).\n\t */\n\tconstructor(n: number, radicand: number | Fraction, coeff: number | Fraction = 1) {\n\t\tif (!Number.isInteger(n) || n < 2) {\n\t\t\tthrow new Error('n must be a integer at least 2');\n\t\t}\n\t\tif (radicand.valueOf() < 0) {\n\t\t\tthrow new Error('radicand must be non-negative');\n\t\t}\n\t\t// 'rationalize'\n\t\tcoeff = numberToFraction(coeff);\n\t\tradicand = numberToFraction(radicand);\n\t\t// extract powers\n\t\tconst [aNum, bNum] = extractPowers(radicand.num, n);\n\t\tconst [aDen, bDen] = extractPowers(radicand.den, n);\n\t\tif (bNum === 1 || bDen === 1) {\n\t\t\tcoeff = coeff.times(aNum).divide(aDen);\n\t\t\tradicand = new Fraction(bNum, bDen);\n\t\t}\n\t\t// create term\n\t\t// edge cases for typesetting\n\t\tif (radicand.valueOf() === 0) {\n\t\t\tcoeff = new Fraction(0);\n\t\t}\n\t\tif (coeff.isEqualTo(0)) {\n\t\t\tradicand = new Fraction(1);\n\t\t}\n\t\tif (radicand.isEqualTo(1)) {\n\t\t\tsuper(coeff);\n\t\t} else {\n\t\t\tif (n === 2) {\n\t\t\t\tsuper(coeff, new Surd(radicand.valueOf()));\n\t\t\t} else {\n\t\t\t\tsuper(coeff, new RootSymbol(n, radicand));\n\t\t\t}\n\t\t}\n\t\tthis.coeff = coeff;\n\t\tthis.n = n;\n\t\tthis.radicand = radicand;\n\t\tthis.kind = 'nthRootTerm';\n\t}\n\n\t//// Arithmetic methods\n\n\t/**\n\t * radical multiplication: $a_1 \\sqrt[n]{b_1} \\times a_2 \\sqrt[n]{b_2} = a_1 a_2 \\sqrt[n]{b_1 b_2}$\n\t *\n\t * only valid if n is the same for both terms.\n\t */\n\ttimes(x: NthRoot | number | Fraction): NthRoot;\n\ttimes(x: string | Term): Term;\n\ttimes(x: NthRoot | number | Fraction | string | Term): NthRoot | Term {\n\t\tif (typeof x === 'number' || x instanceof Fraction) {\n\t\t\tx = numberToNthRoot(this.n, x);\n\t\t}\n\t\tif (!(x instanceof NthRoot)) {\n\t\t\treturn super.times(x);\n\t\t}\n\t\tif (this.n !== x.n) {\n\t\t\tthrow new Error('n must be the same for both terms');\n\t\t}\n\t\treturn new NthRoot(this.n, this.radicand.times(x.radicand), this.coeff.times(x.coeff));\n\t}\n\t/**\n\t * radical division: a_1 \\sqrt[n]{b_1} / a_2 \\sqrt[n]{b_2} = a_1 / a_2 * \\sqrt[n]{b_1 / b_2}$\n\t */\n\tdivide(x: NthRoot | number | Fraction): NthRoot {\n\t\tx = numberToNthRoot(this.n, x);\n\t\tif (this.n !== x.n) {\n\t\t\tthrow new Error('n must be the same for both terms');\n\t\t}\n\t\treturn new NthRoot(this.n, this.radicand.divide(x.radicand), this.coeff.divide(x.coeff));\n\t}\n\n\t/**\n\t * exponentiation\n\t *\n\t * @param n non-negative integer\n\t * @returns this NthRoot to the power of n\n\t */\n\tpow(n: number): NthRoot {\n\t\tif (!Number.isInteger(n) || n < 0) {\n\t\t\tthrow new Error('n must be a non-negative integer');\n\t\t}\n\t\treturn new NthRoot(this.n, this.radicand.pow(n), this.coeff.pow(n));\n\t}\n\n\t/**\n\t * @returns the value of this NthRoot in the primitive number type\n\t */\n\tvalueOf(): number {\n\t\treturn Math.pow(this.radicand.valueOf(), 1 / this.n) * this.coeff.valueOf();\n\t}\n\n\t//// Comparison methods\n\t/**\n\t * tests for equality\n\t */\n\tisEqualTo(x: number | Fraction | NthRoot): boolean {\n\t\tx = x instanceof NthRoot ? x : new NthRoot(this.n, 1, x);\n\t\tif (x.coeff.isEqualTo(0) || this.coeff.isEqualTo(0)) {\n\t\t\treturn x.coeff.isEqualTo(0) && this.coeff.isEqualTo(0);\n\t\t}\n\t\treturn this.n === x.n && this.radicand.isEqualTo(x.radicand) && this.coeff.isEqualTo(x.coeff);\n\t}\n\t/**\n\t * @returns true if this NthRoot represents a rational number\n\t */\n\tisRational(): boolean {\n\t\treturn this.radicand.valueOf() === 1 || this.radicand.valueOf() === 0;\n\t}\n\n\t/**\n\t * if this NthRoot is a rational number, returns the rational number as a `Fraction` instance.\n\t *\n\t * Warning: throws if NthRoot is not a rational number.\n\t */\n\ttoFraction(): Fraction {\n\t\tif (!this.isRational()) {\n\t\t\tthrow new Error('NthRoot is not a rational number');\n\t\t}\n\t\treturn this.coeff.clone();\n\t}\n\n\ttoPrecision(precision: number): string {\n\t\treturn `${Number(this.valueOf().toPrecision(precision))}`;\n\t}\n\ttoFixed(digits: number): string {\n\t\treturn this.valueOf().toFixed(digits);\n\t}\n\n\tclone(): NthRoot {\n\t\treturn new NthRoot(this.n, this.radicand.clone(), this.coeff.clone());\n\t}\n}\n\n/**\n * the SquareRoot class\n * `${coeff: Fraction, radicand: non-negative integer}`\n * representing $a \\sqrt{b}$ where $a$ is the coefficient and $b$ is the radicand.\n *\n * Note that we do not support negative radicands at this point.\n */\nexport class SquareRoot extends NthRoot {\n\tkind: 'sqrtTerm';\n\t//// constructor\n\t/**\n\t * creates a new SquareRoot instance representing $a \\sqrt{b}$.\n\t * @param radicand only non-negative integers or Fractions are supported at this moment.\n\t * @param coeff coefficient of the radical (defaults to 1).\n\t *\n\t * If a fraction is provided as the radicand, we will 'rationalize' it such that\n\t * $a \\sqrt{b/c}$ is converted to $\\frac{a}{c} \\sqrt{bc}$ so that the radicand is an integer.\n\t *\n\t * we will also simplify our radical such that the final surd $a\\sqrt{b}$ is such that b square free,\n\t * up to prime powers less than 100\n\t */\n\tconstructor(radicand: number | Fraction, coeff: number | Fraction = 1) {\n\t\tif (radicand.valueOf() < 0) {\n\t\t\tthrow new Error('radicand must be non-negative');\n\t\t}\n\t\t// 'rationalize'\n\t\tcoeff = numberToFraction(coeff);\n\t\tif (typeof radicand !== 'number') {\n\t\t\tconst c = radicand.den;\n\t\t\tradicand = radicand.num * c;\n\t\t\tcoeff = coeff.divide(c);\n\t\t}\n\t\t// extract powers\n\t\tconst [a, b] = extractPowers(radicand);\n\t\tcoeff = coeff.times(a);\n\t\tradicand = b;\n\t\tsuper(2, radicand, coeff);\n\t\t// edge cases for typesetting\n\t\tthis.kind = 'sqrtTerm';\n\t}\n\n\t//// Arithmetic methods\n\n\t/**\n\t * radical multiplication: $a_1 \\sqrt[n]{b_1} \\times a_2 \\sqrt[n]{b_2} = a_1 a_2 \\sqrt[n]{b_1 b_2}$\n\t *\n\t * only valid if n is the same for both terms.\n\t */\n\ttimes(x: SquareRoot | number | Fraction): SquareRoot;\n\ttimes(x: string | Term): Term;\n\ttimes(x: SquareRoot | number | Fraction | string | Term): Term | SquareRoot {\n\t\tif (typeof x === 'number' || x instanceof Fraction) {\n\t\t\tx = new SquareRoot(1, x);\n\t\t}\n\t\tif (!(x instanceof SquareRoot)) {\n\t\t\treturn super.times(x);\n\t\t} else {\n\t\t\treturn new SquareRoot(this.radicand.times(x.radicand), this.coeff.times(x.coeff));\n\t\t}\n\t}\n\t/**\n\t * radical division: a_1 \\sqrt[n]{b_1} / a_2 \\sqrt[n]{b_2} = a_1 / a_2 * \\sqrt[n]{b_1 / b_2}$\n\t */\n\tdivide(x: SquareRoot | number | Fraction): SquareRoot {\n\t\tx = numberToSquareRoot(x);\n\t\treturn new SquareRoot(this.radicand.divide(x.radicand), this.coeff.divide(x.coeff));\n\t}\n\t/**\n\t * addition of radicals: only work for same radicand currently\n\t */\n\tplus(x: SquareRoot): SquareRoot {\n\t\tif (this.isEqualTo(0)) {\n\t\t\treturn x;\n\t\t}\n\t\tif (x.isEqualTo(0)) {\n\t\t\treturn this;\n\t\t}\n\t\tif (this.radicand.isEqualTo(x.radicand)) {\n\t\t\treturn new SquareRoot(this.radicand, this.coeff.plus(x.coeff));\n\t\t}\n\t\tthrow new Error(`${x} and ${this} have different radicands. Consider using an Expression class`);\n\t}\n\t/**\n\t * subtraction of radicals: only work for same radicand currently\n\t */\n\tminus(x: SquareRoot): SquareRoot {\n\t\treturn this.plus(x.negative());\n\t}\n\n\t/**\n\t * @returns negative of this SquareRoot\n\t */\n\tnegative(): SquareRoot {\n\t\treturn new SquareRoot(this.radicand.clone(), this.coeff.negative());\n\t}\n\n\t/**\n\t * exponentiation\n\t *\n\t * @param n non-negative integer\n\t * @returns this NthRoot to the power of n\n\t */\n\tpow(n: number): SquareRoot {\n\t\tif (!Number.isInteger(n) || n < 0) {\n\t\t\tthrow new Error('n must be a non-negative integer');\n\t\t}\n\t\treturn new SquareRoot(this.radicand.pow(n), this.coeff.pow(n));\n\t}\n\n\tabs(): SquareRoot {\n\t\treturn new SquareRoot(this.radicand, this.coeff.abs());\n\t}\n\n\tsquare(): Fraction {\n\t\treturn this.coeff.pow(2).times(this.radicand);\n\t}\n\n\t/**\n\t * @returns the reciprocal this SquareRoot\n\t */\n\treciprocal(): SquareRoot {\n\t\treturn new SquareRoot(this.radicand.reciprocal(), this.coeff.reciprocal());\n\t}\n\n\tclone(): SquareRoot {\n\t\treturn new SquareRoot(this.radicand.clone(), this.coeff.clone());\n\t}\n\n\t/**\n\t * the number one in SquareRoot class\n\t */\n\tstatic ONE = new SquareRoot(1);\n\n\ttoJSON(): SquareRootJSON {\n\t\treturn {\n\t\t\ttype: 'squareRoot',\n\t\t\targs: [this.radicand.toJSON(), this.coeff.toJSON()],\n\t\t};\n\t}\n}\n\n/**\n * takes an integer x, and returns [a, b] such that x = a^n b and b is n-power free (up to 100)\n * */\nfunction extractPowers(x: number, n = 2, y = 1): [number, number] {\n\t//if (!Number.isInteger(n) || n < 2) {\n\t//  throw 'n must be an integer more than 2';\n\t//}\n\tif (x == 0) {\n\t\treturn [0, 0];\n\t}\n\t// primes up to 100\n\tconst primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n\tfor (const prime of primes) {\n\t\tif (x % Math.pow(prime, n) === 0) {\n\t\t\treturn extractPowers(x / Math.pow(prime, n), n, y * prime);\n\t\t} else if (x < Math.pow(prime, n)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn [y, x];\n}\n\nexport interface SquareRootJSON {\n\ttype: string;\n\targs: [FractionJSON, FractionJSON];\n}\n","import { Fraction } from '../fractionClass';\n// import { SquareRoot } from '../basic/rootClasses';\nimport { SquareRoot } from '../algebra/sqrt';\n\n/**\n * takes an integer and/or Fraction, and returns a new Fraction instance\n * representing the number\n */\nexport function numberToSquareRoot(x: number | Fraction | SquareRoot): SquareRoot {\n\tif (typeof x === 'number' || x instanceof Fraction) {\n\t\treturn new SquareRoot(1, x);\n\t}\n\treturn x.clone();\n}\n","import { Fraction, FractionJSON } from '../fractionClass';\n//import {\n//\tSquareRoot,\n//\tVariableTerm,\n//\tBasicTerm,\n//\tImaginary,\n//\tSquareRootJSON,\n//\tVariableTermJSON,\n//\tImaginaryJSON,\n//} from '../basic';\nimport {\n\tMathSymbol,\n\tMathSymbolJSON,\n\tImaginarySymbol,\n\t//ImaginarySymbolJSON,\n\tSurd,\n\tSurdJSON,\n\t//RootSymbol,\n\t//RootSymbolJSON\n} from '../basic';\nimport { numberToFraction } from '../utils/numberToFraction';\n//import { SquareRoot, SquareRootJSON } from './sqrt';\n//import { Expression } from './expressionClass';\n\n/**\n * A term represented by k x_1 x_2 ... x_n, where k is the coefficient\n * and x_i represent \"basic units\" (square roots, variables and the imaginary unit)\n */\n\nexport class Term {\n\tkind: string;\n\tcoeff: Fraction;\n\tsymbols: { [key: string]: { symbol: MathSymbol | Surd; power: Fraction } };\n\n\tconstructor(\n\t\t...args: (\n\t\t\t| number\n\t\t\t| Fraction\n\t\t\t| string\n\t\t\t| MathSymbol\n\t\t\t| ImaginarySymbol\n\t\t\t| Surd\n\t\t\t//|RootSymbol\n\t\t\t| [string | MathSymbol, number | Fraction]\n\t\t)[]\n\t) {\n\t\tlet coeff = new Fraction(1);\n\t\tlet symbols: { [key: string]: { symbol: MathSymbol | Surd; power: Fraction } } = {};\n\t\tlet imagCount = 0;\n\t\tlet surdArg: number = 1;\n\t\targs.forEach((x) => {\n\t\t\tif (Array.isArray(x)) {\n\t\t\t\tconst [symbol, power] = x;\n\t\t\t\tif (symbol === 'i' || symbol instanceof ImaginarySymbol) {\n\t\t\t\t\timagCount++;\n\t\t\t\t} else {\n\t\t\t\t\tconst mathSymbol = typeof symbol === 'string' ? new MathSymbol(symbol) : symbol;\n\t\t\t\t\tappendToSymbols(symbols, mathSymbol, power);\n\t\t\t\t}\n\t\t\t} else if (typeof x === 'string') {\n\t\t\t\tif (x === 'i') {\n\t\t\t\t\timagCount++;\n\t\t\t\t} else if (x === 'surd') {\n\t\t\t\t\tthrow new RangeError(`'surd' is a reserved symbol name in the Term class`);\n\t\t\t\t} else {\n\t\t\t\t\tconst mathSymbol = new MathSymbol(x);\n\t\t\t\t\tappendToSymbols(symbols, mathSymbol);\n\t\t\t\t}\n\t\t\t} else if (typeof x === 'number' || x instanceof Fraction) {\n\t\t\t\tcoeff = coeff.times(x);\n\t\t\t} else if (x instanceof ImaginarySymbol) {\n\t\t\t\timagCount++;\n\t\t\t} else if (x instanceof Surd) {\n\t\t\t\tsurdArg *= x.radicand;\n\t\t\t} else {\n\t\t\t\tif (x.symbol === 'i' || x.symbol === 'surd') {\n\t\t\t\t\tthrow new RangeError(`'i' and 'surd' are reserved symbol names in the Term class`);\n\t\t\t\t}\n\t\t\t\t// MathSymbol\n\t\t\t\tappendToSymbols(symbols, x);\n\t\t\t}\n\t\t});\n\t\t// handle imaginary\n\t\timagCount = imagCount % 4;\n\t\tif (imagCount === 2) {\n\t\t\tcoeff = coeff.times(-1);\n\t\t} else if (imagCount === 1) {\n\t\t\tsymbols['i'] = { symbol: new ImaginarySymbol(), power: new Fraction(1) };\n\t\t} else if (imagCount === 3) {\n\t\t\tcoeff = coeff.times(-1);\n\t\t\tsymbols['i'] = { symbol: new ImaginarySymbol(), power: new Fraction(1) };\n\t\t}\n\t\t// handle surds. sqrt(surdArg) = y sqrt{x}\n\t\tconst [y, x] = extractPowers(surdArg);\n\t\tcoeff = coeff.times(y);\n\t\tif (x !== 1) {\n\t\t\tsymbols['surd'] = { symbol: new Surd(x), power: new Fraction(1) };\n\t\t}\n\t\t// set up class props\n\t\tthis.coeff = coeff;\n\t\tif (this.coeff.isEqualTo(0)) {\n\t\t\tsymbols = {};\n\t\t}\n\t\tfor (const symbol in symbols) {\n\t\t\tif (symbols[symbol].power.isEqualTo(0)) {\n\t\t\t\tdelete symbols[symbol];\n\t\t\t}\n\t\t}\n\t\tthis.symbols = symbols;\n\t\tconst length = Object.keys(symbols).length;\n\t\tif (length === 0) {\n\t\t\tthis.kind = 'fractionTerm';\n\t\t} else if (length === 1) {\n\t\t\tif ('surd' in symbols) {\n\t\t\t\tthis.kind = 'sqrtTerm';\n\t\t\t} else if ('i' in symbols) {\n\t\t\t\tthis.kind = 'imaginaryTerm';\n\t\t\t} else {\n\t\t\t\tthis.kind = 'singleton';\n\t\t\t}\n\t\t} else {\n\t\t\tthis.kind = 'term';\n\t\t}\n\t}\n\n\tisSurd(): boolean {\n\t\treturn 'surd' in this.symbols;\n\t}\n\n\tisImag(): boolean {\n\t\treturn 'i' in this.symbols;\n\t}\n\n\tisRational(): boolean {\n\t\treturn Object.keys(this.symbols).length === 0;\n\t}\n\n\t/**\n\t * check if two terms are 'like terms'\n\t * (ie same symbols with same powers)\n\t */\n\tisLike(x: Term): boolean {\n\t\tif (Object.keys(this.symbols).length !== Object.keys(x.symbols).length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (const term in this.symbols) {\n\t\t\tif (!(term in x.symbols)) {\n\t\t\t\treturn false;\n\t\t\t} else if (this.symbols[term].power.isNotEqualTo(x.symbols[term].power)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Multiplication\n\t */\n\ttimes(\n\t\tx:\n\t\t\t| number\n\t\t\t| Fraction\n\t\t\t| string\n\t\t\t| MathSymbol\n\t\t\t| ImaginarySymbol\n\t\t\t| Surd\n\t\t\t//|RootSymbol\n\t\t\t| [string | MathSymbol, number | Fraction]\n\t\t\t| Term,\n\t): Term {\n\t\tif (typeof x === 'number' || x instanceof Fraction) {\n\t\t\treturn new Term(this.coeff.times(x), ...symbolsToArray(this.symbols));\n\t\t} else if (\n\t\t\ttypeof x === 'string' ||\n\t\t\tx instanceof MathSymbol ||\n\t\t\tx instanceof ImaginarySymbol ||\n\t\t\tx instanceof Surd ||\n\t\t\tArray.isArray(x)\n\t\t) {\n\t\t\treturn new Term(this.coeff, ...symbolsToArray(this.symbols), x);\n\t\t} else {\n\t\t\t// Term type\n\t\t\treturn new Term(this.coeff.times(x.coeff), ...symbolsToArray(this.symbols), ...symbolsToArray(x.symbols));\n\t\t}\n\t}\n\n\tdivide(\n\t\tx:\n\t\t\t| number\n\t\t\t| Fraction\n\t\t\t| string\n\t\t\t| MathSymbol\n\t\t\t| ImaginarySymbol\n\t\t\t| Surd\n\t\t\t//|RootSymbol\n\t\t\t| [string | MathSymbol, number | Fraction]\n\t\t\t| Term,\n\t): Term {\n\t\tif (typeof x === 'number' || x instanceof Fraction) {\n\t\t\treturn new Term(this.coeff.divide(x), ...symbolsToArray(this.symbols));\n\t\t} else if (typeof x === 'string' || x instanceof MathSymbol) {\n\t\t\treturn new Term(this.coeff, ...symbolsToArray(this.symbols), [x, -1]);\n\t\t} else if (x instanceof ImaginarySymbol) {\n\t\t\treturn new Term(this.coeff.negative(), ...symbolsToArray(this.symbols), x);\n\t\t} else if (x instanceof Surd) {\n\t\t\treturn new Term(this.coeff.divide(x.radicand), ...symbolsToArray(this.symbols), x);\n\t\t} else if (Array.isArray(x)) {\n\t\t\treturn new Term(this.coeff, ...symbolsToArray(this.symbols), [x[0], numberToFraction(x[1]).negative()]);\n\t\t} else {\n\t\t\t// Term type\n\t\t\treturn this.times(x.reciprocal());\n\t\t}\n\t}\n\n\tnegative(): Term {\n\t\treturn new Term(this.coeff.negative(), ...symbolsToArray(this.symbols));\n\t}\n\n\tplus(x: number | Fraction | Term): Term {\n\t\tif (!(x instanceof Term)) {\n\t\t\tx = new Term(x);\n\t\t}\n\t\tif (!this.isLike(x)) {\n\t\t\tthrow new Error(\n\t\t\t\t`addition of terms only work for like terms at the moment.\n\t\t\t\t\t${this} and ${x} received. Consider using the Expression class`,\n\t\t\t);\n\t\t}\n\t\treturn new Term(this.coeff.plus(x.coeff), ...symbolsToArray(this.symbols));\n\t}\n\tminus(x: number | Fraction | Term): Term {\n\t\tif (!(x instanceof Term)) {\n\t\t\tx = new Term(x);\n\t\t}\n\t\tif (!this.isLike(x)) {\n\t\t\tthrow new Error(\n\t\t\t\t`subtraction of terms only work for like terms at the moment.\n\t\t\t\t\t${this} and ${x} received. Consider using the Expression class`,\n\t\t\t);\n\t\t}\n\t\treturn new Term(this.coeff.minus(x.coeff), ...symbolsToArray(this.symbols));\n\t}\n\n\tpow(n: number | Fraction): Term {\n\t\tif (n instanceof Fraction) {\n\t\t\tif (n.den !== 1) {\n\t\t\t\tthrow new RangeError(`only integral n are allowed for term.pow at the moment. ${n} received`);\n\t\t\t}\n\t\t\tn = n.valueOf();\n\t\t}\n\t\tif (!Number.isInteger(n)) {\n\t\t\tthrow new RangeError(`only integral n are allowed for term.pow at the moment. ${n} received`);\n\t\t}\n\t\tconst multiple = n < 0 ? this.reciprocal() : this;\n\t\tlet x = new Term(1);\n\t\tfor (let i = 0; i < Math.abs(n); i++) {\n\t\t\tx = x.times(multiple);\n\t\t}\n\t\treturn x;\n\t}\n\n\treciprocal(): Term {\n\t\tconst symbolsArray = Object.keys(this.symbols).map((x) => {\n\t\t\treturn [this.symbols[x].symbol, this.symbols[x].power.reciprocal()] as [MathSymbol, Fraction];\n\t\t});\n\t\treturn new Term(this.coeff.reciprocal(), ...symbolsArray);\n\t}\n\n\t// applies negative if surd or imaginary term present\n\t//conjugate(): Term {\n\t//\treturn this.isImag || this.isSurd ? this.negative() : this.clone();\n\t//}\n\n\tsubIn(x: number | Fraction, symbol: string | MathSymbol = 'x'): Fraction {\n\t\tlet y = this.coeff;\n\t\tsymbol = typeof symbol === 'string' ? symbol : symbol.symbol;\n\t\tfor (const symbol2 in this.symbols) {\n\t\t\tif (symbol2 === symbol) {\n\t\t\t\ty = y.times(numberToFraction(x).pow(this.symbols[symbol2].power));\n\t\t\t} else {\n\t\t\t\tthrow new Error(`symbols other than ${symbol} (${symbol2}) found`);\n\t\t\t}\n\t\t}\n\t\treturn y;\n\t}\n\n\tsubInNumber(x: number, symbol: string | MathSymbol = 'x'): number {\n\t\tlet y = this.coeff.valueOf();\n\t\tfor (const symbol2 in this.symbols) {\n\t\t\tif (symbol2 === symbol) {\n\t\t\t\ty = y * Math.pow(x, this.symbols[symbol2].power.valueOf());\n\t\t\t} else if (symbol2 === 'surd') {\n\t\t\t\tconst surd = this.symbols[symbol2].symbol;\n\t\t\t\tif (surd instanceof Surd) {\n\t\t\t\t\ty = y * Math.sqrt(surd.radicand);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(`unexpected error: non-surd found`);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error(`symbols other than ${symbol} (${symbol2}) found`);\n\t\t\t}\n\t\t}\n\t\treturn y;\n\t}\n\n\tvalueOf(): number {\n\t\t// TODO: 'e', 'pi', 'ln Term'\n\t\tlet y = this.coeff.valueOf();\n\t\tfor (const symbol2 in this.symbols) {\n\t\t\tif (symbol2 === 'surd') {\n\t\t\t\tconst surd = this.symbols[symbol2].symbol;\n\t\t\t\tif (surd instanceof Surd) {\n\t\t\t\t\ty = y * Math.sqrt(surd.radicand);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(`unexpected error: non-surd found`);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error(`symbols other than surds (${symbol2}) found`);\n\t\t\t}\n\t\t}\n\t\treturn y;\n\t}\n\n\tsquare(): Term | Fraction {\n\t\treturn this.pow(2);\n\t}\n\n\tclone(): Term {\n\t\treturn new Term(this.coeff.clone(), ...symbolsToArray(this.symbols));\n\t}\n\n\ttoString(): string {\n\t\tif (this.coeff.isEqualTo(0)) {\n\t\t\treturn `0`;\n\t\t}\n\t\tlet numString = '',\n\t\t\tdenString = '';\n\t\tfor (const key in this.symbols) {\n\t\t\tconst { power, symbol } = this.symbols[key];\n\t\t\tif (power.isEqualTo(1)) {\n\t\t\t\tif (numString !== '') {\n\t\t\t\t\tnumString += ' ';\n\t\t\t\t}\n\t\t\t\tnumString += `${symbol}`;\n\t\t\t} else if (power.isEqualTo(-1)) {\n\t\t\t\tif (denString !== '') {\n\t\t\t\t\tdenString += ' ';\n\t\t\t\t}\n\t\t\t\tdenString += `${symbol}`;\n\t\t\t} else if (power.isGreaterThan(0)) {\n\t\t\t\tconst powerString = `${power}`.length > 1 ? `{${power}}` : `${power}`;\n\t\t\t\tif (numString !== '') {\n\t\t\t\t\tnumString += ' ';\n\t\t\t\t}\n\t\t\t\tnumString += `${symbol}^${powerString}`;\n\t\t\t} else if (power.isLessThan(0)) {\n\t\t\t\tconst powerString = `${power.abs()}`.length > 1 ? `{${power.abs()}}` : `${power.abs()}`;\n\t\t\t\tif (denString !== '') {\n\t\t\t\t\tdenString += ' ';\n\t\t\t\t}\n\t\t\t\tdenString += `${symbol}^${powerString}`;\n\t\t\t} else {\n\t\t\t\tthrow new Error(`Unexpected power 0 term`);\n\t\t\t}\n\t\t}\n\t\t// non-fraction\n\t\tif (denString === '') {\n\t\t\treturn numString === '' ? this.coeff.toString() : termToString(this.coeff, numString);\n\t\t}\n\t\t// fraction type\n\t\tconst sign = this.coeff.isGreaterThan(0) ? '' : '- ';\n\t\tif (numString === '') {\n\t\t\treturn `${sign}\\\\frac{${this.coeff.abs().num}}{${termToString(this.coeff.den, denString)}}`;\n\t\t} else {\n\t\t\treturn `${sign}\\\\frac{${termToString(this.coeff.abs().num, numString)}}{${termToString(\n\t\t\t\tthis.coeff.den,\n\t\t\t\tdenString,\n\t\t\t)}}`;\n\t\t}\n\t}\n\n\t/**\n\t * toJSON method that allows for quick reconstruction of class instance\n\t * by storing its constructor arguments\n\t */\n\ttoJSON(): { type: string; args: [FractionJSON, ...(MathSymbolJSON | SurdJSON)[]] | [FractionJSON, FractionJSON] } {\n\t\treturn {\n\t\t\ttype: 'term',\n\t\t\targs: [this.coeff.toJSON(), ...Object.keys(this.symbols).map((x) => this.symbols[x].symbol.toJSON())],\n\t\t};\n\t}\n}\n\n/**\n * append MathSymbol to symbols object\n *\n * @param symbols the symbols object\n * @param symbol the MathSymbol\n * @param power the power (number/Fraction). Defaults to 1\n */\nfunction appendToSymbols(\n\tsymbols: { [key: string]: { symbol: MathSymbol; power: Fraction } },\n\tsymbol: MathSymbol,\n\tpower: number | Fraction = 1,\n): void {\n\tif (symbol.symbol in symbols) {\n\t\tsymbols[symbol.symbol].power = symbols[symbol.symbol].power.plus(power);\n\t} else {\n\t\tsymbols[symbol.symbol] = {\n\t\t\tsymbol: symbol,\n\t\t\tpower: numberToFraction(power),\n\t\t};\n\t}\n}\n\n/**\n * convert the symbols object to an array [symbol: MathSymbol, power: Fraction][]\n *\n * @param symbols: symbols object\n * @returns [symbol: MathSymbol, power: Fraction][]\n */\nfunction symbolsToArray(symbols: { [key: string]: { symbol: MathSymbol; power: Fraction } }): [MathSymbol, Fraction][] {\n\treturn Object.keys(symbols).map((key) => [symbols[key].symbol, symbols[key].power]);\n}\n\n/**\n * handle edge cases where coeff is 0/1/-1\n */\nfunction termToString(coeff: number | Fraction, term: string): string {\n\tcoeff = numberToFraction(coeff);\n\tif (coeff.isEqualTo(0)) {\n\t\treturn `0`;\n\t} else if (coeff.isEqualTo(1)) {\n\t\treturn term;\n\t} else if (coeff.isEqualTo(-1)) {\n\t\treturn `- ${term}`;\n\t} else {\n\t\treturn `${coeff} ${term}`;\n\t}\n}\n\n/** takes integers x and n, and returns [a, b] such that x = a^n b.\n * Only work for prime factors up to 100.\n *\n * @param x integer to extract powers from\n * @param options {y?: number, n?: number} defaults to y=1, n=2.\n * y facilitates a recursive algorithm while n is the power to be extracted.\n *\n */\nfunction extractPowers(x: number, options?: { y?: number; n?: number }): [number, number] {\n\tif (x === 0) {\n\t\treturn [0, 0];\n\t}\n\tconst { y, n } = {\n\t\ty: 1,\n\t\tn: 2,\n\t\t...options,\n\t};\n\tif (!(Number.isInteger(n) && n >= 2)) {\n\t\tthrow new RangeError(`n must be an integer at least 2. ${n} received`);\n\t}\n\tconst primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n\tfor (const prime of primes) {\n\t\tif (x % Math.pow(prime, n) === 0) {\n\t\t\treturn extractPowers(x / Math.pow(prime, n), { n, y: y * prime });\n\t\t} else if (x < Math.pow(prime, n)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn [y, x];\n}\n","import { Fraction, FractionJSON } from '../fractionClass';\nimport { MathSymbol } from '../algebra/mathSymbolClass';\n\n/**\n * Imaginary class representing 'ki', where i is the complex unit\n */\nexport class ImaginarySymbol extends MathSymbol {\n\tkind: 'imaginarySymbol';\n\n\tconstructor() {\n\t\tsuper('\\\\mathrm{i}');\n\t\tthis.kind = 'imaginarySymbol';\n\t}\n\n\ttoJSON(): ImaginarySymbolJSON {\n\t\treturn {\n\t\t\ttype: 'imaginarySymbol',\n\t\t\targs: [],\n\t\t};\n\t}\n}\n\nexport interface ImaginarySymbolJSON {\n\ttype: 'imaginarySymbol';\n\targs: [];\n}\n","//export { Term } from './termClass';\nexport { Term } from './term';\n//export { Expression } from './expressionClass';\nexport { Expression } from './expression';\nexport { Polynomial } from './polynomialClass';\nexport { NthRoot, SquareRoot } from './sqrt';\n","import { Term } from './term';\nimport { Fraction } from '../fractionClass';\nimport {\n\tVariableTerm,\n\t//SquareRoot,\n\tImaginary,\n} from '../basic';\nimport { SquareRoot } from './sqrt';\n\n/**\n * Expression class representing the sum of `Terms`\n */\nexport class Expression {\n\tkind: string;\n\t/** array of terms making up the expression */\n\tterms: Term[] = [];\n\n\t/**\n\t * Creates a new Expression\n\t * @param args one or more `Term`s\n\t * `number` and `Fraction` types will be transformed into constant terms,\n\t *  while `string` type will be transformed into a term with coefficient 1\n\t */\n\tconstructor(\n\t\t...args: (number | Fraction | string | [string, number | Fraction] | SquareRoot | Term | ExpressionOptions)[]\n\t) {\n\t\tlet terms: Term[] = [];\n\t\tlet kind = 'expression';\n\t\targs.forEach((x) => {\n\t\t\tif (typeof x === 'object' && 'expressionKind' in x) {\n\t\t\t\tkind = x.expressionKind;\n\t\t\t} else {\n\t\t\t\tconst xTerm = x instanceof Term || x instanceof SquareRoot ? x : new Term(x);\n\t\t\t\tconst i = terms.findIndex((y) => y.isLike(xTerm));\n\t\t\t\tif (i === -1) {\n\t\t\t\t\tterms.push(xTerm);\n\t\t\t\t} else {\n\t\t\t\t\tterms = [...terms.slice(0, i), terms[i].plus(xTerm), ...terms.slice(i + 1)];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tthis.terms = terms.filter((x) => !x.coeff.isEqualTo(0));\n\t\tthis.kind = kind;\n\t}\n\n\t/**\n\t * `toString` method\n\t *\n\t * @returns the LaTeX string representation of the sum of all the terms\n\t */\n\ttoString(): string {\n\t\tif (this.terms.length === 0) {\n\t\t\treturn '0';\n\t\t}\n\t\tlet outputString = this.terms[0].toString();\n\t\tthis.terms.slice(1).forEach((term) => {\n\t\t\toutputString += term.coeff.isGreaterThan(0) ? ` + ${term}` : ` ${term}`;\n\t\t});\n\t\treturn outputString;\n\t}\n\n\t/**\n\t * toJSON method that allows for quick reconstruction of class instance\n\t * by storing its constructor arguments\n\t */\n\ttoJSON(): { type: string; args: any[] } {\n\t\treturn {\n\t\t\ttype: 'expression',\n\t\t\targs: this.terms,\n\t\t};\n\t}\n\n\t/**\n\t * performs scalar multiplication on each term of this\n\t */\n\ttimes(k: number | Fraction | string | SquareRoot | Term | Expression): Expression {\n\t\tif (!(k instanceof Expression)) {\n\t\t\tconst terms = this.terms.map((term) => term.times(k));\n\t\t\treturn new Expression(...terms);\n\t\t}\n\t\treturn k.terms.reduce((exp, term) => exp.plus(this.times(term)), new Expression(0));\n\t}\n\n\tdivide(x: number | Fraction | string | SquareRoot | Term | Expression): Expression {\n\t\tif (x instanceof Expression) {\n\t\t\tthrow new RangeError(`division by Expression not supported at the moment`);\n\t\t}\n\t\treturn new Expression(...this.terms.map((y) => y.divide(x)));\n\t}\n\n\t/** applies negative to square root and imaginary terms */\n\t//conjugate(): Expression {\n\t//\tconst terms = this.terms.map((term) => term.conjugate());\n\t//\treturn new Expression(...terms);\n\t//}\n\n\tnegative(): Expression {\n\t\treturn new Expression(...this.terms.map((term) => term.negative()));\n\t}\n\n\tpow(n: number): Expression {\n\t\tif (!Number.isInteger(n) || n < 0) {\n\t\t\tthrow new Error('Exponent must be a non-negative integer');\n\t\t}\n\t\tlet exp = new Expression(1);\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\texp = exp.times(this);\n\t\t}\n\t\treturn exp;\n\t}\n\n\tsquare(): Expression {\n\t\treturn this.pow(2);\n\t}\n\n\tsubIn(x: number | Fraction): Fraction {\n\t\treturn this.terms.reduce((sum, term) => sum.plus(term.subIn(x)), new Fraction(0));\n\t}\n\n\tsubInNumber(x: number): number {\n\t\treturn this.terms.reduce((sum, term) => sum + term.subInNumber(x), 0);\n\t}\n\n\tvalueOf(): number {\n\t\treturn this.terms.reduce((sum, term) => sum + term.valueOf(), 0);\n\t}\n\n\t/**\n\t * adds the two expressions,\n\t * similar to concatenating the terms in the two expressions, combining like terms\n\t *\n\t * @returns the sum\n\t */\n\tplus(newExpression: number | Fraction | string | SquareRoot | Term | Expression): Expression {\n\t\treturn newExpression instanceof Expression\n\t\t\t? new Expression(...this.terms, ...newExpression.terms)\n\t\t\t: new Expression(...this.terms, newExpression);\n\t}\n\n\t/**\n\t * subtracts this expression by the given expression\n\t *\n\t * @returns the difference\n\t */\n\tminus(newExpression: number | Fraction | string | SquareRoot | Term | Expression): Expression {\n\t\tif (!(newExpression instanceof Expression)) {\n\t\t\tnewExpression = new Expression(newExpression);\n\t\t}\n\t\treturn this.plus(newExpression.times(-1));\n\t}\n\n\t/**\n\t * clones the object, creating a new instance of this expression\n\t */\n\tclone(): Expression {\n\t\tconst newTerms = this.terms.map((term) => term.clone());\n\t\treturn new Expression(...newTerms);\n\t}\n}\n\nexport interface ExpressionOptions {\n\texpressionKind: string;\n}\n","//import { Expression } from './expressionClass';\n//import { VariableTerm, SquareRoot } from '../basic';\nimport { Expression } from './expression';\nimport { SquareRoot } from './sqrt';\nimport { Term } from './term';\nimport { Fraction } from '../fractionClass';\nimport { numberToFraction } from '../utils/numberToFraction';\n\n/**\n * Polynomial class representing \"ax^n + bx^n-1 + ... + k\"\n */\nexport class Polynomial extends Expression {\n\t/** array of coefficients in ascending order, starting from constant term */\n\tcoeffs: Fraction[];\n\t/** whether polynomial in ascending or descending order */\n\tascending: boolean;\n\t/** degree of the polynomial */\n\tdegree: number;\n\t/** variable name (e.g. \"x\") */\n\tvariable: string;\n\n\t/**\n\t * Creates a new Polynomial instance\n\t * @param coeffs array of coefficients. if a number/fraction is provided, will create the polynomial \"kx\".\n\t * @param options defaults to `{ascending: false, degree: coeffs.length-1, variable: 'x'}`\n\t */\n\tconstructor(\n\t\tcoeffs: (number | Fraction)[] | (number | Fraction) | string,\n\t\toptions?: { ascending?: boolean; degree?: number; variable?: string },\n\t) {\n\t\tlet variableDefault = 'x';\n\t\tif (!Array.isArray(coeffs)) {\n\t\t\tif (typeof coeffs === 'string') {\n\t\t\t\tvariableDefault = coeffs;\n\t\t\t\tcoeffs = options?.ascending ? [0, 1] : [1, 0];\n\t\t\t} else {\n\t\t\t\tcoeffs = options?.ascending ? [0, coeffs] : [coeffs, 0];\n\t\t\t}\n\t\t}\n\t\tconst { variable, ascending, degree } = {\n\t\t\tascending: false,\n\t\t\tdegree: coeffs.length - 1,\n\t\t\tvariable: variableDefault,\n\t\t\t...options,\n\t\t};\n\t\tif (degree < 0 || degree < coeffs.length - 1) {\n\t\t\tthrow new RangeError('degree must be greater than coefficients.length-1');\n\t\t}\n\t\t// reverse coefficient array if descending order\n\t\tif (!ascending) {\n\t\t\tcoeffs = [...coeffs].reverse();\n\t\t}\n\t\t// add extra zeros to start from constant term\n\t\tif (degree > coeffs.length - 1) {\n\t\t\tconst extraCoeffLength = degree - coeffs.length + 1;\n\t\t\tcoeffs = [...createZeroArray(extraCoeffLength), ...coeffs];\n\t\t}\n\t\t// convert to Fraction type\n\t\tlet coeffsFrac = coeffs.map(numberToFraction);\n\t\t// remove unnecessary terms (leading coefficients should be non-zero, unless it is a constant polynomial)\n\t\twhile (coeffsFrac[coeffsFrac.length - 1].isEqualTo(0) && coeffsFrac.length > 1) {\n\t\t\tcoeffsFrac.pop();\n\t\t}\n\t\t// generate variable terms\n\t\tconst polynomialTerms = coeffsFrac.map((coeff, n) => {\n\t\t\treturn new Term(coeff, [variable, n]);\n\t\t});\n\t\t// descending order typesetting if necessary;\n\t\tif (!ascending) {\n\t\t\tpolynomialTerms.reverse();\n\t\t}\n\t\tsuper(...polynomialTerms);\n\t\tthis.coeffs = coeffsFrac;\n\t\tthis.degree = coeffsFrac.length - 1;\n\t\tthis.variable = variable;\n\t\tthis.ascending = ascending;\n\t}\n\n\t/** add two polynomials\n\t *\n\t * fraction/numbers will be converted a \"constant polynomial\", while a string will be converted to a polynomial term with coefficient 1\n\t */\n\tplus(p2: number | Fraction | string | Polynomial): Polynomial {\n\t\tp2 = toPolynomial(p2);\n\t\tconst degree = Math.max(this.degree, p2.degree);\n\t\tconst thisCoeffs = [...this.coeffs, ...createZeroArray(degree - this.degree)];\n\t\tconst p2Coeffs = [...p2.coeffs, ...createZeroArray(degree - p2.degree)];\n\t\tconst newCoeffs = thisCoeffs.map((thisCoeff, i) => thisCoeff.plus(p2Coeffs[i]));\n\t\tif (!this.ascending) {\n\t\t\tnewCoeffs.reverse();\n\t\t}\n\t\treturn new Polynomial(newCoeffs, { variable: this.variable, ascending: this.ascending, degree });\n\t}\n\n\t/** multiplies two polynomials */\n\ttimes(p2: number | Fraction | string | Polynomial): Polynomial {\n\t\tp2 = toPolynomial(p2);\n\t\tconst degree = this.degree + p2.degree;\n\t\tconst coeffs = createZeroArray(degree + 1);\n\t\tfor (let i = 0; i < this.coeffs.length; i++) {\n\t\t\tfor (let j = 0; j < p2.coeffs.length; j++) {\n\t\t\t\tcoeffs[i + j] = coeffs[i + j].plus(this.coeffs[i].times(p2.coeffs[j]));\n\t\t\t}\n\t\t}\n\t\tif (!this.ascending) {\n\t\t\tcoeffs.reverse();\n\t\t}\n\t\treturn new Polynomial(coeffs, { ascending: this.ascending, degree, variable: this.variable });\n\t}\n\n\t/** negative of this polynomial */\n\tnegative(): Polynomial {\n\t\treturn this.times(-1);\n\t}\n\n\t/**\n\t * divide by a *scalar*\n\t */\n\tdivide(p2: number | Fraction): Polynomial {\n\t\tp2 = numberToFraction(p2);\n\t\treturn this.times(p2.reciprocal());\n\t}\n\n\t/** subtracts this by p2 */\n\tminus(p2: number | Fraction | string | Polynomial): Polynomial {\n\t\tp2 = toPolynomial(p2);\n\t\treturn this.plus(p2.times(-1));\n\t}\n\n\t/**\n\t * exponentiation\n\t * @returns this polynomial taken to a power of `n`\n\t */\n\tpow(n: number): Polynomial {\n\t\tif (!(Number.isInteger(n) && n >= 0)) {\n\t\t\tthrow new RangeError(`only non-negative integers allowed for n (${n} received)`);\n\t\t}\n\t\tlet newPoly = new Polynomial([1], { variable: this.variable, ascending: this.ascending });\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tnewPoly = newPoly.times(this);\n\t\t}\n\t\treturn newPoly;\n\t}\n\n\t/**\n\t * replace x with a new polynomial\n\t * @param x if string, replaces the variable\n\t */\n\treplaceXWith(x: string | Polynomial): Polynomial {\n\t\tx = typeof x === 'string' ? new Polynomial([1, 0], { variable: x }) : x;\n\t\treturn this.coeffs.reduce(\n\t\t\t(prev, coeff, i) => prev.plus((<Polynomial>x).pow(i).times(coeff)),\n\t\t\tnew Polynomial([0], { ascending: this.ascending, variable: x.variable }),\n\t\t);\n\t}\n\n\t/**\n\t * replace x with x+k\n\t */\n\tshift(k: number | Fraction): Polynomial {\n\t\treturn this.replaceXWith(new Polynomial([1, k], { ascending: this.ascending, variable: this.variable }));\n\t}\n\n\t/**\n\t * square\n\t *\n\t * @returns the square of this polynomial\n\t *  */\n\tsquare(): Polynomial {\n\t\treturn this.pow(2);\n\t}\n\n\t/**\n\t * returns a polynomial with positive leading coefficient and gcd(...coeffs) = 1\n\t * */\n\tsimplify(): Polynomial {\n\t\tconst [newCoeffs] = Fraction.factorize(...this.coeffs);\n\t\treturn new Polynomial(newCoeffs, { ascending: true, variable: this.variable }).changeAscending(this.ascending);\n\t}\n\n\tsubInSurd(x: number | SquareRoot): Expression {\n\t\tconst xSurd = typeof x === 'number' ? new SquareRoot(1, x) : x;\n\t\tconst terms = this.coeffs.map((a, i) => xSurd.pow(i).times(a));\n\t\treturn new Expression(...terms);\n\t}\n\n\t/**\n\t * changes ascending/behavior of polynomial\n\t *\n\t * @param ascending sets ascending behavior. By default, this\n\t * option is set to toggle current ascending/descending behavior\n\t *\n\t * @returns a reference to this polynomial instance\n\t *\n\t * WARNING: mutates current instance\n\t */\n\tchangeAscending(ascending = !this.ascending): this {\n\t\tif (this.ascending === ascending) {\n\t\t\treturn this;\n\t\t}\n\t\tthis.terms.reverse();\n\t\tthis.ascending = ascending;\n\t\treturn this;\n\t}\n\n\t/** derivative of the polynomial */\n\tdifferentiate(): Polynomial {\n\t\tif (this.degree === 0) {\n\t\t\treturn new Polynomial([0]);\n\t\t}\n\t\tconst newCoeffs = this.coeffs.map((coeff, i) => coeff.times(i)).slice(1);\n\t\tconst newPoly = new Polynomial(newCoeffs, { ascending: true, variable: this.variable });\n\t\treturn this.ascending ? newPoly : newPoly.changeAscending();\n\t}\n\n\t/** integral of the polynomial\n\t * @param options `{c, x1, y1}` where we can put in the integration constant c (defaults to 0),\n\t * or a point on the curve (x1, y1).\n\t */\n\tintegrate(options?: { c?: number | Fraction; x1?: number | Fraction; y1?: number | Fraction }): Polynomial {\n\t\tlet c = options?.c ?? 0;\n\t\tif (this.degree === 0) {\n\t\t\treturn new Polynomial([this.coeffs[0], c]);\n\t\t}\n\t\tconst newCoeffs = [0, ...this.coeffs.map((coeff, i) => coeff.divide(i + 1))];\n\t\tconst newPoly = new Polynomial(newCoeffs, { ascending: true, variable: this.variable });\n\t\tconst { x1, y1 } = {\n\t\t\t...options,\n\t\t};\n\t\tif (x1 !== undefined && y1 !== undefined) {\n\t\t\tc = newPoly.subIn(x1).negative().plus(y1);\n\t\t}\n\t\tconst polyWithC = newPoly.plus(c);\n\t\treturn this.ascending ? polyWithC : polyWithC.changeAscending();\n\t}\n\n\t/** definite integral (fraction form)*/\n\tdefiniteIntegral(lower: number | Fraction, upper: number | Fraction): Fraction {\n\t\tconst integral = this.integrate();\n\t\treturn integral.subIn(upper).minus(integral.subIn(lower));\n\t}\n\n\t/** definite integral (number form) */\n\tdefiniteIntegralNumber(lower: number | Fraction, upper: number | Fraction): number {\n\t\tif (typeof lower !== 'number') {\n\t\t\tlower = lower.valueOf();\n\t\t}\n\t\tif (typeof upper !== 'number') {\n\t\t\tupper = upper.valueOf();\n\t\t}\n\t\tconst integral = this.integrate();\n\t\treturn integral.subInNumber(upper) - integral.subInNumber(lower);\n\t}\n\n\t/**\n\t * @returns an ascending polynomial only up until degree n\n\t */\n\tconcatenate(n: number): Polynomial {\n\t\tconst coeffs = this.coeffs.slice(0, n + 1);\n\t\treturn new Polynomial(coeffs, { ascending: true, variable: this.variable });\n\t}\n\n\t/** checks if two polynomials are equal: i.e., coefficient array is the same and same variable */\n\tisEqualTo(poly2: Polynomial): boolean {\n\t\tif (this.variable === poly2.variable) {\n\t\t\tif (this.coeffs.length === poly2.coeffs.length) {\n\t\t\t\tlet valid = true;\n\t\t\t\tthis.coeffs.forEach((coeff, i) => {\n\t\t\t\t\tif (!coeff.isEqualTo(poly2.coeffs[i])) {\n\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn valid;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/** clones this polynomial */\n\tclone(): Polynomial {\n\t\tconst coeffs = [...this.coeffs];\n\t\tif (!this.ascending) {\n\t\t\t// coeffs in ascending by default\n\t\t\tcoeffs.reverse();\n\t\t}\n\t\treturn new Polynomial(coeffs, { ascending: this.ascending, degree: this.degree, variable: this.variable });\n\t}\n\n\t/**\n\t * toJSON method that allows for quick reconstruction of class instance\n\t * by storing its constructor arguments\n\t */\n\ttoJSON(): { type: 'polynomial'; args: [Fraction[], { ascending: boolean; degree: number; variable: string }] } {\n\t\tconst coeffs = this.coeffs.map((e) => e.clone());\n\t\tif (!this.ascending) {\n\t\t\tcoeffs.reverse();\n\t\t}\n\t\treturn {\n\t\t\ttype: 'polynomial',\n\t\t\targs: [coeffs, { ascending: this.ascending, degree: this.degree, variable: this.variable }],\n\t\t};\n\t}\n}\n\nexport function createZeroArray(n: number): Fraction[] {\n\tlet zeroArray: Fraction[] = [];\n\tfor (let i = 0; i < n; i++) {\n\t\tzeroArray.push(Fraction.ZERO);\n\t}\n\treturn zeroArray;\n}\n\nfunction toPolynomial(p2: number | Fraction | string | Polynomial): Polynomial {\n\tif (typeof p2 === 'number' || p2 instanceof Fraction) {\n\t\treturn new Polynomial([p2]);\n\t}\n\tif (typeof p2 === 'string') {\n\t\treturn new Polynomial([1, 0], { variable: p2 });\n\t}\n\treturn p2;\n}\n","export { Vector } from './vectorClass';\nexport { Line } from './lineClass';\nexport { Plane } from './planeClass';\nexport { xVector } from './extendedVectorClass';\nexport { uVector, uxVector, uVectorExpression, uxVectorExpression } from './unknownVectorClass';\n","import { Expression, Term, SquareRoot, Fraction, numberToFraction } from '../core';\nimport { FractionJSON } from '../core/fractionClass';\n\n/**\n * Vector class representing a 3D vector coeff(x i + y j + z k)\n */\nexport class Vector {\n\tx: Fraction;\n\ty: Fraction;\n\tz: Fraction;\n\tcoeff: Fraction;\n\t/**\n\t * creates a new Vector instance\n\t *\n\t * @param options defaults to `{coeff: 1, simplify: false, stretchable: false}`\n\t *  if `simplify` is `true`, then we will factorize our expression such that\n\t *  x,y,z are integers with gcd 1.\n\t *  if `stretchable` is set to true, then we will `simplify` and then\n\t *  set `coeff` to be 1\n\t *\n\t */\n\tconstructor(\n\t\tx: number | Fraction,\n\t\ty?: number | Fraction,\n\t\tz?: number | Fraction,\n\t\toptions?: { coeff?: number | Fraction; simplify?: boolean; stretchable?: boolean },\n\t) {\n\t\tx = numberToFraction(x);\n\t\ty = y === undefined ? Fraction.ZERO : numberToFraction(y);\n\t\tz = z === undefined ? Fraction.ZERO : numberToFraction(z);\n\t\tlet { coeff, simplify, stretchable } = {\n\t\t\tcoeff: Fraction.ONE,\n\t\t\tsimplify: false,\n\t\t\tstretchable: false,\n\t\t\t...options,\n\t\t};\n\t\tcoeff = numberToFraction(coeff);\n\t\tif (stretchable || simplify) {\n\t\t\t[[x, y, z], coeff] = Fraction.factorize(x, y, z);\n\t\t\tcoeff = stretchable ? Fraction.ONE : coeff;\n\t\t}\n\t\tthis.x = coeff.isEqualTo(0) ? Fraction.ZERO : x;\n\t\tthis.y = coeff.isEqualTo(0) ? Fraction.ZERO : y;\n\t\tthis.z = coeff.isEqualTo(0) ? Fraction.ZERO : z;\n\t\tthis.coeff = coeff.isEqualTo(0) ? Fraction.ONE : coeff;\n\t}\n\n\t/**\n\t * simplifies the current vector to k(a,b,c) by taking\n\t * out common factors so that gcd(a,b,c)=1\n\t *\n\t * @param options defaults to `{stretchable: false}`.\n\t * If set to true, will set coeff to 1\n\t *\n\t * WARING: this method mutates the current instance\n\t *\n\t * @returns a reference to this vector\n\t */\n\tsimplify(options = { stretchable: false }): this {\n\t\tconst stretchable = options.stretchable;\n\t\tif (!this.isZero()) {\n\t\t\tlet [[x, y, z], coeff] = Fraction.factorize(this.x, this.y, this.z);\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t\tthis.coeff = stretchable ? Fraction.ONE : coeff.times(this.coeff);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * returns the unit vector parallel to this vector\n\t *\n\t * WARNING: only works if magnitude is integer\n\t */\n\that(): Vector {\n\t\tconst mag = this.magnitude();\n\t\tif (!mag.isRational() || mag.isEqualTo(0)) {\n\t\t\tthrow new Error(`only integer magnitude supported: ${mag}`);\n\t\t}\n\t\treturn this.divide(mag.coeff);\n\t}\n\n\t/**\n\t * Expands the coeff, taking this k(x,y,z) and\n\t * returning (kx, ky, kz)\n\t */\n\texpand(): Vector {\n\t\treturn new Vector(this.coeff.times(this.x), this.coeff.times(this.y), this.coeff.times(this.z));\n\t}\n\n\t/**\n\t * @returns the dot product\n\t */\n\tdot(v2: Vector): Fraction {\n\t\treturn this.coeff.times(v2.coeff).times(this.x.times(v2.x).plus(this.y.times(v2.y)).plus(this.z.times(v2.z)));\n\t}\n\n\t/**\n\t * @returns the magnitude squared of this vector\n\t */\n\tmagnitudeSquare(): Fraction {\n\t\treturn this.dot(this);\n\t}\n\n\t/**\n\t * @returns the magnitude as a SquareRoot class\n\t */\n\tmagnitude(): SquareRoot {\n\t\treturn new SquareRoot(this.magnitudeSquare());\n\t}\n\n\t/**\n\t * @returns if the vector is a zero vector\n\t */\n\tisZero(): boolean {\n\t\treturn this.magnitudeSquare().isEqualTo(0);\n\t}\n\n\t/**\n\t * vector addition\n\t *\n\t * if the coeffs are the same, will retain the same coeff\n\t *\n\t * if the coeffs are different, will expand them in before performing addition\n\t */\n\tplus(v2: Vector, options?: { simplify?: boolean; stretchable?: boolean }): Vector {\n\t\tif (this.coeff.isEqualTo(v2.coeff)) {\n\t\t\treturn new Vector(this.x.plus(v2.x), this.y.plus(v2.y), this.z.plus(v2.z), options);\n\t\t} else {\n\t\t\treturn this.expand().plus(v2.expand(), options);\n\t\t}\n\t}\n\n\t/**\n\t * returns the negative of this vector\n\t *\n\t * @param options default to `{multiplyIntoCoeff: false}`\n\t * the coeff stays the same while the components are made negative\n\t * if false, the coeff is made negative instead\n\t */\n\tnegative(options = { multiplyIntoCoeff: false }): Vector {\n\t\treturn options.multiplyIntoCoeff\n\t\t\t? new Vector(this.x, this.y, this.z, { coeff: this.coeff.negative() })\n\t\t\t: new Vector(this.x.negative(), this.y.negative(), this.z.negative(), { coeff: this.coeff });\n\t}\n\n\t/**\n\t * vector subtraction\n\t */\n\tminus(v2: Vector): Vector {\n\t\treturn this.plus(v2.negative());\n\t}\n\n\t/**\n\t * scalar multiplication\n\t *\n\t * by default, the coeff stays the same while the components are multiplied\n\t * if false, the coeff is multiplied instead\n\t *\n\t * @param options defaults to `{multiplyIntoCoeff: false}`\n\t */\n\tmultiply(k: number | Fraction, options = { multiplyIntoCoeff: false }): Vector {\n\t\treturn options.multiplyIntoCoeff\n\t\t\t? new Vector(this.x, this.y, this.z, { coeff: this.coeff.times(k) })\n\t\t\t: new Vector(this.x.times(k), this.y.times(k), this.z.times(k), { coeff: this.coeff });\n\t}\n\t/**\n\t * scalar division\n\t *\n\t * by default, the coeff stays the same while the components are multiplied\n\t * if false, the coeff is multiplied instead\n\t *\n\t * @param options defaults to `{multiplyIntoCoeff: false}`\n\t */\n\tdivide(k: number | Fraction, options = { multiplyIntoCoeff: false }): Vector {\n\t\treturn options.multiplyIntoCoeff\n\t\t\t? new Vector(this.x, this.y, this.z, { coeff: this.coeff.divide(k) })\n\t\t\t: new Vector(this.x.divide(k), this.y.divide(k), this.z.divide(k), { coeff: this.coeff });\n\t}\n\n\t/**\n\t * @returns the cross product (this cross v2)\n\t */\n\tcross(v2: Vector, options?: { simplify?: boolean; stretchable?: boolean }): Vector {\n\t\tconst coeff = this.coeff.times(v2.coeff);\n\t\tconst x = this.y.times(v2.z).minus(this.z.times(v2.y));\n\t\tconst y = this.z.times(v2.x).minus(this.x.times(v2.z));\n\t\tconst z = this.x.times(v2.y).minus(this.y.times(v2.x));\n\t\treturn new Vector(x, y, z, { coeff, ...options });\n\t}\n\n\t/**\n\t * checks if this is perpendicular to v2\n\t */\n\tisPerpendicularTo(v2: Vector): boolean {\n\t\treturn this.dot(v2).isEqualTo(0);\n\t}\n\n\t/**\n\t * checks if this is parallel to v2\n\t */\n\tisParallelTo(v2: Vector): boolean {\n\t\treturn this.cross(v2).isZero();\n\t}\n\n\t/**\n\t * @returns latex string representing the vector in column vector form\n\t */\n\ttoString(): string {\n\t\tif (this.isZero()) {\n\t\t\treturn `\\\\begin{pmatrix}\\n\\t0 \\\\\\\\\\n\\t0 \\\\\\\\\\n\\t0\\n\\\\end{pmatrix}`;\n\t\t}\n\t\tconst columnVector = `\\\\begin{pmatrix}\\n\\t${this.x} \\\\\\\\\\n\\t${this.y} \\\\\\\\\\n\\t${this.z}\\n\\\\end{pmatrix}`;\n\t\tconst term = new Term(this.coeff, columnVector);\n\t\treturn `${term}`;\n\t}\n\n\t/**\n\t * @returns latex string representing the vector in ijk notation\n\t */\n\ttoIJKString(): string {\n\t\tif (this.isZero()) {\n\t\t\treturn '\\\\mathbf{0}';\n\t\t}\n\t\tconst expression = new Expression(\n\t\t\tnew Term(this.x, '\\\\mathbf{i}'),\n\t\t\tnew Term(this.y, '\\\\mathbf{j}'),\n\t\t\tnew Term(this.z, '\\\\mathbf{k}'),\n\t\t);\n\t\tconst expressionString = this.coeff.isEqualTo(1) ? `${expression}` : `\\\\left( ${expression} \\\\right)`;\n\t\tconst term = new Term(this.coeff, expressionString);\n\t\treturn `${term}`;\n\t}\n\n\t/**\n\t * @returns (kx, ky, kz) as a coordinate triple.\n\t *\n\t * @param name The name of the point which is attached to the front of the coordinates\n\t */\n\ttoCoordinates(name = ''): string {\n\t\tconst v = this.expand();\n\t\treturn `${name}${name === '' ? '' : ' '}\\\\left( ${v.x}, ${v.y}, ${v.z} \\\\right)`;\n\t}\n\n\t/**\n\t * checks if two vectors are equal\n\t */\n\tisEqualTo(v2: Vector): boolean {\n\t\treturn this.minus(v2).magnitudeSquare().isEqualTo(0);\n\t}\n\n\t/**\n\t * @returns angle between two vectors as a string in degrees\n\t *\n\t * @param options default to {acute: false, sineMode: false}\n\t */\n\tangleTo(v2: Vector, options?: { acute?: boolean; sineMode?: boolean }): string {\n\t\tlet cosSquare = this.dot(v2).square().divide(this.magnitudeSquare()).divide(v2.magnitudeSquare());\n\t\tconst { acute, sineMode } = {\n\t\t\tacute: false,\n\t\t\tsineMode: false,\n\t\t\t...options,\n\t\t};\n\t\tif (cosSquare.isEqualTo(1)) {\n\t\t\treturn sineMode ? '90^\\\\circ' : '0^\\\\circ';\n\t\t\t//} else if (cosSquare.isEqualTo(new Fraction(3,4))) {\n\t\t\t//\tif (sineMode) {\n\t\t\t//\t\treturn '60^\\\\circ'\n\t\t\t//\t} else {\n\t\t\t//\t\treturn (acute || this.dot(v2).isGreaterThan(0)) ? '30^\\\\circ' : '150^\\\\circ';\n\t\t\t//\t}\n\t\t} else if (cosSquare.isEqualTo(new Fraction(1, 2))) {\n\t\t\treturn sineMode || acute || this.dot(v2).isGreaterThan(0) ? '45^\\\\circ' : '135^\\\\circ';\n\t\t\t//} else if (cosSquare.isEqualTo(new Fraction(1,4))) {\n\t\t\t//\tif (sineMode) {\n\t\t\t//\t\treturn '30^\\\\circ'\n\t\t\t//\t} else {\n\t\t\t//\t\treturn (acute || this.dot(v2).isGreaterThan(0)) ? '60^\\\\circ' : '120^\\\\circ';\n\t\t\t//\t}\n\t\t} else if (cosSquare.isEqualTo(0)) {\n\t\t\treturn sineMode ? '0^\\\\circ' : '90^\\\\circ';\n\t\t} else {\n\t\t\tconst alpha = (Math.acos(Math.sqrt(cosSquare.valueOf())) * 180) / Math.PI;\n\t\t\tif (sineMode) {\n\t\t\t\tconst theta = 90 - alpha;\n\t\t\t\treturn `${theta.toFixed(1)}^\\\\circ`;\n\t\t\t} else {\n\t\t\t\tconst theta = acute || this.dot(v2).isGreaterThan(0) ? alpha : 180 - alpha;\n\t\t\t\treturn `${theta.toFixed(1)}^\\\\circ`;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * clones a new instance of this vector\n\t */\n\tclone(): Vector {\n\t\treturn new Vector(this.x, this.y, this.z, { coeff: this.coeff });\n\t}\n\n\ttoJSON(): VectorJSON {\n\t\treturn {\n\t\t\ttype: 'vector',\n\t\t\targs: [this.x.toJSON(), this.y.toJSON(), this.z.toJSON(), { coeff: this.coeff.toJSON() }],\n\t\t};\n\t}\n\n\t////\n\t// static properties\n\t////\n\n\t/**\n\t * the zero vector\n\t */\n\tstatic ZERO = new Vector(0);\n\t/**\n\t * the x-axis unit vector (1,0,0)\n\t */\n\tstatic I = new Vector(1);\n\t/**\n\t * the y-axis unit vector (0,1,0)\n\t */\n\tstatic J = new Vector(0, 1);\n\t/**\n\t * the z-axis unit vector (0,0,1)\n\t */\n\tstatic K = new Vector(0, 0, 1);\n\t/**\n\t * ratio theorem\n\t */\n\tstatic Ratio(v1: Vector, v2: Vector, options?: { lambda?: number | Fraction; mu?: number | Fraction }) {\n\t\tlet { lambda, mu } = {\n\t\t\tlambda: 1,\n\t\t\tmu: 1,\n\t\t\t...options,\n\t\t};\n\t\tlambda = numberToFraction(lambda);\n\t\tmu = numberToFraction(mu);\n\t\treturn v2.multiply(lambda).plus(v1.multiply(mu)).divide(lambda.plus(mu));\n\t}\n}\n\nexport interface VectorJSON {\n\ttype: 'vector';\n\targs: [FractionJSON, FractionJSON, FractionJSON, { coeff: FractionJSON }];\n}\n","import { Vector } from './vectorClass';\nimport { type Fraction, type SquareRoot, Polynomial, numberToFraction } from '../core';\nimport { cramersFrac } from '../numerical';\n\n/**\n * Line class representing a 3D Line represented in vector form\n * r = a + \\lambda d, where a is a point on the line,\n * d is a direction vector parallel to the line,\n * and lambda is the parameter\n */\nexport class Line {\n\ta: Vector;\n\td: Vector;\n\tlambda: string;\n\t/**\n\t * creates a new Line instance\n\t *\n\t * by default, v1 is taken as the point a and v2 the direction vector d\n\t *\n\t * if options is `{twoPointsMode: true}` (default: false), then v1 and v2\n\t * will be taken as two points on the line\n\t *\n\t * @param lambda string representing the parameter to be used when\n\t * typesetting the equation of the line. Defaults to `\"\\\\lambda\"`\n\t */\n\tconstructor(v1: Vector, v2: Vector, options?: { twoPointsMode?: boolean; lambda?: string }) {\n\t\tconst { twoPointsMode, lambda } = {\n\t\t\ttwoPointsMode: false,\n\t\t\tlambda: '\\\\lambda',\n\t\t\t...options,\n\t\t};\n\t\tv2 = twoPointsMode ? v2.minus(v1).simplify({ stretchable: true }) : v2;\n\t\tif (v2.isZero()) {\n\t\t\tthrow new Error('Cannot create a line with zero vector as direction');\n\t\t}\n\t\tthis.a = v1.expand();\n\t\tthis.d = v2.clone();\n\t\tthis.lambda = lambda;\n\t}\n\n\t/**\n\t * checks if line contains a point\n\t */\n\tcontains(point: Vector): boolean {\n\t\tconst ab = point.minus(this.a);\n\t\treturn ab.isZero() || this.d.isParallelTo(ab);\n\t}\n\n\t/**\n\t * checks if line is parallel to vector or line\n\t */\n\tisParallelTo(v: Vector | Line): boolean {\n\t\tv = v instanceof Line ? v.d : v;\n\t\treturn this.d.isParallelTo(v);\n\t}\n\n\t/**\n\t * checks if two lines are the same\n\t */\n\tisEqualTo(l2: Line): boolean {\n\t\treturn this.isParallelTo(l2) && this.contains(l2.a);\n\t}\n\n\t/**\n\t * subs in the parameter lambda\n\t *\n\t * @returns the position vector of the resulting point on the line\n\t */\n\tpoint(lambda: number | Fraction = 0): Vector {\n\t\tlambda = numberToFraction(lambda);\n\t\treturn this.a.plus(this.d.multiply(lambda));\n\t}\n\n\t/**\n\t * finds *acute* angle between lines/line and vector\n\t *\n\t * @returns angle between this line and given vector/line\n\t */\n\tangleTo(v: Vector | Line): string {\n\t\tv = v instanceof Line ? v.d : v;\n\t\treturn this.d.angleTo(v, { acute: true });\n\t}\n\n\t/**\n\t * finds distance between this line to a point or a parallel line\n\t *\n\t * WARNING: does not support skew lines at the moment\n\t */\n\tdistanceTo(v: Vector | Line): SquareRoot {\n\t\tlet ab: Vector;\n\t\tif (v instanceof Line) {\n\t\t\tif (!v.isParallelTo(this)) {\n\t\t\t\tthrow new Error('Distance method only supported for parallel lines');\n\t\t\t}\n\t\t\tab = v.a.minus(this.a);\n\t\t} else {\n\t\t\tab = v.minus(this.a);\n\t\t}\n\t\tconst modABCrossD = ab.cross(this.d).magnitude();\n\t\treturn modABCrossD.divide(this.d.magnitude());\n\t}\n\n\t/**\n\t * finds intersection point between two lines\n\t *\n\t * @returns the position vector of the point of intersection,\n\t * or null if there are no points of intersection,\n\t * or a line if the two lines are coincident.\n\t *\n\t */\n\tintersect(l2: Line): Vector | null | Line {\n\t\tif (this.isParallelTo(l2)) {\n\t\t\treturn this.isEqualTo(l2) ? this.clone() : null;\n\t\t}\n\t\tconst intersection = this.intersectParameters(l2);\n\t\tif (intersection === null) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tconst [lambda] = intersection;\n\t\t\treturn this.point(lambda);\n\t\t}\n\t}\n\n\t/**\n\t * @returns [lambda, mu] that corresponds to the intersection of this line and l2\n\t * returns null if skew/parallel/coincident lines\n\t */\n\tintersectParameters(l2: Line): null | [Fraction, Fraction] {\n\t\tif (this.isParallelTo(l2)) {\n\t\t\treturn null;\n\t\t}\n\t\t// solve for lambda and mu from first two rows\n\t\tconst [a1, b1, c1, a2, b2, c2, a3, b3, c3] = [\n\t\t\tthis.d.x,\n\t\t\tl2.d.x.negative(),\n\t\t\tl2.a.x.minus(this.a.x),\n\t\t\tthis.d.y,\n\t\t\tl2.d.y.negative(),\n\t\t\tl2.a.y.minus(this.a.y),\n\t\t\tthis.d.z,\n\t\t\tl2.d.z.negative(),\n\t\t\tl2.a.z.minus(this.a.z),\n\t\t];\n\t\tlet det = determinant(a1, b1, a2, b2);\n\t\tlet x1: Fraction, x2: Fraction, x3: Fraction, y1: Fraction, y2: Fraction, y3: Fraction;\n\t\tif (!det.isEqualTo(0)) {\n\t\t\tx1 = a1;\n\t\t\tx2 = b1;\n\t\t\tx3 = c1;\n\t\t\ty1 = a2;\n\t\t\ty2 = b2;\n\t\t\ty3 = c2;\n\t\t} else {\n\t\t\tdet = determinant(a1, b1, a3, b3);\n\t\t\tif (!det.isEqualTo(0)) {\n\t\t\t\tx1 = a1;\n\t\t\t\tx2 = b1;\n\t\t\t\tx3 = c1;\n\t\t\t\ty1 = a3;\n\t\t\t\ty2 = b3;\n\t\t\t\ty3 = c3;\n\t\t\t} else {\n\t\t\t\tdet = determinant(a2, b2, a3, b3);\n\t\t\t\tif (det.isEqualTo(0)) {\n\t\t\t\t\treturn null;\n\t\t\t\t} else {\n\t\t\t\t\tx1 = a2;\n\t\t\t\t\tx2 = b2;\n\t\t\t\t\tx3 = c2;\n\t\t\t\t\ty1 = a3;\n\t\t\t\t\ty2 = b3;\n\t\t\t\t\ty3 = c3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst [lambda, mu] = cramersFrac(x1, x2, x3, y1, y2, y3);\n\t\t// check if intersecting\n\t\tif (this.point(lambda).isEqualTo(l2.point(mu))) {\n\t\t\t// intersecting lines\n\t\t\treturn [lambda, mu];\n\t\t} else {\n\t\t\t// skew lines\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * finds the foot of perpendicular from point to this line\n\t */\n\tfootOfPerpendicular(point: Vector): Vector {\n\t\tconst AB = point.minus(this.a);\n\t\tconst ABDotD = AB.dot(this.d);\n\t\tconst lambda = ABDotD.divide(this.d.magnitudeSquare());\n\t\tconst AF = this.d.multiply(lambda);\n\t\treturn AF.plus(this.a).expand();\n\t}\n\n\t/**\n\t * finds the reflection of a point/line about this line\n\t */\n\treflect(v: Vector | Line): Vector | Line {\n\t\treturn v instanceof Line ? this.reflectLine(v) : this.reflectPoint(v);\n\t}\n\n\t/**\n\t * finds the reflection of point about this line\n\t */\n\treflectPoint(point: Vector): Vector {\n\t\tconst OF = this.footOfPerpendicular(point);\n\t\treturn OF.multiply(2).minus(point).expand();\n\t}\n\n\t/**\n\t * checks if two lines are skew\n\t */\n\tisSkewTo(l2: Line): boolean {\n\t\treturn !this.isParallelTo(l2) && !this.isEqualTo(l2) && this.intersect(l2) === null;\n\t}\n\n\t/**\n\t * finds the reflection of line l2 about this line\n\t *\n\t * WARNING: throws an error if skew lines encountered\n\t */\n\treflectLine(l2: Line): Line {\n\t\tif (this.isParallelTo(l2)) {\n\t\t\tconst OAPrime = this.reflectPoint(l2.a);\n\t\t\treturn new Line(OAPrime, this.d);\n\t\t}\n\t\tconst OX = this.intersect(l2) as Vector | null;\n\t\tif (OX === null) {\n\t\t\t// skew lines\n\t\t\tthrow new Error('Cannot find line reflection of skew lines');\n\t\t} else {\n\t\t\t// intersecting\n\t\t\tlet OA = l2.a;\n\t\t\tif (this.contains(OA)) {\n\t\t\t\tOA = l2.point(1);\n\t\t\t}\n\t\t\tconst OAPrime = this.reflectPoint(OA);\n\t\t\treturn new Line(OX, OAPrime, { twoPointsMode: true });\n\t\t}\n\t}\n\n\t/**\n\t * @returns equation of the line r = a + lambda d in column vector form\n\t */\n\ttoString(): string {\n\t\treturn this.a.isZero()\n\t\t\t? `\\\\mathbf{r} = ${this.lambda} ${this.d}`\n\t\t\t: `\\\\mathbf{r} = ${this.a} + ${this.lambda} ${this.d}`;\n\t}\n\n\t/**\n\t * @returns equation of the line r = a + lambda d in ijk form\n\t */\n\ttoIJKString(): string {\n\t\treturn this.a.isZero()\n\t\t\t? `\\\\mathbf{r} = ${this.lambda} \\\\left( ${this.d.toIJKString()} \\\\right)`\n\t\t\t: `\\\\mathbf{r} = \\\\left( ${this.a.toIJKString()} \\\\right) + ${\n\t\t\t\t\tthis.lambda\n\t\t\t  } \\\\left( ${this.d.toIJKString()} \\\\right)`;\n\t}\n\n\t/**\n\t * @returns (a+lambda d) combined together in a column vector\n\t *\n\t * @param component 0 (default) returns all 3 components, 1 returns x, 2 returns y, 3 returns z\n\t */\n\ttoCombinedString(component = 0): string {\n\t\tconst x = new Polynomial([this.a.x, this.d.x], { ascending: true, variable: this.lambda });\n\t\tconst y = new Polynomial([this.a.y, this.d.y], { ascending: true, variable: this.lambda });\n\t\tconst z = new Polynomial([this.a.z, this.d.z], { ascending: true, variable: this.lambda });\n\t\tif (component === 0) {\n\t\t\treturn `\\\\begin{pmatrix}\\n\\t${x} \\\\\\\\\\n\\t${y} \\\\\\\\\\n\\t${z}\\n\\\\end{pmatrix}`;\n\t\t} else if (component === 1) {\n\t\t\treturn `${x}`;\n\t\t} else if (component === 2) {\n\t\t\treturn `${y}`;\n\t\t} else if (component === 3) {\n\t\t\treturn `${z}`;\n\t\t} else {\n\t\t\tthrow new Error(`Component ${component} not recognized: must be 0-3`);\n\t\t}\n\t}\n\n\t/**\n\t * @returns cartesian equation of the line\n\t */\n\ttoCartesianString(): string {\n\t\tif (this.d.x.isEqualTo(0)) {\n\t\t\tif (this.d.y.isEqualTo(0)) {\n\t\t\t\t// x,y zero\n\t\t\t\t// by construction z cannot be zero\n\t\t\t\treturn `x = ${this.a.x}, y = ${this.a.y}, z \\\\in \\\\mathbb{R}`;\n\t\t\t} else {\n\t\t\t\t// x zero, y non-zero\n\t\t\t\tconst yString = toCartesianComponent('y', this.a.y, this.d.y);\n\t\t\t\tif (this.d.z.isEqualTo(0)) {\n\t\t\t\t\t// y non-zero, x,z zero\n\t\t\t\t\treturn `x = ${this.a.x}, y \\\\in \\\\mathbb{R}, z = ${this.a.z}`;\n\t\t\t\t} else {\n\t\t\t\t\t// x zero, y,z non-zero\n\t\t\t\t\tconst zString = toCartesianComponent('z', this.a.z, this.d.z);\n\t\t\t\t\treturn `x = ${this.a.x}, ${yString} = ${zString}`;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// x non-zero\n\t\t\tconst xString = toCartesianComponent('x', this.a.x, this.d.x);\n\t\t\tif (this.d.y.isEqualTo(0)) {\n\t\t\t\t// x non-zero, y zero\n\t\t\t\tif (this.d.z.isEqualTo(0)) {\n\t\t\t\t\t// x non-zero, y,z zero\n\t\t\t\t\treturn `x \\\\in \\\\mathbb{R}, y = ${this.a.y}, z = ${this.a.z}`;\n\t\t\t\t} else {\n\t\t\t\t\t// x,z non-zero, y zero\n\t\t\t\t\tconst zString = toCartesianComponent('z', this.a.z, this.d.z);\n\t\t\t\t\treturn `${xString} = ${zString}, y = ${this.a.y}`;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// x,y non-zero\n\t\t\t\tconst yString = toCartesianComponent('y', this.a.y, this.d.y);\n\t\t\t\tif (this.d.z.isEqualTo(0)) {\n\t\t\t\t\t// x,y non-zero, z zero\n\t\t\t\t\treturn `${xString} = ${yString}, z = ${this.a.z}`;\n\t\t\t\t} else {\n\t\t\t\t\t// x,y,z non-zero\n\t\t\t\t\tconst zString = toCartesianComponent('z', this.a.z, this.d.z);\n\t\t\t\t\treturn `${xString} = ${yString} = ${zString}`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * clones and returns a new instance of this line\n\t */\n\tclone(): Line {\n\t\treturn new Line(this.a, this.d, { lambda: this.lambda });\n\t}\n}\n\nfunction toCartesianComponent(x: string, a: Fraction, d: Fraction): string {\n\tconst xMinusA = new Polynomial([1, a.negative()], { variable: x });\n\tlet xString: string;\n\tif (d.isEqualTo(1)) {\n\t\txString = `${xMinusA}`;\n\t} else {\n\t\t// d should be 1 since direction vectors are simplified during instantiation\n\t\t//// old code: const xNum = d.den === 1 ? `${xMinusA}` : `${d.den} \\\\left( ${xMinusA} \\\\right)`;\n\t\tconst xNum = `${xMinusA}`;\n\t\txString = `\\\\frac{${xNum}}{${d.num}}`;\n\t}\n\treturn xString;\n}\n\n/**\n * determinant of 2x2 matrix\n * [a1 a2]\n * [b1 b2]\n */\nfunction determinant(a1: Fraction, b1: Fraction, a2: Fraction, b2: Fraction): Fraction {\n\treturn a1.times(b2).minus(a2.times(b1));\n}\n","export {\n\tcramers,\n\tcramersFrac,\n\ttype NumberArray2x2,\n\ttype FractionArray2x2,\n\ttype NumberArray3x3,\n\ttype FractionArray3x3,\n\ttype NumberArray4x4,\n\ttype FractionArray4x4,\n} from './cramers';\nexport { determinantFrac } from './determinant';\nexport { bisection } from './bisection';\n","import { determinant, determinantFrac, determinantFrac4x4 } from './determinant';\nimport type { Fraction } from '../core';\n\n/**\n * apply Cramer's rule to 2x2 [[a b], [d e]] = [[c], [f]]\n * or to 3x3 [[a b c], [e f g], [i j k] = [[d], [h], [l]]]\n * or to 4x4\n */\nexport function cramers(...args: NumberArray2x2): [number, number];\nexport function cramers(...args: NumberArray3x3): [number, number, number];\nexport function cramers(...args: NumberArray4x4): [number, number, number, number];\nexport function cramers(...args: number[]): number[] {\n\tif (args.length === 6) {\n\t\tconst detA = determinant(...args.slice(0, 2), ...args.slice(3, 5));\n\t\tif (detA === 0) {\n\t\t\tthrow new Error('determinant 0: no roots found');\n\t\t}\n\t\tconst detX = determinant(args[2], args[1], args[5], args[4]);\n\t\tconst detY = determinant(args[0], args[2], args[3], args[5]);\n\t\treturn [detX / detA, detY / detA];\n\t} else if (args.length === 12) {\n\t\tconst detA = determinant(...args.slice(0, 3), ...args.slice(4, 7), ...args.slice(8, 11));\n\t\tif (detA === 0) {\n\t\t\tthrow new Error('determinant 0: no roots found');\n\t\t}\n\t\tconst detX = determinant(\n\t\t\targs[3],\n\t\t\t...args.slice(1, 3),\n\t\t\targs[7],\n\t\t\t...args.slice(5, 7),\n\t\t\targs[11],\n\t\t\t...args.slice(9, 11),\n\t\t);\n\t\tconst detY = determinant(args[0], args[3], args[2], args[4], args[7], args[6], args[8], args[11], args[10]);\n\t\tconst detZ = determinant(\n\t\t\t...args.slice(0, 2),\n\t\t\targs[3],\n\t\t\t...args.slice(4, 6),\n\t\t\targs[7],\n\t\t\t...args.slice(8, 10),\n\t\t\targs[11],\n\t\t);\n\t\treturn [detX / detA, detY / detA, detZ / detA];\n\t} else {\n\t\tthrow new Error('only 2x2 (6 arguments) and 3x3 (12 arguments) equations are supported');\n\t}\n}\n\n/**\n * apply Cramer's rule to 2x2 [[a b], [d e]] = [[c], [f]],\n * to 3x3 [[a b c], [e f g], [i j k] = [[d], [h], [l]]]\n * or 4x4\n */\nexport function cramersFrac(...args: FractionArray2x2): [Fraction, Fraction];\nexport function cramersFrac(...args: FractionArray3x3): [Fraction, Fraction, Fraction];\nexport function cramersFrac(...args: FractionArray4x4): [Fraction, Fraction, Fraction, Fraction];\nexport function cramersFrac(...args: (Fraction | number)[]): Fraction[] {\n\tif (args.length === 6) {\n\t\tconst detA = determinantFrac(...args.slice(0, 2), ...args.slice(3, 5));\n\t\tif (detA.isEqualTo(0)) {\n\t\t\tthrow new Error('determinant 0: no roots found');\n\t\t}\n\t\tconst detX = determinantFrac(args[2], args[1], args[5], args[4]);\n\t\tconst detY = determinantFrac(args[0], args[2], args[3], args[5]);\n\t\treturn [detX.divide(detA), detY.divide(detA)];\n\t} else if (args.length === 12) {\n\t\tconst detA = determinantFrac(...args.slice(0, 3), ...args.slice(4, 7), ...args.slice(8, 11));\n\t\tif (detA.isEqualTo(0)) {\n\t\t\tthrow new Error('determinant 0: no roots found');\n\t\t}\n\t\tconst detX = determinantFrac(\n\t\t\targs[3],\n\t\t\t...args.slice(1, 3),\n\t\t\targs[7],\n\t\t\t...args.slice(5, 7),\n\t\t\targs[11],\n\t\t\t...args.slice(9, 11),\n\t\t);\n\t\tconst detY = determinantFrac(args[0], args[3], args[2], args[4], args[7], args[6], args[8], args[11], args[10]);\n\t\tconst detZ = determinantFrac(\n\t\t\t...args.slice(0, 2),\n\t\t\targs[3],\n\t\t\t...args.slice(4, 6),\n\t\t\targs[7],\n\t\t\t...args.slice(8, 10),\n\t\t\targs[11],\n\t\t);\n\t\treturn [detX.divide(detA), detY.divide(detA), detZ.divide(detA)];\n\t} else if (args.length === 20) {\n\t\treturn cramersFrac4x4(...args);\n\t} else {\n\t\tthrow new Error('only 2x2 (6 arguments) and 3x3 (12 arguments) equations are supported');\n\t}\n}\n\n/**\n * apply Cramer's rule to 4x4\n *\n */\nfunction cramersFrac4x4(...args: (Fraction | number)[]): [Fraction, Fraction, Fraction, Fraction] {\n\tif (args.length !== 20) {\n\t\tthrow new Error('only 4x4 equations are supported');\n\t}\n\tconst det = determinantFrac4x4(\n\t\t...args.slice(0, 4),\n\t\t...args.slice(5, 9),\n\t\t...args.slice(10, 14),\n\t\t...args.slice(15, 19),\n\t);\n\tif (det.isEqualTo(0)) {\n\t\tthrow new Error('determinant 0: no roots found');\n\t}\n\t// 0  1  2  3  4\n\t// 5  6  7  8  9\n\t// 10 11 12 13 14\n\t// 15 16 17 18 19\n\tconst detA = determinantFrac4x4(\n\t\targs[4],\n\t\t...args.slice(1, 4),\n\t\targs[9],\n\t\t...args.slice(6, 9),\n\t\targs[14],\n\t\t...args.slice(11, 14),\n\t\targs[19],\n\t\t...args.slice(16, 19),\n\t);\n\tconst detB = determinantFrac4x4(\n\t\targs[0],\n\t\targs[4],\n\t\t...args.slice(2, 4),\n\t\targs[5],\n\t\targs[9],\n\t\t...args.slice(7, 9),\n\t\targs[10],\n\t\targs[14],\n\t\t...args.slice(12, 14),\n\t\targs[15],\n\t\targs[19],\n\t\t...args.slice(17, 19),\n\t);\n\t// 0  1  2  3  4\n\t// 5  6  7  8  9\n\t// 10 11 12 13 14\n\t// 15 16 17 18 19\n\tconst detC = determinantFrac4x4(\n\t\t...args.slice(0, 2),\n\t\targs[4],\n\t\targs[3],\n\t\t...args.slice(5, 7),\n\t\targs[9],\n\t\targs[8],\n\t\t...args.slice(10, 12),\n\t\targs[14],\n\t\targs[13],\n\t\t...args.slice(15, 17),\n\t\targs[19],\n\t\targs[18],\n\t);\n\tconst detD = determinantFrac4x4(\n\t\t...args.slice(0, 3),\n\t\targs[4],\n\t\t...args.slice(5, 8),\n\t\targs[9],\n\t\t...args.slice(10, 13),\n\t\targs[14],\n\t\t...args.slice(15, 18),\n\t\targs[19],\n\t);\n\treturn [detA.divide(det), detB.divide(det), detC.divide(det), detD.divide(det)];\n}\n\n/*\n\taugmented matrix for 2x2 equations of size 6\n*/\nexport type NumberArray2x2 = [number, number, number, number, number, number];\n/*\n\taugmented matrix for 2x2 equations of size 6\n*/\nexport type FractionArray2x2 = [\n\tFraction | number,\n\tFraction | number,\n\tFraction | number,\n\tFraction | number,\n\tFraction | number,\n\tFraction | number,\n];\n/*\n\taugmented matrix for 3x3 equations of size 12\n*/\nexport type NumberArray3x3 = [\n\tnumber,\n\tnumber,\n\tnumber,\n\tnumber,\n\tnumber,\n\tnumber,\n\tnumber,\n\tnumber,\n\tnumber,\n\tnumber,\n\tnumber,\n\tnumber,\n];\n/*\n\taugmented matrix for 3x3 equations of size 12\n*/\nexport type FractionArray3x3 = [\n\tFraction | number,\n\tFraction | number,\n\tFraction | number,\n\tFraction | number,\n\tFraction | number,\n\tFraction | number,\n\tFraction | number,\n\tFraction | number,\n\tFraction | number,\n\tFraction | number,\n\tFraction | number,\n\tFraction | number,\n];\n/*\n\taugmented matrix for 4x4 equations of size 20\n*/\nexport type NumberArray4x4 = [\n\tnumber,\n\tnumber,\n\tnumber,\n\tnumber,\n\tnumber,\n\tnumber,\n\tnumber,\n\tnumber,\n\tnumber,\n\tnumber,\n\tnumber,\n\tnumber,\n\tnumber,\n\tnumber,\n\tnumber,\n\tnumber,\n\tnumber,\n\tnumber,\n\tnumber,\n\tnumber,\n];\n/*\n\taugmented matrix for 4x4 equations of size 20\n*/\nexport type FractionArray4x4 = [\n\tFraction | number,\n\tFraction | number,\n\tFraction | number,\n\tFraction | number,\n\tFraction | number,\n\tFraction | number,\n\tFraction | number,\n\tFraction | number,\n\tFraction | number,\n\tFraction | number,\n\tFraction | number,\n\tFraction | number,\n\tFraction | number,\n\tFraction | number,\n\tFraction | number,\n\tFraction | number,\n\tFraction | number,\n\tFraction | number,\n\tFraction | number,\n\tFraction | number,\n];\n","import { numberToFraction, type Fraction } from '../core';\n\n/**\n * determinant of [[a b], [c d]] 2x2 matrix or [[a b c], [d e f], [g h i]] 3x3 matrix\n *\n * WARNING: does not work for any other sizes\n */\nexport function determinant(...args: number[]): number {\n\tif (args.length === 4) {\n\t\treturn args[0] * args[3] - args[1] * args[2];\n\t} else if (args.length === 9) {\n\t\treturn (\n\t\t\targs[0] * determinant(args[4], args[5], args[7], args[8]) -\n\t\t\targs[1] * determinant(args[3], args[5], args[6], args[8]) +\n\t\t\targs[2] * determinant(args[3], args[4], args[6], args[7])\n\t\t);\n\t} else {\n\t\tthrow new Error('determinant: only 2x2 or 3x3 matrices supported');\n\t}\n}\n\nexport function determinantFrac4x4(...args: (number | Fraction)[]): Fraction {\n\t// 0 1 2   3\n\t// 4 5 6   7\n\t// 8 9 10 11\n\t// 12 13 14 15 - + - +\n\tconst argsFrac = args.map((arg) => numberToFraction(arg));\n\tconst a = argsFrac[12].times(\n\t\tdeterminantFrac(...argsFrac.slice(1, 4), ...argsFrac.slice(5, 8), ...argsFrac.slice(9, 12)),\n\t);\n\tconst b = argsFrac[13].times(\n\t\tdeterminantFrac(argsFrac[0], ...argsFrac.slice(2, 5), ...argsFrac.slice(6, 9), ...argsFrac.slice(10, 12)),\n\t);\n\tconst c = argsFrac[14].times(\n\t\tdeterminantFrac(\n\t\t\t...argsFrac.slice(0, 2),\n\t\t\t...argsFrac.slice(3, 6),\n\t\t\t...argsFrac.slice(7, 10),\n\t\t\t...argsFrac.slice(11, 12),\n\t\t),\n\t);\n\tconst d = argsFrac[15].times(\n\t\tdeterminantFrac(...argsFrac.slice(0, 3), ...argsFrac.slice(4, 7), ...argsFrac.slice(8, 11)),\n\t);\n\treturn a.negative().plus(b).minus(c).plus(d);\n}\n\n/**\n * determinant of [[a b], [c d]] 2x2 matrix or [[a b c], [d e f], [g h i]] 3x3 matrix\n *\n * WARNING: does not work for any other sizes\n */\nexport function determinantFrac(...args: (number | Fraction)[]): Fraction {\n\tconst argsFrac = args.map((arg) => numberToFraction(arg));\n\tif (argsFrac.length === 4) {\n\t\treturn argsFrac[0].times(argsFrac[3]).minus(argsFrac[1].times(argsFrac[2]));\n\t} else if (argsFrac.length === 9) {\n\t\tconst a = argsFrac[0].times(determinantFrac(argsFrac[4], argsFrac[5], argsFrac[7], argsFrac[8]));\n\t\tconst b = argsFrac[1].times(determinantFrac(argsFrac[3], argsFrac[5], argsFrac[6], argsFrac[8]));\n\t\tconst c = argsFrac[2].times(determinantFrac(argsFrac[3], argsFrac[4], argsFrac[6], argsFrac[7]));\n\t\treturn a.minus(b).plus(c);\n\t} else {\n\t\tthrow new Error('determinant: only 2x2 or 3x3 matrices supported');\n\t}\n}\n","/**\n * implementation of the bisection method for numerical root finding.\n *\n * @param f function\n * @param lower lower bound (sign must be different at lower and upper)\n * @param upper upper bound (sign must be different at lower and upper)\n * @param precision number of digits after the decimal point to match before terminating\n */\nexport function bisection(f: (x: number) => number, lower: number, upper: number, precision = 5): number {\n\tif (Math.abs(upper - lower) < Math.pow(10, -precision)) {\n\t\treturn (upper + lower) / 2;\n\t} else {\n\t\tconst fa = f(lower);\n\t\tconst fb = f(upper);\n\t\tif (Math.sign(fa) === Math.sign(fb)) {\n\t\t\tthrow new Error('bisection ERROR: no sign change detected');\n\t\t}\n\t\tconst midPt = (lower + upper) / 2;\n\t\tif (Math.sign(fa) === Math.sign(f(midPt))) {\n\t\t\treturn bisection(f, midPt, upper, precision);\n\t\t} else {\n\t\t\treturn bisection(f, lower, midPt, precision);\n\t\t}\n\t}\n}\n","import { Vector } from './vectorClass';\nimport { Line } from './lineClass';\nimport { type Fraction, SquareRoot, Term, Expression, numberToFraction } from '../core';\n\n/**\n * Plane class representing a 3D Plane represented in scalar product form\n * r \\cdot n = rhs, where rhs = a \\cdot n and a is a point on the plane,\n * n is a normal vector perpendicular to the plane,\n * and lambda is the parameter\n */\nexport class Plane {\n\tn: Vector;\n\trhs: Fraction;\n\t/**\n\t * mode 1: normal vector, rhs\n\t *\n\t * mode 2: normal vector, pt\n\t *\n\t * mode 3: pt, d1, d2, {points: 1}\n\t *\n\t * mode 4: pt1, pt2, d, {points: 2}\n\t *\n\t * mode 5: pt1, pt2, pt3, {points: 3}\n\t */\n\tconstructor(n: Vector, rhs?: number | Fraction);\n\tconstructor(n: Vector, a: Vector);\n\tconstructor(pt: Vector, d1: Vector, d2: Vector, options: { points: 1 });\n\tconstructor(pt1: Vector, pt2: Vector, d1: Vector, options: { points: 2 });\n\tconstructor(pt1: Vector, pt2: Vector, pt3: Vector, options: { points: 3 });\n\t//constructor(\n\t//\tv1: Vector,\n\t//\toptions?: {\n\t//\t\tmode?: 'rhs' | 'ptN' | 'ptDD' | 'ptPtD' | 'ptPtPt';\n\t//\t\trhs?: number | Fraction;\n\t//\t\tv2?: Vector;\n\t//\t\tv3?: Vector;\n\t//\t},\n\t//) {\n\tconstructor(v1: Vector, v2: number | Fraction | Vector = 0, v3?: Vector, options?: { points: 1 | 2 | 3 }) {\n\t\tlet n: Vector;\n\t\tif (v3 === undefined) {\n\t\t\tn = v1.clone();\n\t\t\tthis.rhs = v2 instanceof Vector ? n.dot(v2) : numberToFraction(v2);\n\t\t} else if (options) {\n\t\t\tif (!(v2 instanceof Vector)) {\n\t\t\t\tthrow new Error(`Expected second argument ${v2} to be a vector`);\n\t\t\t}\n\t\t\tif (options.points === 1) {\n\t\t\t\tn = v2.cross(v3).simplify({ stretchable: true });\n\t\t\t\tthis.rhs = v1.dot(n);\n\t\t\t} else if (options.points === 2) {\n\t\t\t\tn = v3.cross(v2.minus(v1)).simplify({ stretchable: true });\n\t\t\t\tthis.rhs = v1.dot(n);\n\t\t\t} else if (options.points === 3) {\n\t\t\t\tn = v2.minus(v1).cross(v3.minus(v1)).simplify({ stretchable: true });\n\t\t\t\tthis.rhs = v1.dot(n);\n\t\t\t} else {\n\t\t\t\tthrow new Error(`Unexpected options object: options.points should be 1/2/3: ${options}`);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error(`unexpected plane inputs ${v1} ${v2} ${v3} ${options}`);\n\t\t}\n\t\tif (n.isEqualTo(Vector.ZERO)) {\n\t\t\tthrow new Error('normal vector cannot be zero');\n\t\t}\n\t\tthis.n = n;\n\t}\n\n\t/**\n\t * checks if this plane contains a point/line\n\t */\n\tcontains(pointOrLine: Vector | Line): boolean {\n\t\tif (pointOrLine instanceof Vector) {\n\t\t\t// point\n\t\t\treturn this.rhs.isEqualTo(this.n.dot(pointOrLine));\n\t\t} else {\n\t\t\t// line\n\t\t\treturn this.contains(pointOrLine.a) && this.n.isPerpendicularTo(pointOrLine.d);\n\t\t}\n\t}\n\n\t/**\n\t * checks if this plane is parallel to line or plane\n\t */\n\tisParallelTo(lineOrPlane: Plane | Line): boolean {\n\t\tif (lineOrPlane instanceof Line) {\n\t\t\t// line\n\t\t\treturn this.n.isPerpendicularTo(lineOrPlane.d);\n\t\t} else {\n\t\t\t// plane\n\t\t\treturn this.n.isParallelTo(lineOrPlane.n);\n\t\t}\n\t}\n\n\t/**\n\t * checks if two planes are the same\n\t */\n\tisEqualTo(p2: Plane): boolean {\n\t\tif (this.isParallelTo(p2)) {\n\t\t\t// n1 = k n2\n\t\t\tlet k: Fraction;\n\t\t\tif (this.n.x.isEqualTo(0)) {\n\t\t\t\tif (this.n.y.isEqualTo(0)) {\n\t\t\t\t\t// theoretically z component should be non-zero\n\t\t\t\t\tk = this.n.z.divide(p2.n.z);\n\t\t\t\t} else {\n\t\t\t\t\tk = this.n.y.divide(p2.n.y);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// division of x component allowed\n\t\t\t\tk = this.n.x.divide(p2.n.x);\n\t\t\t}\n\t\t\treturn this.rhs.isEqualTo(p2.rhs.times(k));\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @returns a point on the plane\n\t *\n\t * tries (x,0,0) if possible, followed by (0,y,0) and (0,0,z)\n\t */\n\tpoint(): Vector {\n\t\tif (this.n.x.isEqualTo(0)) {\n\t\t\tif (this.n.y.isEqualTo(0)) {\n\t\t\t\t// theoretically this.n.z should be non-zero\n\t\t\t\treturn new Vector(0, 0, this.rhs.divide(this.n.z));\n\t\t\t} else {\n\t\t\t\t// (0,y,0)\n\t\t\t\treturn new Vector(0, this.rhs.divide(this.n.y));\n\t\t\t}\n\t\t} else {\n\t\t\t// (x,0,0)\n\t\t\treturn new Vector(this.rhs.divide(this.n.x));\n\t\t}\n\t}\n\n\t/**\n\t * finds angle between this plane and vector/line/plane\n\t */\n\tangleTo(v: Vector | Line | Plane): string {\n\t\tif (v instanceof Plane) {\n\t\t\treturn this.n.angleTo(v.n, { acute: true });\n\t\t} else {\n\t\t\tv = v instanceof Line ? v.d : v;\n\t\t\treturn this.n.angleTo(v, { acute: true, sineMode: true });\n\t\t}\n\t}\n\n\t/**\n\t * finds distance between this plane to a point or a parallel line/plane\n\t */\n\tdistanceTo(v: Vector | Line | Plane): SquareRoot {\n\t\tlet ab: Vector;\n\t\tif (v instanceof Line) {\n\t\t\tif (this.isParallelTo(v)) {\n\t\t\t\tv = v.a;\n\t\t\t} else {\n\t\t\t\t// intersecting\n\t\t\t\treturn new SquareRoot(0);\n\t\t\t}\n\t\t} else if (v instanceof Plane) {\n\t\t\tif (this.isParallelTo(v)) {\n\t\t\t\tv = v.point();\n\t\t\t} else {\n\t\t\t\t// intersecting\n\t\t\t\treturn new SquareRoot(0);\n\t\t\t}\n\t\t}\n\t\tconst modABDotN = new SquareRoot(1, v.minus(this.point()).dot(this.n).abs());\n\t\treturn modABDotN.divide(this.n.magnitude());\n\t}\n\n\t/**\n\t * finds intersection between this plane and another line/plane\n\t */\n\tintersect(lineOrPlane: Line | Plane): Vector | Line | null | Plane {\n\t\treturn lineOrPlane instanceof Line ? this.intersectLine(lineOrPlane) : this.intersectPlane(lineOrPlane);\n\t}\n\n\t/**\n\t * finds lambda of line such that line intersects plane\n\t */\n\tintersectLineParam(l: Line): Fraction {\n\t\tif (this.isParallelTo(l)) {\n\t\t\tthrow new Error('line parallel to plane');\n\t\t}\n\t\treturn this.rhs.minus(l.a.dot(this.n)).divide(l.d.dot(this.n));\n\t}\n\n\t/**\n\t * finds the intersection between this plane and a line\n\t */\n\tintersectLine(l: Line): Vector | null | Line {\n\t\tif (this.isParallelTo(l)) {\n\t\t\t// parallel or on\n\t\t\treturn this.contains(l) ? l.clone() : null;\n\t\t}\n\t\t// intersecting\n\t\tconst lambda = this.intersectLineParam(l);\n\t\treturn l.point(lambda);\n\t}\n\n\t/**\n\t * finds the intersection between this plane and a plane\n\t */\n\tintersectPlane(p2: Plane): Line | null | Plane {\n\t\tif (this.isParallelTo(p2)) {\n\t\t\t// parallel or coincident\n\t\t\treturn this.isEqualTo(p2) ? p2.clone() : null;\n\t\t}\n\t\t// intersecting\n\t\tconst d1 = this.n.cross(p2.n).simplify({ stretchable: true });\n\t\tlet d = d1.clone();\n\t\tif (\n\t\t\td1.z.isLessThan(0) ||\n\t\t\t(d1.z.isEqualTo(0) && d1.y.isLessThan(0)) ||\n\t\t\t(d1.z.isEqualTo(0) && d1.y.isEqualTo(0) && d1.x.isLessThan(0))\n\t\t) {\n\t\t\td = d1.negative();\n\t\t}\n\t\t// try z = 0\n\t\tlet det = determinant(this.n.x, this.n.y, p2.n.x, p2.n.y);\n\t\tif (det.isEqualTo(0)) {\n\t\t\t// try y = 0\n\t\t\tdet = determinant(this.n.x, this.n.z, p2.n.x, p2.n.z);\n\t\t\tif (det.isEqualTo(0)) {\n\t\t\t\t// x = 0\n\t\t\t\tdet = determinant(this.n.y, this.n.z, p2.n.y, p2.n.z);\n\t\t\t\t// theoretically non-zero since planes not parallel\n\t\t\t\tconst y = determinant(this.rhs, this.n.z, p2.rhs, p2.n.z).divide(det);\n\t\t\t\tconst z = determinant(this.n.y, this.rhs, p2.n.y, p2.rhs).divide(det);\n\t\t\t\treturn new Line(new Vector(0, y, z), d);\n\t\t\t} else {\n\t\t\t\t// y = 0\n\t\t\t\tconst x = determinant(this.rhs, this.n.z, p2.rhs, p2.n.z).divide(det);\n\t\t\t\tconst z = determinant(this.n.x, this.rhs, p2.n.x, p2.rhs).divide(det);\n\t\t\t\treturn new Line(new Vector(x, 0, z), d);\n\t\t\t}\n\t\t} else {\n\t\t\t// z = 0\n\t\t\tconst y = determinant(this.n.x, this.rhs, p2.n.x, p2.rhs).divide(det);\n\t\t\tconst x = determinant(this.rhs, this.n.y, p2.rhs, p2.n.y).divide(det);\n\t\t\treturn new Line(new Vector(x, y, 0), d);\n\t\t}\n\t}\n\n\t/**\n\t * finds the foot of perpendicular from point to this plane\n\t */\n\tfootOfPerpendicular(point: Vector): Vector {\n\t\tconst AB = point.minus(this.point());\n\t\tconst ABDotN = AB.dot(this.n);\n\t\tconst lambda = ABDotN.divide(this.n.magnitudeSquare());\n\t\tconst FB = this.n.multiply(lambda);\n\t\treturn point.minus(FB).expand();\n\t}\n\n\t/**\n\t * finds the reflection of point about this plane\n\t */\n\tpointReflection(point: Vector): Vector {\n\t\tconst OF = this.footOfPerpendicular(point);\n\t\treturn OF.multiply(2).minus(point).expand();\n\t}\n\n\t/**\n\t * finds the reflection of line l about this plane\n\t */\n\tlineReflection(l: Line): Line {\n\t\tif (this.isParallelTo(l)) {\n\t\t\tconst OAPrime = this.pointReflection(l.a);\n\t\t\treturn new Line(OAPrime, l.d);\n\t\t}\n\t\t// line and plane intersect at one point\n\t\tconst OX = this.intersect(l) as Vector;\n\t\tlet OA = l.a;\n\t\t// ensure OA doesn't lie on plane\n\t\tif (this.contains(OA)) {\n\t\t\tOA = l.point(1);\n\t\t}\n\t\tconst OAPrime = this.pointReflection(OA);\n\t\treturn new Line(OX, OAPrime, { twoPointsMode: true });\n\t}\n\n\t/**\n\t * reflects a point/line about this plane\n\t */\n\treflect(pointOrLine: Line | Vector): Vector | Line {\n\t\treturn pointOrLine instanceof Line ? this.lineReflection(pointOrLine) : this.pointReflection(pointOrLine);\n\t}\n\n\t/**\n\t * @returns equation of the plane r \\cdot n = rhs in column vector form\n\t */\n\ttoString(): string {\n\t\treturn `\\\\mathbf{r} \\\\cdot ${this.n} = ${this.rhs}`;\n\t}\n\n\t/**\n\t * @returns equation of the line r = a + lambda d in ijk form\n\t */\n\ttoIJKString(): string {\n\t\treturn `\\\\mathbf{r} \\\\cdot \\\\left( ${this.n.toIJKString()} \\\\right) = ${this.rhs}`;\n\t}\n\n\t/**\n\t * @returns cartesian equation of the line\n\t */\n\ttoCartesianString(): string {\n\t\tconst xyzExpression = new Expression(new Term(this.n.x, 'x'), new Term(this.n.y, 'y'), new Term(this.n.z, 'z'));\n\t\treturn `${xyzExpression} = ${this.rhs}`;\n\t}\n\n\t/**\n\t * clones a new instance of this line\n\t */\n\tclone(): Plane {\n\t\treturn new Plane(this.n, this.rhs);\n\t}\n}\n\n/**\n * determinant of 2x2 matrix\n * [a1 a2]\n * [b1 b2]\n */\nfunction determinant(a1: Fraction, b1: Fraction, a2: Fraction, b2: Fraction): Fraction {\n\treturn a1.times(b2).minus(a2.times(b1));\n}\n","import { Fraction, VariableTerm, Term, Expression, numberToFraction } from '../core/index';\nimport { Vector } from './vectorClass';\n\n/**\n * \"Extended\" Vector class representing a 3D vector coeff(x i + y j + z k),\n * where x,y and z can be Expressions\n */\nexport class xVector {\n\tx: Expression;\n\ty: Expression;\n\tz: Expression;\n\tcoeff: Fraction;\n\t/**\n\t * creates a new Vector instance\n\t *\n\t * @param options defaults to `{coeff: 1, simplify: false, stretchable: false}`\n\t *  if `simplify` is `true`, then we will factorize our expression such that\n\t *  x,y,z are integers with gcd 1.\n\t *  if `stretchable` is set to true, then we will `simplify` and then\n\t *  set `coeff` to be 1\n\t *\n\t */\n\tconstructor(\n\t\tx: number | Fraction | string | Term | Expression,\n\t\ty?: number | Fraction | string | Term | Expression,\n\t\tz?: number | Fraction | string | Term | Expression,\n\t\toptions?: { coeff?: number | Fraction },\n\t) {\n\t\tx = toExpression(x);\n\t\ty = y === undefined ? toExpression(0) : toExpression(y);\n\t\tz = z === undefined ? toExpression(0) : toExpression(z);\n\t\tlet { coeff } = {\n\t\t\tcoeff: 1,\n\t\t\t...options,\n\t\t};\n\t\tcoeff = numberToFraction(coeff);\n\t\tthis.x = coeff.isEqualTo(0) ? toExpression(0) : x;\n\t\tthis.y = coeff.isEqualTo(0) ? toExpression(0) : y;\n\t\tthis.z = coeff.isEqualTo(0) ? toExpression(0) : z;\n\t\tthis.coeff = coeff.isEqualTo(0) ? Fraction.ONE : coeff;\n\t}\n\n\t/**\n\t * Expands the coeff, taking this k(x,y,z) and\n\t * returning (kx, ky, kz)\n\t */\n\texpand(): xVector {\n\t\treturn new xVector(this.x.times(this.coeff), this.y.times(this.coeff), this.z.times(this.coeff));\n\t}\n\n\t/**\n\t * @returns the dot product\n\t */\n\tdot(v2: xVector | Vector): Expression {\n\t\tconst x = this.x.times(v2.x);\n\n\t\treturn this.x.times(v2.x).plus(this.y.times(v2.y)).plus(this.z.times(v2.z)).times(this.coeff).times(v2.coeff);\n\t}\n\n\t/**\n\t * @returns the magnitude squared of this vector\n\t */\n\tmagnitudeSquare(): Expression {\n\t\treturn this.dot(this);\n\t}\n\n\t/**\n\t * @returns if the vector is a zero vector\n\t */\n\tisZero(): boolean {\n\t\treturn `${this.magnitudeSquare()}` === '0';\n\t}\n\n\t/**\n\t * vector addition\n\t *\n\t * if the coeffs are the same, will retain the same coeff\n\t *\n\t * if the coeffs are different, will expand them in before performing addition\n\t */\n\tplus(v2: xVector | Vector): xVector {\n\t\tif (this.coeff.isEqualTo(v2.coeff)) {\n\t\t\treturn new xVector(this.x.plus(v2.x), this.y.plus(v2.y), this.z.plus(v2.z));\n\t\t} else {\n\t\t\treturn this.expand().plus(v2.expand());\n\t\t}\n\t}\n\n\t/**\n\t * returns the negative of this vector\n\t *\n\t * @param options default to `{multiplyIntoCoeff: false}`\n\t * the coeff stays the same while the components are made negative\n\t * if false, the coeff is made negative instead\n\t */\n\tnegative(options = { multiplyIntoCoeff: false }): xVector {\n\t\treturn options.multiplyIntoCoeff\n\t\t\t? new xVector(this.x, this.y, this.z, { coeff: this.coeff.negative() })\n\t\t\t: new xVector(this.x.negative(), this.y.negative(), this.z.negative(), { coeff: this.coeff });\n\t}\n\n\t/**\n\t * vector subtraction\n\t */\n\tminus(v2: xVector | Vector): xVector {\n\t\treturn this.plus(v2.negative());\n\t}\n\n\t/**\n\t * scalar multiplication\n\t *\n\t * by default, the coeff stays the same while the components are multiplied\n\t * if false, the coeff is multiplied instead\n\t *\n\t * @param options defaults to `{multiplyIntoCoeff: false}`\n\t */\n\tmultiply(k: number | Fraction, options = { multiplyIntoCoeff: false }): xVector {\n\t\treturn options.multiplyIntoCoeff\n\t\t\t? new xVector(this.x, this.y, this.z, { coeff: this.coeff.times(k) })\n\t\t\t: new xVector(this.x.times(k), this.y.times(k), this.z.times(k), { coeff: this.coeff });\n\t}\n\n\t/**\n\t * @returns the cross product (this cross v2)\n\t */\n\tcross(v2: xVector | Vector): xVector {\n\t\tconst coeff = this.coeff.times(v2.coeff);\n\t\tconst x = this.y.times(v2.z).minus(this.z.times(v2.y));\n\t\tconst y = this.z.times(v2.x).minus(this.x.times(v2.z));\n\t\tconst z = this.x.times(v2.y).minus(this.y.times(v2.x));\n\t\treturn new xVector(x, y, z, { coeff });\n\t}\n\n\t/**\n\t * checks if this is perpendicular to v2\n\t */\n\tisPerpendicularTo(v2: xVector | Vector): boolean {\n\t\treturn `${this.dot(v2)}` === '0';\n\t}\n\n\t/**\n\t * checks if this is parallel to v2\n\t */\n\tisParallelTo(v2: xVector | Vector): boolean {\n\t\treturn this.cross(v2).isZero();\n\t}\n\n\tsubIn(x: Fraction): Vector {\n\t\treturn new Vector(this.x.subIn(x), this.y.subIn(x), this.z.subIn(x), { coeff: this.coeff });\n\t}\n\n\t/**\n\t * @returns latex string representing the vector in column vector form\n\t */\n\ttoString(): string {\n\t\tif (this.isZero()) {\n\t\t\treturn `\\\\begin{pmatrix}\\n\\t0 \\\\\\\\\\n\\t0 \\\\\\\\\\n\\t0\\n\\\\end{pmatrix}`;\n\t\t}\n\t\tconst columnVector = `\\\\begin{pmatrix}\\n\\t${this.x} \\\\\\\\\\n\\t${this.y} \\\\\\\\\\n\\t${this.z}\\n\\\\end{pmatrix}`;\n\t\tconst term = new Term(this.coeff, columnVector);\n\t\treturn `${term}`;\n\t}\n\n\ttoCartesianString(): string {\n\t\tconst xTerm = this.x.times('x');\n\t\tconst yTerm = this.y.times('y');\n\t\tconst zTerm = this.z.times('z');\n\t\tconst cartesianExpression = xTerm.plus(yTerm).plus(zTerm);\n\t\treturn `${cartesianExpression}`;\n\t}\n\n\t/**\n\t * @returns (kx, ky, kz) as a coordinate triple.\n\t *\n\t * @param name The name of the point which is attached to the front of the coordinates\n\t */\n\ttoCoordinates(name = ''): string {\n\t\tconst v = this.expand();\n\t\treturn `${name}\\\\left( ${v.x}, ${v.y}, ${v.z} \\\\right)`;\n\t}\n\n\t/**\n\t * checks if two vectors are equal\n\t */\n\tisEqualTo(v2: xVector | Vector): boolean {\n\t\treturn `${this.minus(v2).magnitudeSquare()}` === '0';\n\t}\n\n\t/**\n\t * clones a new instance of this vector\n\t */\n\tclone(): xVector {\n\t\treturn new xVector(this.x, this.y, this.z, { coeff: this.coeff });\n\t}\n\n\t////\n\t// static properties\n\t////\n\n\t/**\n\t * the zero vector\n\t */\n\tstatic ZERO = new xVector(0);\n\t/**\n\t * the x-axis unit vector (1,0,0)\n\t */\n\tstatic I = new xVector(1);\n\t/**\n\t * the y-axis unit vector (0,1,0)\n\t */\n\tstatic J = new xVector(0, 1);\n\t/**\n\t * the z-axis unit vector (0,0,1)\n\t */\n\tstatic K = new xVector(0, 0, 1);\n}\n\nfunction toExpression(x: number | Fraction | string | Term | Expression): Expression {\n\tif (typeof x === 'number' || x instanceof Fraction || typeof x === 'string') {\n\t\treturn new Expression(new Term(x));\n\t}\n\treturn x instanceof Term ? new Expression(x) : x.clone();\n}\n","import { Fraction, VariableTerm, BasicTerm, Term, Expression } from '../core/index';\n\n/**\n * An unknown vector represented by k a\n */\nexport class uVector extends BasicTerm {\n\tvector: string;\n\t/**\n\t * Creates a new unknown vector\n\t * @param coeff the k in k a\n\t * @param vector the a in k a\n\t */\n\tconstructor(vector: string, coeff: Fraction | number = 1) {\n\t\t// bold face if not already\n\t\tvector = vector.slice(0, 7) === '\\\\mathbf' ? vector : `\\\\mathbf{${vector}}`;\n\t\tsuper(coeff, vector);\n\t\tthis.vector = vector;\n\t}\n\n\tplus(v: uVector | string): uVectorExpression {\n\t\treturn new uVectorExpression(this, v);\n\t}\n\tnegative(): uVector {\n\t\treturn new uVector(this.vector, this.coeff.negative());\n\t}\n\tminus(v: uVector | string): uVectorExpression {\n\t\tv = v instanceof uVector ? v : new uVector(v);\n\t\treturn new uVectorExpression(this, v.negative());\n\t}\n\t/** scalar multiplication */\n\tmultiply(k: number | Fraction): uVector {\n\t\treturn new uVector(this.vector, this.coeff.times(k));\n\t}\n\t/** scalar (dot) product */\n\tdot(v: uVector | string): Term {\n\t\tv = v instanceof uVector ? v : new uVector(v);\n\t\tif (this.vector === v.vector) {\n\t\t\treturn new Term(this.coeff.times(v.coeff), `\\\\left| ${this.vector} \\\\right|^2`);\n\t\t}\n\t\tconst [v1, v2] = [this.vector, v.vector].sort();\n\t\treturn new Term(this.coeff.times(v.coeff), `${v1} \\\\cdot ${v2}`);\n\t}\n\t/** vector (cross) product */\n\tcross(v: uVector | string): uVector {\n\t\tv = v instanceof uVector ? v : new uVector(v);\n\t\tif (this.vector === v.vector) {\n\t\t\treturn new uVector(this.vector, 0);\n\t\t}\n\t\tconst [v1, v2] = [this.vector, v.vector].sort();\n\t\tconst coeff = v1 === this.vector ? this.coeff.times(v.coeff) : this.coeff.times(v.coeff).negative();\n\t\treturn new uVector(`${v1} \\\\times ${v2}`, coeff);\n\t}\n\n\tclone(): uVector {\n\t\treturn new uVector(this.vector, this.coeff);\n\t}\n}\n\nexport class uVectorExpression {\n\tvectors: uVector[];\n\n\tconstructor(...args: (string | uVector)[]) {\n\t\tconst terms = args.map((term) => {\n\t\t\tif (typeof term === 'string') {\n\t\t\t\treturn new uVector(term);\n\t\t\t}\n\t\t\treturn term.clone();\n\t\t});\n\t\t// combine like terms and remove zero terms\n\t\tthis.vectors = combineLikeVectors(terms).filter((term) => !term.coeff.isEqualTo(0));\n\t}\n\n\tplus(v: string | uVector | uVectorExpression): uVectorExpression {\n\t\tif (typeof v === 'string' || v instanceof uVector) {\n\t\t\treturn new uVectorExpression(...this.vectors, v);\n\t\t}\n\t\treturn new uVectorExpression(...this.vectors, ...v.vectors);\n\t}\n\tnegative(): uVectorExpression {\n\t\treturn new uVectorExpression(...this.vectors.map((vector) => vector.negative()));\n\t}\n\tminus(v: string | uVector | uVectorExpression): uVectorExpression {\n\t\tif (typeof v === 'string') {\n\t\t\tv = new uVector(v);\n\t\t}\n\t\tif (v instanceof uVector) {\n\t\t\treturn new uVectorExpression(...this.vectors, v.negative());\n\t\t}\n\t\treturn new uVectorExpression(...this.vectors, ...v.negative().vectors);\n\t}\n\t/** scalar multiplication */\n\tmultiply(k: number | Fraction) {\n\t\treturn new uVectorExpression(...this.vectors.map((vector) => vector.multiply(k)));\n\t}\n\t/** scalar (dot) product */\n\tdot(v: string | uVector | uVectorExpression): Expression {\n\t\tif (!(v instanceof uVectorExpression)) {\n\t\t\tconst vectors = this.vectors.map((vector) => vector.dot(v));\n\t\t\treturn new Expression(...vectors);\n\t\t}\n\t\treturn v.vectors.reduce((exp, term) => exp.plus(this.dot(term)), new Expression(0));\n\t}\n\t/** vector (cross) product */\n\tcross(v: string | uVector | uVectorExpression): uVectorExpression {\n\t\tif (!(v instanceof uVectorExpression)) {\n\t\t\tconst vectors = this.vectors.map((vector) => vector.cross(v));\n\t\t\treturn new uVectorExpression(...vectors);\n\t\t}\n\t\treturn v.vectors.reduce((exp, term) => exp.plus(this.cross(term)), new uVectorExpression(new uVector('a', 0)));\n\t}\n\n\t/**\n\t * `toString` method\n\t *\n\t * @returns the LaTeX string representation of the sum of all the vectors\n\t */\n\ttoString(): string {\n\t\tif (this.vectors.length === 0) {\n\t\t\treturn '0';\n\t\t}\n\t\tlet outputString = '';\n\t\tthis.vectors.forEach((vector, i) => {\n\t\t\tif (i !== 0) {\n\t\t\t\toutputString += vector.coeff.isGreaterThan(0) ? ' + ' : ' ';\n\t\t\t}\n\t\t\toutputString += vector.toString();\n\t\t});\n\t\treturn outputString;\n\t}\n\n\tclone(): uVectorExpression {\n\t\treturn new uVectorExpression(...this.vectors.map((vector) => vector.clone()));\n\t}\n}\n\n/**\n * An unknown vector represented by k a, where k can potentially be unknown\n */\nexport class uxVector {\n\tcoeff: Term;\n\tvector: string;\n\t/**\n\t * Creates a new unknown vector\n\t * @param coeff the k in k a\n\t * @param vector the a in k a\n\t */\n\tconstructor(vector: string, coeff: Fraction | number | string | Term = 1) {\n\t\t// bold face if not already\n\t\tvector = vector.slice(0, 7) === '\\\\mathbf' ? vector : `\\\\mathbf{${vector}}`;\n\t\tif (coeff instanceof Term) {\n\t\t\tthis.coeff = coeff.clone();\n\t\t} else {\n\t\t\tthis.coeff = new Term(coeff);\n\t\t}\n\t\tthis.vector = vector;\n\t}\n\n\tplus(v: uVector | string | uxVector): uxVectorExpression {\n\t\treturn new uxVectorExpression(this, v);\n\t}\n\tnegative(): uxVector {\n\t\treturn new uxVector(this.vector, this.coeff.negative());\n\t}\n\tminus(v: uVector | string | uxVector): uxVectorExpression {\n\t\tv = typeof v === 'string' ? new uxVector(v) : v;\n\t\treturn new uxVectorExpression(this, v.negative());\n\t}\n\t/** scalar multiplication */\n\tmultiply(k: number | Fraction): uxVector {\n\t\treturn new uxVector(this.vector, this.coeff.times(k));\n\t}\n\t/** scalar (dot) product */\n\tdot(v: uVector | string | uxVector): Term {\n\t\tv = typeof v === 'string' ? new uxVector(v) : v;\n\t\tif (this.vector === v.vector) {\n\t\t\treturn new Term(1, `\\\\left| ${this.vector} \\\\right|^2`).times(this.coeff).times(v.coeff);\n\t\t}\n\t\tconst [v1, v2] = [this.vector, v.vector].sort();\n\t\treturn new Term(1, `\\\\mathbf{${v1}} \\\\cdot \\\\mathbf{${v2}}`).times(this.coeff).times(v.coeff);\n\t}\n\t/** vector (cross) product */\n\tcross(v: uVector | string | uxVector): uxVector {\n\t\tv = typeof v === 'string' ? new uVector(v) : v;\n\t\tif (this.vector === v.vector) {\n\t\t\treturn new uxVector(this.vector, 0);\n\t\t}\n\t\tconst [v1, v2] = [this.vector, v.vector].sort();\n\t\treturn this.vector === v1\n\t\t\t? new uxVector(`\\\\mathbf{${v1}} \\\\times \\\\mathbf{${v2}}`, this.coeff.times(v.coeff))\n\t\t\t: new uxVector(`\\\\mathbf{${v1}} \\\\times \\\\mathbf{${v2}}`, this.coeff.times(v.coeff).negative());\n\t}\n\t/** sub in unknown into the coefficient term */\n\tsubIn(x: Fraction | number): uVector {\n\t\treturn new uVector(this.vector, this.coeff.subIn(x));\n\t}\n\n\tclone(): uxVector {\n\t\treturn new uxVector(this.vector, this.coeff);\n\t}\n\n\ttoString(): string {\n\t\tif (`${this.coeff}` === `0`) {\n\t\t\treturn '\\\\mathbf{0}';\n\t\t} else if (`${this.coeff}` === `1`) {\n\t\t\treturn `${this.vector}`;\n\t\t} else if (`${this.coeff}` === `- 1`) {\n\t\t\treturn `- ${this.vector}`;\n\t\t} else {\n\t\t\treturn `${this.coeff} ${this.vector}`;\n\t\t}\n\t}\n}\n\nexport class uxVectorExpression {\n\tvectors: (uVector | uxVector)[];\n\n\tconstructor(...args: (string | uVector | uxVector)[]) {\n\t\tconst terms = args.map((term) => {\n\t\t\tif (typeof term === 'string') {\n\t\t\t\treturn new uVector(term);\n\t\t\t}\n\t\t\treturn term.clone();\n\t\t});\n\t\t// combine like terms and remove zero terms\n\t\tthis.vectors = combineLikeXVectors(terms).filter((term) => `${term.coeff}` !== '0');\n\t}\n\n\tplus(v: string | uVector | uxVector | uxVectorExpression): uxVectorExpression {\n\t\tif (typeof v === 'string' || v instanceof uVector || v instanceof uxVector) {\n\t\t\treturn new uxVectorExpression(...this.vectors, v);\n\t\t}\n\t\treturn new uxVectorExpression(...this.vectors, ...v.vectors);\n\t}\n\tnegative(): uxVectorExpression {\n\t\treturn new uxVectorExpression(...this.vectors.map((vector) => vector.negative()));\n\t}\n\tminus(v: string | uVector | uxVector | uVectorExpression): uxVectorExpression {\n\t\tif (typeof v === 'string') {\n\t\t\tv = new uVector(v);\n\t\t}\n\t\tif (v instanceof uVector || v instanceof uxVector) {\n\t\t\treturn new uxVectorExpression(...this.vectors, v.negative());\n\t\t}\n\t\treturn new uxVectorExpression(...this.vectors, ...v.negative().vectors);\n\t}\n\t/** scalar multiplication */\n\tmultiply(k: number | Fraction) {\n\t\treturn new uxVectorExpression(...this.vectors.map((vector) => vector.multiply(k)));\n\t}\n\t/** scalar (dot) product */\n\tdot(v: string | uVector | uxVector | uVectorExpression): Expression {\n\t\tif (!(v instanceof uxVectorExpression)) {\n\t\t\tconst terms: Term[] = [];\n\t\t\tthis.vectors.forEach((vector, i) => {\n\t\t\t\tif (vector instanceof uxVector) {\n\t\t\t\t\tterms.push(vector.dot(<string | uVector | uxVector>v));\n\t\t\t\t} else if (v instanceof uxVector) {\n\t\t\t\t\tterms.push(v.dot(vector));\n\t\t\t\t} else {\n\t\t\t\t\tterms.push(vector.dot(<string | uVector>v));\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn new Expression(...terms);\n\t\t}\n\t\treturn v.vectors.reduce((exp, term) => exp.plus(this.dot(term)), new Expression(0));\n\t}\n\t/** vector (cross) product */\n\tcross(v: string | uVector | uxVector | uVectorExpression | uxVectorExpression): uxVectorExpression {\n\t\tif (!(v instanceof uVectorExpression) && !(v instanceof uxVectorExpression)) {\n\t\t\tconst vectors: (uVector | uxVector)[] = [];\n\t\t\tthis.vectors.forEach((vector, i) => {\n\t\t\t\tif (vector instanceof uxVector) {\n\t\t\t\t\tvectors.push(vector.cross(<string | uVector | uxVector>v));\n\t\t\t\t} else if (v instanceof uxVector) {\n\t\t\t\t\tvectors.push(v.cross(vector));\n\t\t\t\t} else {\n\t\t\t\t\tvectors.push(vector.cross(<string | uVector>v));\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn new uxVectorExpression(...vectors);\n\t\t}\n\t\treturn (<uxVector[]>v.vectors).reduce(\n\t\t\t(exp, term) => exp.plus(this.cross(term)),\n\t\t\tnew uxVectorExpression(new uxVector('a', 0)),\n\t\t);\n\t}\n\n\t/**\n\t * `toString` method\n\t *\n\t * @returns the LaTeX string representation of the sum of all the vectors\n\t */\n\ttoString(): string {\n\t\tif (this.vectors.length === 0) {\n\t\t\treturn '\\\\mathbf{0}';\n\t\t}\n\t\tlet outputString = '';\n\t\tthis.vectors.forEach((vector, i) => {\n\t\t\tif (i !== 0) {\n\t\t\t\toutputString += `${vector.coeff}`[0] === '-' ? ' ' : ' + ';\n\t\t\t}\n\t\t\toutputString += vector.toString();\n\t\t});\n\t\treturn outputString;\n\t}\n\n\tclone(): uxVectorExpression {\n\t\treturn new uxVectorExpression(...this.vectors.map((vector) => vector.clone()));\n\t}\n}\n\nfunction combineLikeVectors(vectors: uVector[]): uVector[] {\n\tconst variableArray: string[] = [],\n\t\tnewTerms: uVector[] = [];\n\tvectors.forEach((term) => {\n\t\tconst variableIndex = variableArray.indexOf(term.variableString);\n\t\tif (variableIndex === -1) {\n\t\t\t// new term type\n\t\t\tvariableArray.push(term.variableString);\n\t\t\tnewTerms.push(term.clone());\n\t\t} else {\n\t\t\t// combine like terms\n\t\t\tnewTerms[variableIndex] = new uVector(term.vector, newTerms[variableIndex].coeff.plus(term.coeff));\n\t\t}\n\t});\n\treturn newTerms;\n}\n\nfunction combineLikeXVectors(vectors: (uVector | uxVector)[]): (uxVector | uVector)[] {\n\tconst variableArray: string[] = [],\n\t\tnewTerms: (uVector | uxVector)[] = [];\n\tvectors.forEach((term) => {\n\t\tconst variableIndex = variableArray.indexOf(term.vector);\n\t\tif (variableIndex === -1) {\n\t\t\t// new term type\n\t\t\tvariableArray.push(term.vector);\n\t\t\tnewTerms.push(term.clone());\n\t\t} else {\n\t\t\t// combine like terms if applicable\n\t\t\tconst coeff1 = newTerms[variableIndex].coeff;\n\t\t\tconst coeff2 = term.coeff;\n\t\t\tlet newCoeff: Term | Fraction | Expression;\n\t\t\tif (coeff1 instanceof Fraction && coeff2 instanceof Fraction) {\n\t\t\t\tnewCoeff = coeff2.plus(coeff1);\n\t\t\t} else {\n\t\t\t\tnewCoeff = new Expression(coeff1, coeff2);\n\t\t\t}\n\t\t\tif (!(newCoeff instanceof Expression)) {\n\t\t\t\tnewTerms[variableIndex] = new uxVector(term.vector, newCoeff);\n\t\t\t} else {\n\t\t\t\tnewTerms.push(term.clone());\n\t\t\t}\n\t\t}\n\t});\n\treturn newTerms;\n}\n","export { getRandomInt, getRandomInts } from './getRandomInt';\nexport { getRandomVec, getNiceVec, getRandomPerps, getRandomPerp, getRandomLine } from './getRandomVec';\nexport { getRandomFrac } from './getRandomFrac';\nexport { shuffle } from './shuffle';\nexport { sample, sampleN } from './sample';\nexport { heads } from './coinFlip';\nexport { getRandomAngle } from './getRandomAngle';\n","/**\n * Generates a random integer between `min` and `max` (inclusive)\n *\n * @param min defaults to -9\n * @param max defaults to 9\n * @param options `{avoid: []}` array of numbers to be avoided\n *\n */\nexport function getRandomInt(min: number = -9, max: number = 9, options?: { avoid?: number | number[] }): number {\n\tmin = Math.ceil(min); // in case min is non-integer\n\tmax = Math.floor(max); // in case max is non-integer\n\t[min, max] = [Math.min(min, max), Math.max(min, max)];\n\tlet randomInt = Math.floor(Math.random() * (max - min + 1)) + min;\n\tlet { avoid } = {\n\t\tavoid: [],\n\t\t...options,\n\t};\n\tif (typeof avoid === 'number') {\n\t\tavoid = [avoid];\n\t}\n\tif (avoid.length !== 0) {\n\t\tlet avoidArray = avoid.filter((num) => num >= min && num <= max);\n\t\tavoidArray = avoidArray.filter((num, i) => avoidArray.indexOf(num) === i);\n\t\tif (avoidArray.length >= max - min + 1) {\n\t\t\tthrow new Error(`no integer exists between ${min} and ${max} that avoids ${avoid}`);\n\t\t}\n\t\twhile (avoidArray.includes(randomInt)) {\n\t\t\trandomInt = Math.floor(Math.random() * (max - min + 1)) + min;\n\t\t}\n\t}\n\treturn randomInt;\n}\n\n/**\n * Generates a random integer between `min` and `max` (inclusive)\n *\n * @param n number of integers to be generated\n * @param min defaults to -9\n * @param max defaults to 9\n * @param options `{avoid: [], repeated: false}`\n *\n */\nexport function getRandomInts(\n\tn: number,\n\tmin: number = -9,\n\tmax: number = 9,\n\toptions?: { avoid?: number[]; repeated?: boolean },\n): number[] {\n\tconst { avoid, repeated } = {\n\t\tavoid: [],\n\t\trepeated: false,\n\t\t...options,\n\t};\n\tconst ints: number[] = [];\n\twhile (ints.length < n) {\n\t\tconst randomInt = getRandomInt(min, max, { avoid });\n\t\tints.push(randomInt);\n\t\tif (!repeated) {\n\t\t\tavoid.push(randomInt);\n\t\t}\n\t}\n\treturn ints;\n}\n","import { getRandomInt } from './getRandomInt';\nimport { Vector, Line } from '../vectors/index';\nimport { shuffle } from './shuffle';\nimport { heads } from './coinFlip';\nimport { factorPairs } from '../misc/index';\nimport { Fraction } from '../core';\n\n/**\n * Generates a random 3D Vector with\n * integer coordinates between `min` and `max` (inclusive)\n *\n * @param options defaults  to `{min: -5, max: 5, simplify: false, nonzero: true, avoid: [], avoidParallel: false, avoidPerp: false, avoidLine: }`\n * setting nonzero to true will ensure a non-zero Vector\n * setting simplify to true will return a 'simplified' Vector (such that gcd(x,y,z)=1)\n *\n */\nexport function getRandomVec(options?: randomVecOptions): Vector {\n\tconst { nonzero, min, max, simplify, avoid, avoidParallel, avoidPerp, avoidLine } = {\n\t\tnonzero: true,\n\t\tsimplify: false,\n\t\tmin: -5,\n\t\tmax: 5,\n\t\tavoid: [],\n\t\tavoidParallel: false,\n\t\tavoidPerp: false,\n\t\t...options,\n\t};\n\tconst x = getRandomInt(min, max);\n\tconst y = getRandomInt(min, max);\n\tconst z = getRandomInt(min, max);\n\tif (nonzero && x === 0 && y === 0 && z === 0) {\n\t\treturn getRandomVec(options);\n\t}\n\tconst vec = new Vector(x, y, z, { stretchable: simplify });\n\t// check things to avoid\n\tif (avoidLine !== undefined && avoidLine.contains(vec)) {\n\t\treturn getRandomVec(options);\n\t}\n\tif (avoidParallel && avoidPerp) {\n\t\tif (avoid.some((v) => v.isParallelTo(vec) || v.isPerpendicularTo(vec))) {\n\t\t\treturn getRandomVec(options);\n\t\t}\n\t} else if (avoidParallel) {\n\t\tif (avoid.some((v) => v.isParallelTo(vec))) {\n\t\t\treturn getRandomVec(options);\n\t\t}\n\t} else if (avoidPerp) {\n\t\tif (avoid.some((v) => v.isPerpendicularTo(vec))) {\n\t\t\treturn getRandomVec(options);\n\t\t}\n\t} else {\n\t\tif (avoid.some((v) => v.isEqualTo(vec))) {\n\t\t\treturn getRandomVec(options);\n\t\t}\n\t}\n\treturn new Vector(x, y, z, { stretchable: simplify });\n}\n\n/**\n * options default to {min: -5, max: 5, lambda: '\\\\lambda'}\n */\nexport function getRandomLine(options?: { min?: number; max?: number; lambda?: string }) {\n\tconst a = getRandomVec({ ...options, nonzero: false });\n\tconst d = getRandomVec({ ...options, simplify: true });\n\treturn new Line(a, d, options);\n}\n\n/**\n * Generates a random 3D Vector with\n * integral magnitude\n *\n * (1,2,2 | 3) * 2\n * (0,3,4 | 5) * 2\n * (2,3,6 | 7)\n * (1,4,8 | 9)\n * (2,6,9 | 11)\n * (0,5,12 | 13)\n *\n * @param options defaults to {multiplesAllowed: false, max: 13}, magnitudes from 3,5,7,9,11,13 supported\n */\nexport function getNiceVec(options?: { multiplesAllowed?: boolean; max?: number }): Vector {\n\tconst { multiplesAllowed, max } = {\n\t\tmultiplesAllowed: false,\n\t\tmax: 13,\n\t\t...options,\n\t};\n\tconst pythagoreanQuads = [\n\t\t[1, 2, 2, 3],\n\t\t[0, 3, 4, 5],\n\t\t[2, 3, 6, 7],\n\t\t[1, 4, 8, 9],\n\t\t[2, 6, 9, 11],\n\t\t[0, 5, 12, 13],\n\t];\n\tconst choices = pythagoreanQuads.filter((arr) => arr[3] <= max);\n\tif (choices.length === 0) {\n\t\tthrow new Error(`max ${max} results in no choices`);\n\t}\n\tlet choice = choices[getRandomInt(0, choices.length - 1)];\n\tif (multiplesAllowed && choice[3] * 2 <= max && heads()) {\n\t\tchoice = choice.map((e) => e * 2);\n\t}\n\tconst components = choice.slice(0, 3);\n\tshuffle(components);\n\tconst [x, y, z] = components.map((e) => (heads() ? e * -1 : e));\n\treturn new Vector(x, y, z);\n}\n\n/**\n * get two random vectors that are perpendicular to each other\n *\n * this algorithm makes x1 and y2 non-zero\n *\n * options default to `{ min: -5, max: 5, simplify: true}`\n *\n * warning: max should be positive or loop logic may fail\n */\nexport function getRandomPerps(options?: { min?: number; max?: number; simplify?: boolean }): [Vector, Vector] {\n\tconst { min, max, simplify } = {\n\t\tmin: -5,\n\t\tmax: 5,\n\t\tsimplify: true,\n\t\t...options,\n\t};\n\tlet x1 = getRandomInt(min, max, { avoid: [0] });\n\tlet x2 = getRandomInt(min, max);\n\tlet y1 = getRandomInt(min, max);\n\tlet y2 = getRandomInt(min, max, { avoid: [0] });\n\tlet dot = x1 * x2 + y1 * y2;\n\tif (dot === 0) {\n\t\tconst z1 = getRandomInt(min, max, { avoid: [0] });\n\t\tconst z2 = 0;\n\t\tconst a = new Vector(x1, y1, z1, { stretchable: simplify });\n\t\tconst b = new Vector(x2, y2, z2, { stretchable: simplify });\n\t\treturn [a, b];\n\t}\n\tlet factors = factorPairs(Math.abs(dot));\n\tlet eligibleFactors = factors.filter((e) => e[0] < max && e[1] < max);\n\twhile (eligibleFactors.length === 0) {\n\t\t// ~ 27.2% using default of -5 to 5\n\t\tx1 = getRandomInt(min, max, { avoid: [0] });\n\t\tx2 = getRandomInt(min, max);\n\t\ty1 = getRandomInt(min, max);\n\t\ty2 = getRandomInt(min, max, { avoid: [0] });\n\t\tdot = x1 * x2 + y1 * y2;\n\t\tif (dot === 0) {\n\t\t\tconst z1 = heads() ? 0 : getRandomInt(min, max);\n\t\t\tconst z2 = z1 === 0 ? getRandomInt(min, max) : 0;\n\t\t\tconst a = new Vector(x1, y1, z1, { stretchable: simplify });\n\t\t\tconst b = new Vector(x2, y2, z2, { stretchable: simplify });\n\t\t\treturn [a, b];\n\t\t}\n\t\tfactors = factorPairs(Math.abs(dot));\n\t\teligibleFactors = factors.filter((e) => e[0] < max && e[1] < max);\n\t}\n\tconst factorPair = eligibleFactors[getRandomInt(0, eligibleFactors.length - 1)];\n\tif (heads()) {\n\t\tfactorPair.reverse();\n\t}\n\tlet [z1, z2] = factorPair;\n\tif (dot < 0) {\n\t\t// need positive z1*z2\n\t\tif (heads()) {\n\t\t\tz1 = -z1;\n\t\t\tz2 = -z2;\n\t\t}\n\t} else {\n\t\t// need negative z1*z2\n\t\tif (heads()) {\n\t\t\tz1 = -z1;\n\t\t} else {\n\t\t\tz2 = -z2;\n\t\t}\n\t}\n\tconst a = new Vector(x1, y1, z1, { stretchable: simplify });\n\tconst b = new Vector(x2, y2, z2, { stretchable: simplify });\n\treturn [a, b];\n}\n\n/**\n * get a random vector that is perpendicular to given vector\n *\n * options default to `{ min: -5, max: 5, simplify: true, avoid: []}`\n *\n * @param options avoid is an array of vectors that the return value cannot be parallel to\n *\n * warning: max should be positive or loop logic may fail\n */\nexport function getRandomPerp(\n\tv: Vector,\n\toptions?: { min?: number; max?: number; simplify?: boolean; avoid?: Vector[] },\n): Vector {\n\tconst { min, max, simplify, avoid } = {\n\t\tmin: -5,\n\t\tmax: 5,\n\t\tsimplify: true,\n\t\tavoid: [],\n\t\t...options,\n\t};\n\tif (!v.z.isEqualTo(0)) {\n\t\tconst x = getRandomInt(min, max, { avoid: [0] });\n\t\tconst y = getRandomInt(min, max);\n\t\tconst dot = v.x.times(x).plus(v.y.times(y));\n\t\tconst vec = new Vector(x, y, dot.negative().divide(v.z), { stretchable: simplify });\n\t\tif (maxComponent(vec).isGreaterThan(max)) {\n\t\t\treturn getRandomPerp(v, options);\n\t\t}\n\t\tif (avoid.length > 0 && avoid.some((e) => e.isParallelTo(vec))) {\n\t\t\treturn getRandomPerp(v, options);\n\t\t}\n\t\treturn vec;\n\t} else if (!v.y.isEqualTo(0)) {\n\t\tconst x = getRandomInt(min, max, { avoid: [0] });\n\t\tconst z = getRandomInt(min, max);\n\t\tconst dot = v.x.times(x).plus(v.z.times(z));\n\t\tconst vec = new Vector(x, dot.negative().divide(v.y), z, { stretchable: simplify });\n\t\tif (maxComponent(vec).isGreaterThan(max)) {\n\t\t\treturn getRandomPerp(v, options);\n\t\t}\n\t\tif (avoid.length > 0 && avoid.some((e) => e.isParallelTo(vec))) {\n\t\t\treturn getRandomPerp(v, options);\n\t\t}\n\t\treturn vec;\n\t} else {\n\t\tif (v.x.isEqualTo(0)) {\n\t\t\tthrow new Error('cannot get perpendicular to zero vector');\n\t\t}\n\t\tconst y = getRandomInt(min, max, { avoid: [0] });\n\t\tconst z = getRandomInt(min, max);\n\t\tconst dot = v.y.times(y).plus(v.z.times(z));\n\t\tconst vec = new Vector(dot.negative().divide(v.x), y, z, { stretchable: simplify });\n\t\tif (maxComponent(vec).isGreaterThan(max)) {\n\t\t\treturn getRandomPerp(v, options);\n\t\t}\n\t\tif (avoid.length > 0 && avoid.some((e) => e.isParallelTo(vec))) {\n\t\t\treturn getRandomPerp(v, options);\n\t\t}\n\t\treturn vec;\n\t}\n}\n\n/**\n * options for `getRandomInt`\n *\n * of the form `{ avoid: [] }`;\n */\ninterface randomVecOptions {\n\t/** whether the vector must be nonzero */\n\tnonzero?: boolean;\n\t/** whether the vector is \"simplified\" */\n\tsimplify?: boolean;\n\t/** min */\n\tmin?: number;\n\t/** max */\n\tmax?: number;\n\t/** vectors to avoid */\n\tavoid?: Vector[];\n\t/** avoidParallel */\n\tavoidParallel?: boolean;\n\t/** avoidPerp */\n\tavoidPerp?: boolean;\n\t/** avoidPerp */\n\tavoidLine?: Line;\n}\n\nfunction maxComponent(v: Vector): Fraction {\n\treturn v.x.abs().isAtLeast(v.y.abs())\n\t\t? v.x.abs().isAtLeast(v.z.abs())\n\t\t\t? v.x.abs()\n\t\t\t: v.z.abs()\n\t\t: v.y.abs().isAtLeast(v.z.abs())\n\t\t? v.y.abs()\n\t\t: v.z.abs();\n}\n","/**\n * shuffles the array\n *\n * WARNING: mutates current array\n */\nexport function shuffle<Type>(array: Array<Type>): Array<Type> {\n\tlet currentIndex = array.length,\n\t\trandomIndex;\n\t// While there remain elements to shuffle.\n\twhile (currentIndex != 0) {\n\t\t// Pick a remaining element.\n\t\trandomIndex = Math.floor(Math.random() * currentIndex);\n\t\tcurrentIndex--;\n\t\t// And swap it with the current element.\n\t\t[array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];\n\t}\n\n\treturn array;\n}\n","export function heads(): boolean {\n\treturn Math.random() < 0.5;\n}\n","export { factorPairs } from './factors';\nexport { JSONParse } from './JSONParse';\nexport { UnsimplifiedExpression, BracketedTerm } from './unsimplifiedExpression';\n","/**\n * returns all factor pairs of a positive integer\n */\nexport function factorPairs(n: number): [number, number][] {\n\tif (n <= 0 || !Number.isInteger(n)) {\n\t\tthrow new Error(`factorPairs function only valid for positive integers. ${n} received`);\n\t}\n\tlet result: [number, number][] = [[1, n]];\n\tfor (let i = 2; i <= Math.floor(Math.sqrt(n)); i++) {\n\t\tif (n % i === 0) {\n\t\t\tresult.push([i, n / i]);\n\t\t}\n\t}\n\treturn result;\n}\n","import { Fraction, Term, Expression, VariableTerm, SquareRoot, Imaginary, Polynomial, MathSymbol } from '../core/index';\nimport { Vector } from '../vectors/index';\nimport { Laurent } from '../calculus';\n\n/**\n * parse JSON, returning a Mathlify class instance (Fraction/Term/Expression/Vector)\n *\n * for primitive types, return itself:\n */\nexport function JSONParse(\n\tjsonString: string,\n):\n\t| string\n\t| number\n\t| boolean\n\t| Fraction\n\t| Term\n\t| Expression\n\t| Polynomial\n\t| Vector\n\t| Laurent\n\t| (string | number | boolean | Fraction | Term | Expression | Vector)[] {\n\tconst jsonObject = JSON.parse(jsonString);\n\treturn Array.isArray(jsonObject) ? parseArray(jsonObject) : parseSingleItem(jsonObject);\n}\n\nfunction parseArray(arr: any[]): any[] {\n\treturn arr.map((e) => {\n\t\treturn Array.isArray(e) ? parseArray(e) : parseSingleItem(e);\n\t});\n}\n\nfunction parseSingleItem(\n\titem: any,\n): string | number | boolean | Fraction | Term | Expression | Vector | Polynomial | Laurent {\n\tif (typeof item === 'string' || typeof item === 'number' || typeof item === 'boolean') {\n\t\treturn item;\n\t}\n\tif ('type' in item && 'args' in item && item.type in classes) {\n\t\tconst type = item.type as 'fraction' | 'term' | 'expression' | 'vector' | 'polynomial' | 'laurent';\n\t\tconst args = item.args as any[];\n\t\tconst parsedArgs = parseArray(args);\n\t\treturn new (classes[type] as any)(...parsedArgs);\n\t} else {\n\t\treturn JSON.stringify(item);\n\t}\n}\n\nconst classes = {\n\tfraction: Fraction,\n\tterm: Term,\n\texpression: Expression,\n\tvector: Vector,\n\tvariable: VariableTerm,\n\timaginary: Imaginary,\n\tsquareRoot: SquareRoot,\n\tpolynomial: Polynomial,\n\tlaurent: Laurent,\n\tmathSymbol: MathSymbol,\n};\n","export { PowerFn, SinFn, CosFn, LnFn, ExpFn, RationalFn, Laurent } from './classes/';\nexport { Parametric } from './parametricClass';\nexport { rationalToPowerFn } from './rationalToPower';\n\nexport { integrate, definiteIntegral } from './integrate';\n\nexport { simpsons } from './simpsons';\nexport { finiteDifference } from './finiteDifference';\n\nexport { de } from './differential_equations';\n","export { PowerFn, SinFn, CosFn, ExpFn, LnFn, RationalFn } from './classes';\nexport { Laurent } from './laurent';\n","import { Fraction, Polynomial, VariableTerm, numberToFraction, BasicTerm, SquareRoot } from '../../core/index';\nimport { Rational } from '../../algebra';\nimport { sin, cos, Angle } from '../../trigo';\n\n/**\n * function representing k ( f(x) )^n\n */\nexport class PowerFn {\n\t/** coefficient k in k( f(x) )^n */\n\tcoeff: Fraction;\n\t/** \"inner\" function f(x) */\n\tfx: Polynomial | SinFn | CosFn | LnFn; //TODO: Exp|Ln|Sin|Cos\n\t/** Exponent */\n\tn: Fraction;\n\t/**\n\t * Creates a new PowerFn class\n\t * @param options defaults to `{ fx: \"x\", coeff: 1 }`\n\t */\n\tconstructor(\n\t\tn: number | Fraction,\n\t\toptions?: {\n\t\t\tfx?: string | VariableTerm | Polynomial | CosFn | SinFn | LnFn;\n\t\t\tcoeff?: number | Fraction;\n\t\t},\n\t) {\n\t\tlet { fx, coeff } = {\n\t\t\tfx: 'x',\n\t\t\tcoeff: 1,\n\t\t\t...options,\n\t\t};\n\t\tif (typeof fx === 'string') {\n\t\t\tfx = new Polynomial([1, 0], { variable: fx });\n\t\t} else if (fx instanceof VariableTerm) {\n\t\t\tfx = new Polynomial([fx.coeff, 0], { variable: fx.variable });\n\t\t}\n\t\tthis.fx = fx;\n\t\tthis.coeff = numberToFraction(coeff);\n\t\tthis.n = numberToFraction(n);\n\t}\n\n\t/**\n\t * differentiates this expression using chain rule\n\t * @return `{ string, power, fPrime }` where string is an attempted string representation of the derivative,\n\t * power is the PowerFn n ( f(x) )^(n-1) and fPrime is f'(x)\n\t */\n\tdifferentiate(): { string: string; power: PowerFn; fPrime: Polynomial | CosFn | SinFn | RationalFn } {\n\t\tconst fPrime = this.fx.differentiate();\n\t\tconst fPrimeTwo = this.fx.differentiate();\n\t\tlet coeff =\n\t\t\tfPrime instanceof Polynomial || fPrime instanceof RationalFn\n\t\t\t\t? this.coeff.times(this.n)\n\t\t\t\t: this.coeff.times(this.n).times(fPrime.coeff);\n\t\tif (!(fPrimeTwo instanceof Polynomial || fPrimeTwo instanceof RationalFn)) {\n\t\t\tfPrimeTwo.coeff = new Fraction(1);\n\t\t}\n\t\tlet power = new PowerFn(this.n.minus(1), { fx: this.fx, coeff: this.coeff.times(this.n) });\n\t\tif (fPrime instanceof Polynomial && fPrime.degree === 0) {\n\t\t\tcoeff = coeff.times(fPrime.coeffs[0]);\n\t\t\tpower = power.times(fPrime.coeffs[0]);\n\t\t}\n\t\tconst term = `${fPrimeTwo} ${new PowerFn(this.n.minus(1), { fx: this.fx })}`;\n\t\tconst string = `${new BasicTerm(coeff, term)}`;\n\t\treturn { power, fPrime, string };\n\t}\n\n\t/**\n\t * integration of this expression, using the f'(x) ( f(x) )^n formula\n\t * for non-linear fx, we assume f'(x) is present\n\t */\n\tintegrate(options?: { modulus?: boolean }): PowerFn | LnFn {\n\t\tconst { modulus } = {\n\t\t\tmodulus: true,\n\t\t\t...options,\n\t\t};\n\t\tconst divisor = this.fx instanceof Polynomial && this.fx.degree === 1 ? this.fx.coeffs[1] : 1;\n\t\tif (this.n.isEqualTo(-1)) {\n\t\t\tif (!(this.fx instanceof Polynomial)) {\n\t\t\t\t// TODO: other forms\n\t\t\t\tthrow new Error(`Only polynomials of degree 1 supported for inner integrand ${this.fx}`);\n\t\t\t}\n\t\t\treturn new LnFn({ fx: this.fx, coeff: this.coeff.divide(divisor), modulus });\n\t\t} else {\n\t\t\treturn new PowerFn(this.n.plus(1), { fx: this.fx, coeff: this.coeff.divide(this.n.plus(1)).divide(divisor) });\n\t\t}\n\t}\n\n\ttimes(x: number | Fraction): PowerFn {\n\t\treturn new PowerFn(this.n, { fx: this.fx, coeff: this.coeff.times(x) });\n\t}\n\n\tdivide(x: number | Fraction): PowerFn {\n\t\treturn new PowerFn(this.n, { fx: this.fx, coeff: this.coeff.divide(x) });\n\t}\n\n\tremoveCoeff(): PowerFn {\n\t\treturn new PowerFn(this.n, { fx: this.fx });\n\t}\n\n\t/** sub in: only works for polynomial inner function\n\t * and integral n at the moment\n\t * also works for square roots if the value substituted in can be square-rooted\n\t */\n\tsubIn(x: number | Fraction): Fraction {\n\t\tif (!(this.fx instanceof Polynomial)) {\n\t\t\tthrow new Error(`PowerFn.subIn() only works for polynomial inner function`);\n\t\t}\n\t\tif (this.n.isInteger()) {\n\t\t\tif (this.n.isGreaterThan(0)) {\n\t\t\t\treturn this.coeff.times(this.fx.subIn(x).pow(this.n.num));\n\t\t\t} else {\n\t\t\t\treturn this.coeff.divide(this.fx.subIn(x).pow(this.n.abs().num));\n\t\t\t}\n\t\t}\n\t\tif (this.n.den === 2) {\n\t\t\tconst sqrtX = new SquareRoot(this.fx.subIn(x));\n\t\t\tif (sqrtX.isRational()) {\n\t\t\t\tif (this.n.isGreaterThan(0)) {\n\t\t\t\t\treturn this.coeff.times(sqrtX.coeff.pow(this.n.num));\n\t\t\t\t} else {\n\t\t\t\t\treturn this.coeff.divide(sqrtX.coeff.pow(this.n.abs().num));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthrow new Error(`PowerFn.subIn() only works for polynomial inner function and integral n at the moment `);\n\t}\n\n\t/**\n\t * only works for polynomial inner function at the moment\n\t */\n\tsubInNumber(x: number): number {\n\t\tif (!(this.fx instanceof Polynomial)) {\n\t\t\tthrow new Error(`PowerFn.subIn() only works for polynomial inner function`);\n\t\t}\n\t\treturn Math.pow(this.fx.subInNumber(x), this.n.valueOf()) * this.coeff.valueOf();\n\t}\n\n\t/**\n\t * if n = k/2, then substituting a value in will return a surd.\n\t * this method accomplishes that\n\t */\n\tsubInToGetSurd(x: number | Fraction): SquareRoot {\n\t\tif (this.n.den !== 2) {\n\t\t\tthrow new Error(`subInToGetSurd method only works if denominator of n is 2. ${this.n} received.`);\n\t\t}\n\t\tif (!(this.fx instanceof Polynomial)) {\n\t\t\tthrow new Error(`PowerFn.subIn() only works for polynomial inner function`);\n\t\t}\n\t\tconst sqrtX = new SquareRoot(this.fx.subIn(x));\n\t\treturn sqrtX.pow(this.n.num).times(this.coeff);\n\t}\n\n\t/**\n\t * definite integral: only works for polynomial inner function\n\t * and integral n \\neq -1 at the moment\n\t */\n\tdefiniteIntegral(lower: number | Fraction, upper: number | Fraction): Fraction {\n\t\tif (this.n.isEqualTo(-1)) {\n\t\t\tthrow new Error(`logarithmic integral not supported at the moment`);\n\t\t}\n\t\tconst integral = this.integrate() as PowerFn;\n\t\treturn integral.subIn(upper).minus(integral.subIn(lower));\n\t}\n\n\t/**\n\t * `toString` method\n\t *\n\t * @returns the LaTeX string representation of the sum of all the terms\n\t */\n\ttoString(): string {\n\t\tlet fxN: string;\n\t\tif (this.n.isEqualTo(0)) {\n\t\t\tfxN = '';\n\t\t} else if (this.n.isEqualTo(1)) {\n\t\t\tfxN = `${this.fx}`;\n\t\t} else {\n\t\t\tconst nString = `${this.n}`.length === 1 ? `${this.n}` : `{${this.n}}`;\n\t\t\tif (this.fx instanceof CosFn || this.fx instanceof SinFn) {\n\t\t\t\tconst cos = this.fx instanceof CosFn ? '\\\\cos' : '\\\\sin';\n\t\t\t\tconst fxString = this.fx.fx.terms.length === 1 ? `${this.fx.fx}` : `\\\\left( ${this.fx.fx} \\\\right)`;\n\t\t\t\tfxN = `${cos}^${nString} ${fxString}`;\n\t\t\t} else {\n\t\t\t\tfxN = `${this.fx}`.length === 1 ? `${this.fx}^${nString}` : `\\\\left( ${this.fx} \\\\right)^${nString}`;\n\t\t\t}\n\t\t}\n\t\treturn `${new BasicTerm(this.coeff, fxN)}`;\n\t}\n}\n\n/**\n * function representing k sin ( f(x) )\n */\nexport class SinFn {\n\t/** coefficient k in k sin ( f(x) ) */\n\tcoeff: Fraction;\n\t/** \"inner\" function f(x) */\n\tfx: Polynomial; //TODO: Exp|Ln|Sin|Cos\n\t/**\n\t * Creates a new SinFn class\n\t * @param options defaults to `{ fx: \"x\", coeff: 1 }`\n\t */\n\tconstructor(options?: { fx?: string | VariableTerm | Polynomial; coeff?: number | Fraction }) {\n\t\tlet { fx, coeff } = {\n\t\t\tfx: 'x',\n\t\t\tcoeff: 1,\n\t\t\t...options,\n\t\t};\n\t\tif (typeof fx === 'string') {\n\t\t\tfx = new Polynomial([1, 0], { variable: fx });\n\t\t} else if (fx instanceof VariableTerm) {\n\t\t\tfx = new Polynomial([fx.coeff, 0], { variable: fx.variable });\n\t\t}\n\t\tthis.fx = fx;\n\t\tthis.coeff = numberToFraction(coeff);\n\t}\n\n\t/** differentiates this expression */\n\tdifferentiate(): CosFn {\n\t\t//TODO: full chain rule version\n\t\tif (this.fx.coeffs.length === 2) {\n\t\t\t// linear fx\n\t\t\treturn new CosFn({ fx: this.fx, coeff: this.coeff.times(this.fx.coeffs[1]) });\n\t\t}\n\t\treturn new CosFn({ fx: this.fx, coeff: this.coeff });\n\t}\n\n\t/** integrates this expression */\n\tintegrate(): CosFn {\n\t\tif (this.fx.coeffs.length === 2) {\n\t\t\t// linear fx\n\t\t\treturn new CosFn({ fx: this.fx, coeff: this.coeff.negative().divide(this.fx.coeffs[1]) });\n\t\t}\n\t\treturn new CosFn({ fx: this.fx, coeff: this.coeff.negative() });\n\t}\n\n\ttimes(x: number | Fraction): SinFn {\n\t\treturn new SinFn({ fx: this.fx, coeff: this.coeff.times(x) });\n\t}\n\tremoveCoeff(): SinFn {\n\t\treturn new SinFn({ fx: this.fx });\n\t}\n\n\t/**\n\t * @returns special ratios\n\t *\n\t * only works for sin nx at the moment\n\t */\n\tsubIn(x: Angle | number | Fraction): SquareRoot {\n\t\tif (!(x instanceof Angle)) {\n\t\t\tx = new Angle(x);\n\t\t}\n\t\tif (this.fx.coeffs.length === 2 && this.fx.coeffs[0].isEqualTo(0)) {\n\t\t\tx = x.times(this.fx.coeffs[1]);\n\t\t} else {\n\t\t\tthrow new Error(`only works for sin(nx) at the moment ${this}`);\n\t\t}\n\t\treturn sin(x).times(this.coeff);\n\t}\n\n\t/**\n\t * `toString` method\n\t *\n\t * @returns the LaTeX string representation of the sum of all the terms\n\t */\n\ttoString(): string {\n\t\tlet fxString: string = '';\n\t\tif (this.fx instanceof Polynomial) {\n\t\t\tfxString = this.fx.terms.length === 1 ? `${this.fx}` : `\\\\left( ${this.fx} \\\\right)`;\n\t\t}\n\t\treturn `${new BasicTerm(this.coeff, `\\\\sin ${fxString}`)}`;\n\t}\n}\n\n/**\n * function representing k cos ( f(x) )\n */\nexport class CosFn {\n\t/** coefficient k in k cos ( f(x) ) */\n\tcoeff: Fraction;\n\t/** \"inner\" function f(x) */\n\tfx: Polynomial; //TODO: Exp|Ln|Sin|Cos\n\t/**\n\t * Creates a new CosFn class\n\t * @param options defaults to `{ fx: \"x\", coeff: 1 }`\n\t */\n\tconstructor(options?: { fx?: string | VariableTerm | Polynomial; coeff?: number | Fraction }) {\n\t\tlet { fx, coeff } = {\n\t\t\tfx: 'x',\n\t\t\tcoeff: 1,\n\t\t\t...options,\n\t\t};\n\t\tif (typeof fx === 'string') {\n\t\t\tfx = new Polynomial([1, 0], { variable: fx });\n\t\t} else if (fx instanceof VariableTerm) {\n\t\t\tfx = new Polynomial([fx.coeff, 0], { variable: fx.variable });\n\t\t}\n\t\tthis.fx = fx;\n\t\tthis.coeff = numberToFraction(coeff);\n\t}\n\n\t/** differentiates this expression */\n\tdifferentiate(): SinFn {\n\t\t//TODO: full chain rule version\n\t\tif (this.fx.coeffs.length === 2) {\n\t\t\t// linear fx\n\t\t\treturn new SinFn({ fx: this.fx, coeff: this.coeff.negative().times(this.fx.coeffs[1]) });\n\t\t}\n\t\treturn new SinFn({ fx: this.fx, coeff: this.coeff.negative() });\n\t}\n\n\ttimes(x: number | Fraction): CosFn {\n\t\treturn new CosFn({ fx: this.fx, coeff: this.coeff.times(x) });\n\t}\n\n\t/** integrates this expression */\n\tintegrate(): SinFn {\n\t\tif (this.fx.coeffs.length === 2) {\n\t\t\t// linear fx\n\t\t\treturn new SinFn({ fx: this.fx, coeff: this.coeff.divide(this.fx.coeffs[1]) });\n\t\t}\n\t\treturn new SinFn({ fx: this.fx, coeff: this.coeff });\n\t}\n\n\tremoveCoeff(): CosFn {\n\t\treturn new CosFn({ fx: this.fx });\n\t}\n\n\t/**\n\t * @returns special ratios\n\t *\n\t * only works for sin nx at the moment\n\t */\n\tsubIn(x: Angle | number | Fraction): SquareRoot {\n\t\tif (!(x instanceof Angle)) {\n\t\t\tx = new Angle(x);\n\t\t}\n\t\tif (this.fx.coeffs.length === 2 && this.fx.coeffs[0].isEqualTo(0)) {\n\t\t\tx = x.times(this.fx.coeffs[1]);\n\t\t} else {\n\t\t\tthrow new Error(`only works for sin(nx) at the moment ${this}`);\n\t\t}\n\t\treturn cos(x).times(this.coeff);\n\t}\n\n\t/**\n\t * `toString` method\n\t *\n\t * @returns the LaTeX string representation of the sum of all the terms\n\t */\n\ttoString(): string {\n\t\tlet fxString: string = '';\n\t\tif (this.fx instanceof Polynomial) {\n\t\t\tfxString = this.fx.terms.length === 1 ? `${this.fx}` : `\\\\left( ${this.fx} \\\\right)`;\n\t\t}\n\t\treturn `${new BasicTerm(this.coeff, `\\\\cos ${fxString}`)}`;\n\t}\n}\n\n/**\n * function representing k exp ( f(x) )\n */\nexport class ExpFn {\n\t/** coefficient k in k exp ( f(x) ) */\n\tcoeff: Fraction;\n\t/** \"inner\" function f(x) */\n\tfx: Polynomial; //TODO: Exp|Ln|Sin|Cos\n\t/**\n\t * Creates a new CosFn class\n\t * @param options defaults to `{ fx: \"x\", coeff: 1 }`\n\t */\n\tconstructor(options?: { fx?: string | VariableTerm | Polynomial; coeff?: number | Fraction }) {\n\t\tlet { fx, coeff } = {\n\t\t\tfx: 'x',\n\t\t\tcoeff: 1,\n\t\t\t...options,\n\t\t};\n\t\tif (typeof fx === 'string') {\n\t\t\tfx = new Polynomial([1, 0], { variable: fx });\n\t\t} else if (fx instanceof VariableTerm) {\n\t\t\tfx = new Polynomial([fx.coeff, 0], { variable: fx.variable });\n\t\t}\n\t\tthis.fx = fx;\n\t\tthis.coeff = numberToFraction(coeff);\n\t}\n\n\t/** differentiates this expression */\n\tdifferentiate(): ExpFn {\n\t\t//TODO: full chain rule version\n\t\tif (this.fx.coeffs.length === 2) {\n\t\t\t// linear fx\n\t\t\treturn new ExpFn({ fx: this.fx, coeff: this.coeff.times(this.fx.coeffs[1]) });\n\t\t}\n\t\treturn new ExpFn({ fx: this.fx, coeff: this.coeff });\n\t}\n\n\t/** integrates this expression */\n\tintegrate(): ExpFn {\n\t\tif (this.fx.coeffs.length === 2) {\n\t\t\t// linear fx\n\t\t\treturn new ExpFn({ fx: this.fx, coeff: this.coeff.divide(this.fx.coeffs[1]) });\n\t\t}\n\t\treturn new ExpFn({ fx: this.fx, coeff: this.coeff });\n\t}\n\n\ttimes(x: number | Fraction): ExpFn {\n\t\treturn new ExpFn({ fx: this.fx, coeff: this.coeff.times(x) });\n\t}\n\tremoveCoeff(): ExpFn {\n\t\treturn new ExpFn({ fx: this.fx });\n\t}\n\n\t/**\n\t * `toString` method\n\t *\n\t * @returns the LaTeX string representation of the sum of all the terms\n\t */\n\ttoString(): string {\n\t\treturn `${new BasicTerm(this.coeff, `\\\\mathrm{e}^{${this.fx}}`)}`;\n\t}\n}\n\n/**\n * function representing k ln ( f(x) )\n */\nexport class LnFn {\n\t/** coefficient k in k ln ( f(x) ) */\n\tcoeff: Fraction;\n\t/** \"inner\" function f(x) */\n\tfx: Polynomial; //TODO: Exp|Ln|Sin|Cos\n\t/** modulus allows for k ln |f(x)|*/\n\tmodulus: boolean;\n\t/**\n\t * Creates a new SinFn class\n\t * @param options defaults to `{ fx: \"x\", coeff: 1 }`\n\t */\n\tconstructor(options?: { fx?: string | VariableTerm | Polynomial; coeff?: number | Fraction; modulus?: boolean }) {\n\t\tlet { fx, coeff, modulus } = {\n\t\t\tfx: 'x',\n\t\t\tcoeff: 1,\n\t\t\tmodulus: false,\n\t\t\t...options,\n\t\t};\n\t\tif (typeof fx === 'string') {\n\t\t\tfx = new Polynomial([1, 0], { variable: fx });\n\t\t} else if (fx instanceof VariableTerm) {\n\t\t\tfx = new Polynomial([fx.coeff, 0], { variable: fx.variable });\n\t\t}\n\t\tthis.fx = fx;\n\t\tthis.coeff = numberToFraction(coeff);\n\t\tthis.modulus = modulus;\n\t}\n\n\t/** differentiates this expression */\n\tdifferentiate(): RationalFn {\n\t\treturn new RationalFn(this.fx.differentiate().times(this.coeff), this.fx);\n\t}\n\n\t///** integrates this expression */\n\t//integrate(): CosFn {\n\t//\t//TODO: chain rule version\n\t//\treturn new CosFn({ fx: this.fx, coeff: this.coeff.negative() });\n\t//}\n\n\t/**\n\t * `toString` method\n\t *\n\t * @returns the LaTeX string representation of the sum of all the terms\n\t */\n\ttoString(): string {\n\t\tif (this.modulus) {\n\t\t\treturn `${new BasicTerm(this.coeff, `\\\\ln \\\\left| ${this.fx} \\\\right|`)}`;\n\t\t}\n\t\tlet fxString = `${this.fx}`;\n\t\tif (this.fx instanceof Polynomial) {\n\t\t\tfxString = this.fx.terms.length === 1 ? `${this.fx}` : `\\\\left( ${this.fx} \\\\right)`;\n\t\t}\n\t\treturn `${new BasicTerm(this.coeff, `\\\\ln ${fxString}`)}`;\n\t}\n}\n\n/**\n * function representing f(x) / g(x)\n * the RationalFn extends the Rational class by allowing differentiation\n */\nexport class RationalFn extends Rational {\n\tconstructor(\n\t\tnum: Polynomial | number | Fraction,\n\t\tden: Polynomial | Fraction | number = 1,\n\t\toptions?: { poles?: (number | Fraction)[] },\n\t) {\n\t\tsuper(num, den, options);\n\t}\n\n\t/** differentiates this expression */\n\tdifferentiate(): RationalFn {\n\t\treturn new RationalFn(\n\t\t\tthis.den.times(this.num.differentiate()).minus(this.num.times(this.den.differentiate())),\n\t\t\tthis.num.square(),\n\t\t\t{ poles: this.poles },\n\t\t);\n\t}\n\n\t///** integrates this expression */\n\t//integrate(): void {\n\t//\t//TODO: chain rule version\n\t//\n\t//}\n}\n","export { Rational } from './rationalClass';\nexport { solveRational } from './solveRational';\nexport { partialFractions } from './partialFractions';\nexport { xPolynomial } from './extendedPolynomialClass';\n","import { Polynomial, Fraction, numberToFraction, SquareRoot } from '../core';\nimport { solveLinear, solveQuadratic, longDivide } from '../polynomialMethods';\n\n/**\n * function representing f(x) / g(x) where f, g are polynomials\n * Does not consider repeated roots at the moment\n */\nexport class Rational {\n\t/** numerator */\n\tnum: Polynomial;\n\t/** denominator */\n\tden: Polynomial;\n\t/** Rational poles of the function */\n\tpoles: Fraction[];\n\n\t/**\n\t * Creates a new Rational class\n\t * @param options defaults to `{ poles: [] }` Poles are automatically determined for degree at most 2.\n\t */\n\tconstructor(\n\t\tnum: Polynomial | number | Fraction,\n\t\tden: Polynomial | Fraction | number = 1,\n\t\toptions?: { poles?: (number | Fraction)[] },\n\t) {\n\t\t// identify unknown\n\t\tlet unknown = 'x';\n\t\tif (num instanceof Polynomial) {\n\t\t\tif (den instanceof Polynomial) {\n\t\t\t\tif (num.variable !== den.variable) {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t`different unknowns detected for numerator and denominator. Will use numerator's ${num.variable}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tunknown = num.variable;\n\t\t} else {\n\t\t\tif (den instanceof Polynomial) {\n\t\t\t\tunknown = den.variable;\n\t\t\t}\n\t\t}\n\t\t// change to Polynomials\n\t\tif (typeof num === 'number' || num instanceof Fraction) {\n\t\t\tnum = new Polynomial([num], { variable: unknown });\n\t\t}\n\t\tif (typeof den === 'number' || den instanceof Fraction) {\n\t\t\tden = new Polynomial([den], { variable: unknown });\n\t\t}\n\t\tconst poles = assignPoles(den, options?.poles);\n\t\t// check for common factors\n\t\tlet newPoles = poles.map((x) => x);\n\t\tpoles.forEach((x) => {\n\t\t\tconst numerator = num as Polynomial;\n\t\t\tif (numerator.subIn(x).isEqualTo(0)) {\n\t\t\t\tconst denominator = den as Polynomial;\n\t\t\t\t({ quotient: num } = longDivide(numerator, new Polynomial([1, x.negative()], { variable: unknown })));\n\t\t\t\t({ quotient: den } = longDivide(denominator, new Polynomial([1, x.negative()], { variable: unknown })));\n\t\t\t\tnewPoles = newPoles.filter((y) => !y.isEqualTo(x));\n\t\t\t}\n\t\t});\n\t\tthis.num = num.clone();\n\t\tthis.den = den.clone();\n\t\tthis.poles = poles;\n\t}\n\n\t/** Addition */\n\tplus(rational2: number | Fraction | Polynomial | Rational): Rational {\n\t\tif (typeof rational2 === 'number' || rational2 instanceof Fraction) {\n\t\t\trational2 = new Polynomial([rational2], { variable: this.num.variable });\n\t\t}\n\t\tif (rational2 instanceof Polynomial) {\n\t\t\treturn new Rational(this.num.plus(rational2.times(this.den)), this.den, { poles: this.poles });\n\t\t}\n\t\tlet commonDivisor = new Polynomial([1], { variable: this.num.variable });\n\t\tlet sharesCommonDivisor = false;\n\t\tconst f = rational2.den;\n\t\tthis.poles.forEach((x) => {\n\t\t\tif (f.subIn(x).isEqualTo(0)) {\n\t\t\t\tcommonDivisor = commonDivisor.times(new Polynomial([1, x.negative()], { variable: this.num.variable }));\n\t\t\t\tsharesCommonDivisor = true;\n\t\t\t}\n\t\t});\n\t\tif (sharesCommonDivisor) {\n\t\t\tconst { quotient: multiple1 } = longDivide(rational2.den, commonDivisor);\n\t\t\tconst { quotient: multiple2 } = longDivide(this.den, commonDivisor);\n\t\t\tconst den = this.den.times(multiple1);\n\t\t\treturn new Rational(this.num.times(multiple1).plus(rational2.num.times(multiple2)), den, {\n\t\t\t\tpoles: [...this.poles, ...rational2.poles],\n\t\t\t});\n\t\t} else {\n\t\t\treturn new Rational(\n\t\t\t\tthis.num.times(rational2.den).plus(rational2.num.times(this.den)),\n\t\t\t\tthis.den.times(rational2.den),\n\t\t\t\t{ poles: [...this.poles, ...rational2.poles] },\n\t\t\t);\n\t\t}\n\t}\n\n\tnegative(): Rational {\n\t\treturn new Rational(this.num.negative(), this.den, { poles: this.poles });\n\t}\n\n\t/** subtraction */\n\tminus(rational2: number | Fraction | Polynomial | Rational): Rational {\n\t\tif (typeof rational2 === 'number' || rational2 instanceof Fraction) {\n\t\t\trational2 = new Polynomial([rational2], { variable: this.num.variable });\n\t\t}\n\t\treturn this.plus(rational2.negative());\n\t}\n\n\t/** multiplication */\n\ttimes(rational2: number | Fraction | Polynomial | Rational): Rational {\n\t\tif (typeof rational2 === 'number' || rational2 instanceof Fraction) {\n\t\t\trational2 = new Polynomial([rational2], { variable: this.num.variable });\n\t\t}\n\t\tif (rational2 instanceof Polynomial) {\n\t\t\trational2 = new Rational(rational2);\n\t\t}\n\t\treturn new Rational(this.num.times(rational2.num), this.den.times(rational2.den), {\n\t\t\tpoles: [...this.poles, ...rational2.poles],\n\t\t});\n\t}\n\n\treciprocal(): Rational {\n\t\treturn new Rational(this.den, this.num);\n\t}\n\n\t/** division */\n\tdivide(rational2: number | Fraction | Polynomial | Rational): Rational {\n\t\tif (typeof rational2 === 'number' || rational2 instanceof Fraction) {\n\t\t\trational2 = new Polynomial([rational2], { variable: this.num.variable });\n\t\t}\n\t\tif (rational2 instanceof Polynomial) {\n\t\t\trational2 = new Rational(rational2);\n\t\t}\n\t\treturn this.times(rational2.reciprocal());\n\t}\n\n\t/** subs in a fraction/integer */\n\tsubIn(x: number | Fraction): Fraction {\n\t\treturn this.num.subIn(x).divide(this.den.subIn(x));\n\t}\n\n\tsubInNumber(x: number): number {\n\t\treturn this.num.subInNumber(x) / this.den.subInNumber(x);\n\t}\n\n\tdifferentiate(): Rational {\n\t\tconst num = this.num.differentiate().times(this.den).minus(this.den.differentiate().times(this.num));\n\t\tconst den = this.den.square();\n\t\treturn new Rational(num, den, { poles: this.poles });\n\t}\n\n\treplaceXWith(x: string | Polynomial): Rational {\n\t\treturn new Rational(this.num.replaceXWith(x), this.den.replaceXWith(x));\n\t}\n\n\t/**\n\t * `toString` method\n\t *\n\t * @returns the LaTeX string representation of the sum of all the terms\n\t */\n\ttoString(): string {\n\t\tif (this.den.degree === 0) {\n\t\t\tconst f = this.num.divide(this.den.coeffs[0]);\n\t\t\treturn `${f}`;\n\t\t} else {\n\t\t\treturn `\\\\frac{ ${this.num} }{ ${this.den} }`;\n\t\t}\n\t}\n}\n\nfunction assignPoles(den: Polynomial, providedPoles?: (number | Fraction)[]): Fraction[] {\n\tif (den.degree === 0) {\n\t\treturn [];\n\t} else if (den.degree === 1) {\n\t\treturn [solveLinear(den)];\n\t} else if (den.degree === 2) {\n\t\tconst roots = solveQuadratic(den);\n\t\tif (roots[2] === 'frac') {\n\t\t\treturn [roots[0], roots[1]];\n\t\t}\n\t} else {\n\t\t// degree 3 and above\n\t\tif (providedPoles) {\n\t\t\tconst poles: Fraction[] = [];\n\t\t\tconst f = den;\n\t\t\t// check if poles are valid\n\t\t\tprovidedPoles.forEach((x) => {\n\t\t\t\tif (f.subIn(x).isEqualTo(0)) {\n\t\t\t\t\tpoles.push(numberToFraction(x));\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(`Provided pole ${x} is incorrect for denominator ${f}`);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn poles;\n\t\t}\n\t}\n\treturn [];\n}\n","export { expToPoly } from './expressionToPolynomial';\nexport {\n\tsimplifyPoly,\n\tfactorizeQuadratic,\n\tfactorizeCubic,\n\tsolveQuadratic,\n\tsolveQuadraticSurd,\n\tsolveLinear,\n\tshiftPoly,\n\tcompleteSquare,\n\tcompleteSquareParams,\n} from './polynomials';\nexport { solveQuadraticComplex } from './solveQuadraticComplex';\nexport { longDivide } from './longDivide';\nexport { linear } from './linear';\nexport { subSurdInPoly } from './polynomialsAndSurds';\n","import { Expression, Polynomial } from '../core/index';\nimport { createZeroArray } from '../core/algebra/polynomialClass';\n\n/**\n * parses an expression, and attempts to convert it to a Polynomial\n * of degree n\n *\n * options default to {n: 2, ascending: false}\n */\nexport function expToPoly(exp: Expression, options?: { n?: number; ascending?: boolean }): Polynomial {\n\tconst { n, ascending } = {\n\t\tn: 2,\n\t\tascending: false,\n\t\t...options,\n\t};\n\tconst coeffs = createZeroArray(n + 1);\n\tlet variable: string | undefined = undefined;\n\texp.terms.forEach((term) => {\n\t\tconst length = Object.keys(term.symbols).length;\n\t\t// constant term\n\t\tif (length === 0) {\n\t\t\tcoeffs[0] = coeffs[0].plus(term.coeff);\n\t\t\treturn;\n\t\t}\n\t\t// checks for unknown term\n\t\tif (length > 1) {\n\t\t\tthrow new Error(`cannot convert term with more than one basic unit ${term}`);\n\t\t}\n\t\tconst unit = term.symbols[Object.keys(term.symbols)[0]];\n\t\t// checks if more than one unknown\n\t\tif (variable === undefined) {\n\t\t\tvariable = unit.symbol.symbol;\n\t\t} else {\n\t\t\tif (variable !== unit.symbol.symbol) {\n\t\t\t\tthrow new Error(`cannot convert term with multiple unknowns ${unit}, ${variable}`);\n\t\t\t}\n\t\t}\n\t\t// checks validity of degree\n\t\tif (unit.power.isLessThan(0) || unit.power.isGreaterThan(n) || !unit.power.isInteger()) {\n\t\t\tthrow new Error(`Invalid degree for ${unit} to be converted into polynomial`);\n\t\t}\n\t\t// adds into coeffs array\n\t\tcoeffs[unit.power.valueOf()] = coeffs[unit.power.valueOf()].plus(term.coeff);\n\t});\n\tif (!ascending) {\n\t\tcoeffs.reverse();\n\t}\n\treturn new Polynomial(coeffs, { ascending, degree: n, variable: variable ?? 'x' });\n}\n","import { Polynomial, Fraction, SquareRoot, numberToFraction, Expression, Term } from '../core/index';\n\n/**\n * simplify a polynomial, returning a simplified polynomial\n * so that all the coefficients are integers, the leading coefficient is positive,\n * and gcd(...coeffs) = 1\n */\nexport function simplifyPoly(poly: Polynomial): Polynomial {\n\tlet [coeffs] = Fraction.factorize(...poly.coeffs);\n\tif (coeffs[0].valueOf() < 0) {\n\t\tcoeffs = coeffs.map((c) => c.negative());\n\t}\n\tif (!poly.ascending) {\n\t\tcoeffs.reverse();\n\t}\n\treturn new Polynomial(coeffs, { ascending: poly.ascending, variable: poly.variable });\n}\n\n/**\n * factorize a simplified quadratic polynomial into two linear factors\n *\n * Also returns the two roots of the quadratic\n */\nexport function factorizeQuadratic(poly: Polynomial): [Polynomial, Polynomial, [Fraction, Fraction]] {\n\tconst [root1, root2] = solveQuadratic(poly);\n\tif (typeof root1 === 'number' || typeof root2 === 'number') {\n\t\tthrow new Error('irrational roots');\n\t}\n\tconst factor1 = new Polynomial([root1.den, -root1.num], { variable: poly.variable });\n\tconst factor2 = new Polynomial([root2.den, -root2.num], { variable: poly.variable });\n\treturn [factor1, factor2, [root1, root2]];\n}\n\n/**\n * factorize a simplified cubic polynomial into three linear factors or one linear + one irreducible quadratic\n *\n * Also returns the other roots\n */\nexport function factorizeCubic(poly: Polynomial, root: number | Fraction): [Polynomial[], [Fraction, Fraction] | null] {\n\tif (!poly.subIn(root).isEqualTo(0)) {\n\t\tthrow new Error(`root provided is not correct`);\n\t}\n\troot = numberToFraction(root);\n\tconst factor1 = new Polynomial([root.den, -root.num], { variable: poly.variable });\n\t// ax^3 + bx^2 + cx + d = (ex+f)(Ax^2+Bx+C);\n\t// comparing coefficients\n\tconst [d, c, b, a] = poly.coeffs;\n\tconst [f, e] = factor1.coeffs;\n\t// a = Ae\n\tconst A = a.divide(e);\n\t// b = Af + Be\n\tconst B = b.minus(A.times(f)).divide(e);\n\t// check answer: c = Bf + Ce\n\t// d = fC\n\tconst C = d.divide(f);\n\tif (!c.isEqualTo(B.times(f).plus(C.times(e)))) {\n\t\tthrow new Error(`Error encountered in comparing coefficients: check code`);\n\t}\n\tconst quadratic = new Polynomial([A, B, C], { variable: poly.variable });\n\tconst [root2, root3] = solveQuadratic(quadratic);\n\t// see if can factorize further\n\tif (root2 instanceof Fraction && root3 instanceof Fraction) {\n\t\tconst [factor2, factor3] = factorizeQuadratic(quadratic);\n\t\treturn [\n\t\t\t[factor1, factor2, factor3],\n\t\t\t[root2, root3],\n\t\t];\n\t}\n\treturn [[factor1, quadratic], null];\n}\n\n/**\n * solves a quadratic equation\n *\n * throws [NaN, NaN] if complex roots found: consider using complex solver\n *\n */\nexport function solveQuadratic(\n\tpoly: Polynomial | (number | Fraction)[],\n): [Fraction, Fraction, 'frac'] | [number, number, 'float'] | [number, number, 'NaN'] {\n\tif (!(poly instanceof Polynomial)) {\n\t\tpoly = new Polynomial(poly);\n\t}\n\tif (poly.degree !== 2) {\n\t\tthrow new Error(`${poly} is not a quadratic polynomial`);\n\t}\n\tlet [c, b, a] = poly.coeffs;\n\tif (a.isLessThan(0)) {\n\t\ta = a.negative();\n\t\tb = b.negative();\n\t\tc = c.negative();\n\t}\n\tconst discriminant = b.square().minus(a.times(c).times(4));\n\tif (discriminant.valueOf() < 0) {\n\t\treturn [NaN, NaN, 'NaN'];\n\t}\n\tconst sqrt = new SquareRoot(discriminant);\n\tif (sqrt.isRational()) {\n\t\tconst sqrtValue = sqrt.coeff;\n\t\tconst root1 = b.negative().minus(sqrtValue).divide(2).divide(a);\n\t\tconst root2 = b.negative().plus(sqrtValue).divide(2).divide(a);\n\t\treturn [root1, root2, 'frac'];\n\t}\n\t// irrational answers\n\tconst sqrtValue = sqrt.valueOf();\n\tconst root1 = (-b.valueOf() - sqrtValue) / 2 / a.valueOf();\n\tconst root2 = (-b.valueOf() + sqrtValue) / 2 / a.valueOf();\n\treturn [root1, root2, 'float'];\n}\n\n/**\n * solves a quadratic equation to give irrational roots in surd form\n *\n * throws if complex roots found: consider using complex solver\n *\n */\nexport function solveQuadraticSurd(poly: Polynomial | (number | Fraction)[]): [Expression, Expression] {\n\tif (!(poly instanceof Polynomial)) {\n\t\tpoly = new Polynomial(poly);\n\t}\n\tif (poly.degree !== 2) {\n\t\tthrow new Error(`${poly} is not a quadratic polynomial`);\n\t}\n\tlet [c, b, a] = poly.coeffs;\n\tif (a.isLessThan(0)) {\n\t\t[c, b, a] = [c.negative(), b.negative(), a.negative()];\n\t}\n\tconst discriminant = b.square().minus(a.times(c).times(4));\n\tif (discriminant.valueOf() < 0) {\n\t\tthrow new Error(`complex roots found: ${poly}`);\n\t}\n\tconst sqrt = new SquareRoot(discriminant);\n\tconst surd = sqrt.divide(a.times(2));\n\tconst root2 = new Expression(b.negative().divide(a.times(2)), new Term(surd.coeff, `${surd.variableString}`));\n\tconst root1 = new Expression(\n\t\tb.negative().divide(a.times(2)),\n\t\tnew Term(surd.coeff.negative(), `${surd.variableString}`),\n\t);\n\treturn [root1, root2];\n}\n\n/**\n * solves a linear equation\n */\nexport function solveLinear(poly: Polynomial | (number | Fraction)[]): Fraction {\n\tif (!(poly instanceof Polynomial)) {\n\t\tpoly = new Polynomial(poly);\n\t}\n\treturn poly.coeffs[0].negative().divide(poly.coeffs[1]);\n}\n\n/**\n * shifts a polynomial: replace x with x+a\n */\nexport function shiftPoly(poly: Polynomial, a: number | Fraction): Polynomial {\n\tconst xPlusA = poly.ascending\n\t\t? new Polynomial([a, 1], { variable: poly.variable, ascending: true })\n\t\t: new Polynomial([1, a], { variable: poly.variable });\n\tconst zero = new Polynomial([0], { variable: poly.variable, ascending: poly.ascending });\n\treturn poly.coeffs.reduce((prev, curr, i) => {\n\t\tif (i === 0) {\n\t\t\treturn prev.plus(curr);\n\t\t}\n\t\treturn prev.plus(xPlusA.pow(i).times(curr));\n\t}, zero);\n}\n\n/**\n * completes the square\n */\nexport function completeSquare(poly: Polynomial): string {\n\tif (poly.degree !== 2) {\n\t\tthrow new Error(`${poly} is not a quadratic polynomial`);\n\t}\n\tconst { a, completedSquare, c } = completeSquareParams(poly);\n\tconst bOver2A = completedSquare.coeffs[1];\n\tconst bracketed = bOver2A.isEqualTo(0) ? `${completedSquare}^2` : `\\\\left( ${completedSquare} \\\\right)^2`;\n\tconst exp = new Expression(new Term(a, `${bracketed}`), c);\n\treturn `${exp}`;\n}\n\n/**\n * completes the square\n * returns a (x+b)^2 + c\n * as `{a, completedSquare: (x+b), c}`\n *\n */\nexport function completeSquareParams(poly: Polynomial): { a: Fraction; completedSquare: Polynomial; c: Fraction } {\n\tif (poly.degree !== 2) {\n\t\tthrow new Error(`${poly} is not a quadratic polynomial`);\n\t}\n\tconst [c1, b1, a] = poly.coeffs;\n\tconst b = b1.divide(2).divide(a);\n\tconst c = c1.minus(b1.square().divide(4).divide(a));\n\treturn { a, c, completedSquare: new Polynomial([1, b], { variable: poly.variable }) };\n}\n","import { solveQuadraticSurd } from './polynomials';\nimport { Complex, xComplex } from '../complex';\nimport { Polynomial, SquareRoot, type Fraction } from '../core';\n\nexport function solveQuadraticComplex(\n\tpoly: Polynomial | (number | Fraction)[],\n): [Complex, Complex] | [xComplex, xComplex] {\n\tif (!(poly instanceof Polynomial)) {\n\t\tpoly = new Polynomial(poly);\n\t}\n\tif (poly.degree !== 2) {\n\t\tthrow new Error(`${poly} is not a quadratic polynomial`);\n\t}\n\tlet [c, b, a] = poly.coeffs;\n\tif (a.isLessThan(0)) {\n\t\ta = a.negative();\n\t\tb = b.negative();\n\t\tc = c.negative();\n\t}\n\tconst discriminant = b.square().minus(a.times(c).times(4));\n\tif (discriminant.valueOf() >= 0) {\n\t\t// real roots\n\t\tconst [root1, root2] = solveQuadraticSurd(poly);\n\t\treturn [new xComplex(root1, 0), new xComplex(root2, 0)];\n\t}\n\tconst sqrt = new SquareRoot(discriminant.abs());\n\tconst real = b.negative().divide(2).divide(a);\n\tif (sqrt.isRational()) {\n\t\tconst imag = sqrt.coeff.divide(2).divide(a);\n\t\treturn [new Complex(real, imag.negative()), new Complex(real, imag)];\n\t}\n\t// irrational answers\n\tconst imag = sqrt.divide(2).divide(a).abs();\n\treturn [new xComplex(real, imag.negative()), new xComplex(real, imag)];\n}\n","export { Complex } from './complexClass';\nexport { ComplexExp } from './complexExpClass';\nexport { xComplex } from './extendedComplexClass';\nexport { expToCartesian, complexToQuadratic, subComplexIntoPoly } from './utils';\n","import { Fraction, Imaginary, Expression, numberToFraction, SquareRoot, Term } from '../core';\n\n/**\n * Complex class representing x + yi\n */\nexport class Complex extends Expression {\n\t/** real part of the complex number */\n\treal: Fraction;\n\t/** imaginary part of the complex number */\n\timag: Fraction;\n\n\t/**\n\t * Creates a new Complex instance\n\t */\n\tconstructor(real: number | Fraction, imag: number | Fraction = 0) {\n\t\tconst x = numberToFraction(real);\n\t\t// const y = new Imaginary(imag);\n\t\tsuper(x, new Term(imag, 'i'));\n\t\tthis.real = x;\n\t\tthis.imag = numberToFraction(imag);\n\t}\n\n\t/**\n\t * adds two complex numbers\n\t */\n\tplus(z: number | Fraction | Complex): Complex {\n\t\tif (z instanceof Complex) {\n\t\t\treturn new Complex(this.real.plus(z.real), this.imag.plus(z.imag));\n\t\t}\n\t\treturn new Complex(this.real.plus(z), this.imag);\n\t}\n\t/**\n\t * negative of this complex number\n\t */\n\tnegative(): Complex {\n\t\treturn new Complex(this.real.negative(), this.imag.negative());\n\t}\n\t/**\n\t * complex number subtraction\n\t */\n\tminus(z: number | Fraction | Complex): Complex {\n\t\tif (typeof z === 'number') {\n\t\t\treturn this.plus(new Complex(-z, 0));\n\t\t}\n\t\treturn this.plus(z.negative());\n\t}\n\t/**\n\t * complex number multiplication\n\t */\n\ttimes(z: number | Fraction | Complex): Complex {\n\t\tif (z instanceof Complex) {\n\t\t\treturn new Complex(\n\t\t\t\tthis.real.times(z.real).minus(this.imag.times(z.imag)),\n\t\t\t\tthis.real.times(z.imag).plus(this.imag.times(z.real)),\n\t\t\t);\n\t\t}\n\t\treturn new Complex(this.real.times(z), this.imag.times(z));\n\t}\n\t/**\n\t * complex conjugation\n\t */\n\tconjugate(): Complex {\n\t\treturn new Complex(this.real, this.imag.negative());\n\t}\n\t/**\n\t * r^2 = |z|^2\n\t */\n\trSquared(): Fraction {\n\t\treturn this.times(this.conjugate()).real.clone();\n\t}\n\t/**\n\t * reciprocal\n\t */\n\treciprocal(): Complex {\n\t\tif (this.rSquared().isEqualTo(0)) {\n\t\t\tthrow new Error('division by zero');\n\t\t}\n\t\treturn this.conjugate().times(this.rSquared().reciprocal());\n\t}\n\t/**\n\t * complex division\n\t */\n\tdivide(z: number | Fraction | Complex): Complex {\n\t\tif (typeof z === 'number') {\n\t\t\treturn this.times(new Fraction(1, z));\n\t\t}\n\t\treturn this.times(z.reciprocal());\n\t}\n\t/**\n\t * r = |z|\n\t */\n\tr(): SquareRoot {\n\t\treturn new SquareRoot(this.rSquared());\n\t}\n\t/**\n\t * z^n\n\t */\n\tpow(n: number): Complex {\n\t\tif (!Number.isInteger(n) || n < 0) {\n\t\t\tthrow new Error(`invalid exponent ${n}: only non-negative integers supported`);\n\t\t}\n\t\tlet result = new Complex(1, 0);\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tresult = result.times(this);\n\t\t}\n\t\treturn result;\n\t}\n\t/**\n\t * z^2\n\t */\n\tsquare(): Complex {\n\t\treturn this.times(this);\n\t}\n\n\tisReal(): boolean {\n\t\treturn this.imag.isEqualTo(0);\n\t}\n\tisPurelyImaginary(): boolean {\n\t\treturn this.real.isEqualTo(0);\n\t}\n\n\tisEqualTo(z: Complex | number): boolean {\n\t\tif (typeof z === 'number') {\n\t\t\treturn this.isReal() && this.real.isEqualTo(z);\n\t\t}\n\t\treturn this.real.isEqualTo(z.real) && this.imag.isEqualTo(z.imag);\n\t}\n\n\t/**\n\t * clones this complex number\n\t */\n\tclone(): Complex {\n\t\treturn new Complex(this.real, this.imag);\n\t}\n\n\tstatic I = new Complex(0, 1);\n}\n","import { Fraction, Surd, Imaginary, Term, Expression, numberToFraction, SquareRoot, numberToSquareRoot } from '../core';\nimport { Angle } from '../trigo';\n\n/**\n * ComplexExp class representing r e^{i theta}\n */\nexport class ComplexExp extends Term {\n\t/** modulus of the complex number */\n\tmod: SquareRoot;\n\t/** argument of the complex number */\n\targ: Angle;\n\n\t/**\n\t * Creates a new ComplexExp instance\n\t *\n\t * @param theta type number will be interpreted as in degrees, type Fraction will be interpreted as k in k pi\n\t */\n\tconstructor(r: number | Fraction | SquareRoot, theta: number | Fraction | Angle = 0) {\n\t\tr = numberToSquareRoot(r);\n\t\tif (r.valueOf() < 0) {\n\t\t\tthrow new Error(`negative modulus ${r} provided`);\n\t\t}\n\t\tif (!(theta instanceof Angle)) {\n\t\t\ttheta = new Angle(theta);\n\t\t}\n\t\tif (theta.isEqualTo(0)) {\n\t\t\tsuper(r.coeff, new Surd(r.radicand.valueOf()));\n\t\t} else {\n\t\t\tconst argumentTerm = new Term(1).times(theta).times('i');\n\t\t\tsuper(r.coeff, new Surd(r.radicand.valueOf()), `\\\\mathrm{e}^{${argumentTerm}}`);\n\t\t}\n\t\tif (r.coeff.isLessThan(0)) {\n\t\t\tthrow new Error(`r ${r} must be non-negative`);\n\t\t}\n\t\tthis.mod = r.clone();\n\t\tthis.arg = theta.clone();\n\t}\n\n\t/**\n\t * negative of this complex number\n\t */\n\tnegative(): ComplexExp {\n\t\treturn new ComplexExp(this.mod, this.arg.plus(new Fraction(1))); // multiplies by e^i pi\n\t}\n\t/**\n\t * complex number multiplication\n\t */\n\ttimes(z: number | Fraction | ComplexExp): ComplexExp {\n\t\tif (z instanceof ComplexExp) {\n\t\t\treturn new ComplexExp(this.mod.times(z.mod), this.arg.plus(z.arg));\n\t\t}\n\t\treturn (typeof z === 'number' && z > 0) || (z instanceof Fraction && z.isGreaterThan(0))\n\t\t\t? new ComplexExp(this.mod.times(z), this.arg)\n\t\t\t: typeof z === 'number'\n\t\t\t? new ComplexExp(this.mod.times(Math.abs(z)), this.arg.plus(Fraction.ONE))\n\t\t\t: new ComplexExp(this.mod.times(z.abs()), this.arg.plus(Fraction.ONE));\n\t}\n\t/**\n\t * complex conjugation\n\t */\n\tconjugate(): ComplexExp {\n\t\treturn new ComplexExp(this.mod, this.arg.negative());\n\t}\n\treciprocal(): ComplexExp {\n\t\tif (this.mod.isEqualTo(0)) {\n\t\t\tthrow new Error('division by zero');\n\t\t}\n\t\treturn new ComplexExp(this.mod.reciprocal(), this.arg.negative());\n\t}\n\t/**\n\t * complex division\n\t */\n\tdivide(z: number | Fraction | ComplexExp): ComplexExp {\n\t\tif (typeof z === 'number') {\n\t\t\treturn this.times(new Fraction(1, z));\n\t\t}\n\t\treturn this.times(z.reciprocal());\n\t}\n\t/**\n\t * complex exponentiation\n\t */\n\tpow(n: number): ComplexExp {\n\t\treturn new ComplexExp(this.mod.pow(n), this.arg.times(n));\n\t}\n\t/**\n\t * z^2\n\t */\n\tsquare(): ComplexExp {\n\t\treturn this.pow(2);\n\t}\n\t/**\n\t * returns the polar form r (cos theta + i sin theta)\n\t */\n\ttoPolarString(wrap = false): string {\n\t\tif (wrap) {\n\t\t\tconst trigoString = this.arg.k.isLessThan(0)\n\t\t\t\t? `\\\\cos ( ${this.arg} ) + \\\\mathrm{i} \\\\sin ( ${this.arg} )`\n\t\t\t\t: `\\\\cos ${this.arg} + \\\\mathrm{i} \\\\sin ${this.arg}`;\n\t\t\treturn this.mod.isEqualTo(1) ? trigoString : `${this.mod} ( ${trigoString} )`;\n\t\t} else {\n\t\t\tconst trigoString = this.arg.k.isLessThan(0)\n\t\t\t\t? `\\\\cos \\\\left( ${this.arg} \\\\right) + \\\\mathrm{i} \\\\sin \\\\left( ${this.arg} \\\\right)`\n\t\t\t\t: `\\\\cos ${this.arg} + \\\\mathrm{i} \\\\sin ${this.arg}`;\n\t\t\treturn this.mod.isEqualTo(1) ? trigoString : `${this.mod} \\\\left( ${trigoString} \\\\right)`;\n\t\t}\n\t}\n\tclone(): ComplexExp {\n\t\treturn new ComplexExp(this.mod, this.arg);\n\t}\n\n\t/**\n\t * returns the standard form r e^(i theta)\n\t */\n\tstatic FORM(r = 'r', theta = '\\\\theta'): string {\n\t\treturn theta === '\\\\theta' ? `${r} \\\\mathrm{e}^{\\\\mathrm{i}${theta}}` : `${r} \\\\mathrm{e}^{${theta}\\\\mathrm{i}}`;\n\t}\n\t/**\n\t * returns the standard form r e^(i theta)\n\t */\n\tstatic POLAR_FORM(r = 'r', theta = '\\\\theta'): string {\n\t\treturn r === ''\n\t\t\t? `\\\\cos ${theta} + \\\\mathrm{i} \\\\sin ${theta}`\n\t\t\t: `${r} (\\\\cos ${theta} + \\\\mathrm{i} \\\\sin ${theta})`;\n\t}\n}\n","export { Angle } from './angleClass';\nexport { sin, cos, tan } from './trigoFns';\nexport { asin, acos, atan } from './arcFns';\n","import { Term, Fraction } from '../core';\n\n/**\n * Angle class representing an angle k pi\n */\nexport class Angle extends Term {\n\t/**\n\t * k in k pi\n\t */\n\tk: Fraction;\n\t/**\n\t * angle in degrees\n\t */\n\tdegrees: Fraction;\n\t/**\n\t * 'complex' means -pi < theta \\leq pi\n\t * 'default' means 0 \\leq theta < 2 pi\n\t * 'all' means -\\infty < theta < infty: no cycling will be performed\n\t */\n\tdomain: 'complex' | 'default' | 'all';\n\t/**\n\t * constructs a new Angle class instance\n\t *\n\t * @param angle if angle is a number, we will treat it as if it is in degrees. If angle is of Fraction type, will treat it\n\t * as if it is k in k pi\n\t * @param options defaults to { domain: 'complex' }\n\t * 'complex' means -pi < theta \\leq pi\n\t * 'default' means 0 \\leq theta < 2 pi\n\t * 'all' means -\\infty < theta < infty: no cycling will be performed\n\t */\n\tconstructor(angle: number | Fraction, options?: { domain?: 'complex' | 'default' | 'all' }) {\n\t\tconst domain = options?.domain ?? 'complex';\n\t\tlet k = typeof angle === 'number' ? new Fraction(angle, 180) : angle;\n\t\tif (domain === 'complex') {\n\t\t\twhile (k.isAtMost(-1)) {\n\t\t\t\tk = k.plus(2);\n\t\t\t}\n\t\t\twhile (k.isGreaterThan(1)) {\n\t\t\t\tk = k.minus(2);\n\t\t\t}\n\t\t} else if (domain === 'default') {\n\t\t\twhile (k.isLessThan(0)) {\n\t\t\t\tk = k.plus(2);\n\t\t\t}\n\t\t\twhile (k.isAtLeast(2)) {\n\t\t\t\tk = k.minus(2);\n\t\t\t}\n\t\t}\n\t\tsuper(k, '\\\\pi');\n\t\tthis.k = k;\n\t\tthis.degrees = k.times(180);\n\t\tthis.domain = domain;\n\t}\n\n\tplus(theta: number | Fraction | Angle): Angle {\n\t\treturn new Angle(this.k.plus(numberToAngle(theta).k), { domain: this.domain });\n\t}\n\tnegative(): Angle {\n\t\treturn new Angle(this.k.negative(), { domain: this.domain });\n\t}\n\tminus(theta: number | Fraction | Angle): Angle {\n\t\treturn new Angle(this.k.minus(numberToAngle(theta).k), { domain: this.domain });\n\t}\n\ttimes(k: number | Fraction): Angle {\n\t\treturn new Angle(this.k.times(k), { domain: this.domain });\n\t}\n\tdivide(k: number | Fraction): Angle {\n\t\treturn new Angle(this.k.divide(k), { domain: this.domain });\n\t}\n\tisEqualTo(theta: number | Fraction | Angle): boolean {\n\t\treturn this.k.isEqualTo(numberToAngle(theta).k);\n\t}\n\n\t/**\n\t * returns the value of the angle in radians in the number type\n\t */\n\tvalueOf(): number {\n\t\treturn this.k.valueOf() * Math.PI;\n\t}\n\tclone(): Angle {\n\t\treturn new Angle(this.k.clone(), { domain: this.domain });\n\t}\n}\n\nfunction numberToAngle(angle: number | Fraction | Angle): Angle {\n\tif (angle instanceof Angle) {\n\t\treturn angle;\n\t}\n\treturn new Angle(angle);\n}\n","import { Fraction, SquareRoot } from '../core';\nimport { Angle } from './angleClass';\n\nexport function cos(theta: Angle | number | Fraction): SquareRoot {\n\tif (typeof theta === 'number' || theta instanceof Fraction) {\n\t\ttheta = new Angle(theta);\n\t}\n\ttheta = new Angle(theta.k); // change to -pi to pi domain\n\tif (theta.k.den === 1) {\n\t\tif (theta.k.num === 0) {\n\t\t\treturn new SquareRoot(1);\n\t\t} else if (theta.k.num === 1) {\n\t\t\treturn new SquareRoot(1, -1);\n\t\t}\n\t} else if (theta.k.den === 2) {\n\t\tif (Math.abs(theta.k.num) === 1) {\n\t\t\treturn new SquareRoot(0);\n\t\t}\n\t} else if (theta.k.den === 3) {\n\t\tif (Math.abs(theta.k.num) === 1) {\n\t\t\treturn new SquareRoot(1, new Fraction(1, 2));\n\t\t} else if (Math.abs(theta.k.num) === 2) {\n\t\t\treturn new SquareRoot(1, new Fraction(-1, 2));\n\t\t}\n\t} else if (theta.k.den === 4) {\n\t\tif (Math.abs(theta.k.num) === 1) {\n\t\t\treturn new SquareRoot(2, new Fraction(1, 2));\n\t\t} else if (Math.abs(theta.k.num) === 3) {\n\t\t\treturn new SquareRoot(2, new Fraction(-1, 2));\n\t\t}\n\t} else if (theta.k.den === 6) {\n\t\tif (Math.abs(theta.k.num) === 1) {\n\t\t\treturn new SquareRoot(3, new Fraction(1, 2));\n\t\t} else if (Math.abs(theta.k.num) === 5) {\n\t\t\treturn new SquareRoot(3, new Fraction(-1, 2));\n\t\t}\n\t}\n\tthrow new Error(`${theta} cos function only valid for special angles`);\n}\n\nexport function sin(theta: Angle | number | Fraction): SquareRoot {\n\tif (typeof theta === 'number' || theta instanceof Fraction) {\n\t\ttheta = new Angle(theta);\n\t}\n\ttheta = new Angle(theta.k); // change to -pi to pi domain\n\tif (theta.k.den === 1) {\n\t\tif (theta.k.num === 0) {\n\t\t\treturn new SquareRoot(0);\n\t\t} else if (theta.k.num === 1) {\n\t\t\treturn new SquareRoot(0);\n\t\t}\n\t} else if (theta.k.den === 2) {\n\t\tif (Math.abs(theta.k.num) === 1) {\n\t\t\treturn new SquareRoot(1).times(Math.sign(theta.k.num));\n\t\t}\n\t} else if (theta.k.den === 3) {\n\t\tif (Math.abs(theta.k.num) === 1) {\n\t\t\treturn new SquareRoot(3, new Fraction(1, 2)).times(Math.sign(theta.k.num));\n\t\t} else if (Math.abs(theta.k.num) === 2) {\n\t\t\treturn new SquareRoot(3, new Fraction(1, 2)).times(Math.sign(theta.k.num));\n\t\t}\n\t} else if (theta.k.den === 4) {\n\t\tif (Math.abs(theta.k.num) === 1) {\n\t\t\treturn new SquareRoot(2, new Fraction(1, 2)).times(Math.sign(theta.k.num));\n\t\t} else if (Math.abs(theta.k.num) === 3) {\n\t\t\treturn new SquareRoot(2, new Fraction(1, 2)).times(Math.sign(theta.k.num));\n\t\t}\n\t} else if (theta.k.den === 6) {\n\t\tif (Math.abs(theta.k.num) === 1) {\n\t\t\treturn new SquareRoot(1, new Fraction(1, 2)).times(Math.sign(theta.k.num));\n\t\t} else if (Math.abs(theta.k.num) === 5) {\n\t\t\treturn new SquareRoot(1, new Fraction(1, 2)).times(Math.sign(theta.k.num));\n\t\t}\n\t}\n\tthrow new Error(`${theta} sin function only valid for special angles`);\n}\n\nexport function tan(theta: Angle | number | Fraction): SquareRoot {\n\treturn sin(theta).divide(cos(theta));\n}\n","import { Fraction, SquareRoot } from '../core';\nimport { Angle } from './angleClass';\n\nexport function asin(x: number | SquareRoot | Fraction): Angle {\n\tconst half = new Fraction(1, 2);\n\tif (typeof x === 'number') {\n\t\tx = new Fraction(x);\n\t}\n\tif (x instanceof SquareRoot) {\n\t\tif (x.isRational()) {\n\t\t\tx = x.coeff;\n\t\t}\n\t}\n\tif (x.isEqualTo(0)) {\n\t\treturn new Angle(0, { domain: 'all' });\n\t}\n\tif (x instanceof Fraction) {\n\t\tif (x.abs().isEqualTo(half)) {\n\t\t\treturn x.isGreaterThan(0) ? new Angle(30, { domain: 'all' }) : new Angle(-30, { domain: 'all' });\n\t\t} else if (x.abs().isEqualTo(1)) {\n\t\t\treturn x.isGreaterThan(0) ? new Angle(90, { domain: 'all' }) : new Angle(-90, { domain: 'all' });\n\t\t}\n\t} else {\n\t\tif (x.abs().isEqualTo(new SquareRoot(2, half))) {\n\t\t\treturn x.coeff.isGreaterThan(0) ? new Angle(45, { domain: 'all' }) : new Angle(-45, { domain: 'all' });\n\t\t} else if (x.abs().isEqualTo(new SquareRoot(3, half))) {\n\t\t\treturn x.coeff.isGreaterThan(0) ? new Angle(60, { domain: 'all' }) : new Angle(-60, { domain: 'all' });\n\t\t}\n\t}\n\tthrow new Error(`${x} asin function only valid for special ratios`);\n}\nexport function acos(x: number | SquareRoot | Fraction): Angle {\n\tconst half = new Fraction(1, 2);\n\tif (typeof x === 'number') {\n\t\tx = new Fraction(x);\n\t}\n\tif (x instanceof SquareRoot) {\n\t\tif (x.isRational()) {\n\t\t\tx = x.coeff;\n\t\t}\n\t}\n\tif (x.isEqualTo(0)) {\n\t\treturn new Angle(90, { domain: 'all' });\n\t}\n\tif (x instanceof Fraction) {\n\t\tif (x.abs().isEqualTo(half)) {\n\t\t\treturn x.isGreaterThan(0) ? new Angle(60, { domain: 'all' }) : new Angle(120, { domain: 'all' });\n\t\t} else if (x.abs().isEqualTo(1)) {\n\t\t\treturn x.isGreaterThan(0) ? new Angle(0, { domain: 'all' }) : new Angle(180, { domain: 'all' });\n\t\t}\n\t} else {\n\t\tif (x.abs().isEqualTo(new SquareRoot(2, half))) {\n\t\t\treturn x.coeff.isGreaterThan(0) ? new Angle(45, { domain: 'all' }) : new Angle(135, { domain: 'all' });\n\t\t} else if (x.abs().isEqualTo(new SquareRoot(3, half))) {\n\t\t\treturn x.coeff.isGreaterThan(0) ? new Angle(30, { domain: 'all' }) : new Angle(150, { domain: 'all' });\n\t\t}\n\t}\n\tthrow new Error(`${x} acos function only valid for special ratios`);\n}\nexport function atan(x: number | SquareRoot | Fraction): Angle {\n\tconst third = new Fraction(1, 3);\n\tif (typeof x === 'number') {\n\t\tx = new Fraction(x);\n\t}\n\tif (x instanceof SquareRoot) {\n\t\tif (x.isRational()) {\n\t\t\tx = x.coeff;\n\t\t}\n\t}\n\tif (x.isEqualTo(0)) {\n\t\treturn new Angle(0, { domain: 'all' });\n\t}\n\tif (x instanceof Fraction) {\n\t\tif (x.abs().isEqualTo(1)) {\n\t\t\treturn x.isGreaterThan(0) ? new Angle(45, { domain: 'all' }) : new Angle(-45, { domain: 'all' });\n\t\t}\n\t} else {\n\t\tif (x.abs().isEqualTo(new SquareRoot(3))) {\n\t\t\treturn x.coeff.isGreaterThan(0) ? new Angle(60, { domain: 'all' }) : new Angle(-60, { domain: 'all' });\n\t\t} else if (x.abs().isEqualTo(new SquareRoot(3, third))) {\n\t\t\treturn x.coeff.isGreaterThan(0) ? new Angle(30, { domain: 'all' }) : new Angle(-30, { domain: 'all' });\n\t\t}\n\t}\n\tthrow new Error(`${x} atan function only valid for special ratios`);\n}\n","import { Fraction, Imaginary, Expression, numberToFraction, SquareRoot, Term, VariableTerm } from '../core';\nimport { Complex } from './complexClass';\n\n/**\n * xComplex class representing x + yi\n * where x,y can be expressions\n */\nexport class xComplex extends Expression {\n\t/** real part of the complex number */\n\treal: Expression;\n\t/** imaginary part of the complex number */\n\timag: Expression;\n\n\t/**\n\t * Creates a new Complex instance\n\t */\n\tconstructor(\n\t\treal: number | Fraction | string | SquareRoot | Term | Expression,\n\t\timag: number | Fraction | string | SquareRoot | Term | Expression = 0,\n\t) {\n\t\treal = real instanceof Expression ? real.clone() : new Expression(real);\n\t\timag = imag instanceof Expression ? imag.clone() : new Expression(imag);\n\t\tsuper(...real.terms, ...imag.times('i').terms);\n\t\tthis.real = real;\n\t\tthis.imag = imag;\n\t}\n\n\t/**\n\t * adds two complex numbers\n\t */\n\tplus(z: number | Fraction | Complex | xComplex): xComplex {\n\t\tif (z instanceof xComplex || z instanceof Complex) {\n\t\t\treturn new xComplex(this.real.plus(z.real), this.imag.plus(z.imag));\n\t\t}\n\t\treturn new xComplex(this.real.plus(z), this.imag);\n\t}\n\t/**\n\t * negative of this complex number\n\t */\n\tnegative(): xComplex {\n\t\treturn new xComplex(this.real.negative(), this.imag.negative());\n\t}\n\t/**\n\t * complex number subtraction\n\t */\n\tminus(z: number | Fraction | Complex | xComplex): xComplex {\n\t\tif (typeof z === 'number') {\n\t\t\treturn this.plus(new xComplex(-z, 0));\n\t\t}\n\t\treturn this.plus(z.negative());\n\t}\n\t/**\n\t * complex number multiplication\n\t */\n\ttimes(z: number | Fraction | Complex | xComplex): xComplex {\n\t\tif (z instanceof xComplex || z instanceof Complex) {\n\t\t\treturn new xComplex(\n\t\t\t\tthis.real.times(z.real).minus(this.imag.times(z.imag)),\n\t\t\t\tthis.real.times(z.imag).plus(this.imag.times(z.real)),\n\t\t\t);\n\t\t}\n\t\treturn new xComplex(this.real.times(z), this.imag.times(z));\n\t}\n\t/**\n\t * complex conjugation\n\t */\n\tconjugate(): xComplex {\n\t\treturn new xComplex(this.real, this.imag.negative());\n\t}\n\t/**\n\t * r^2 = |z|^2\n\t */\n\trSquared(): Expression {\n\t\treturn this.times(this.conjugate()).real.clone();\n\t}\n\t/**\n\t * z^n\n\t */\n\tpow(n: number): xComplex {\n\t\tif (!Number.isInteger(n) || n < 0) {\n\t\t\tthrow new Error(`invalid exponent ${n}: only non-negative integers supported`);\n\t\t}\n\t\tlet result = new xComplex(1, 0);\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tresult = result.times(this);\n\t\t}\n\t\treturn result;\n\t}\n\t/**\n\t * z^2\n\t */\n\tsquare(): xComplex {\n\t\treturn this.times(this);\n\t}\n\tclone(): xComplex {\n\t\treturn new xComplex(this.real, this.imag);\n\t}\n}\n","export { expToCartesian } from './expToCartesian';\nexport { complexToQuadratic } from './complexToQuadratic';\nexport { subComplexIntoPoly } from './subInComplex';\n","import { ComplexExp } from '../complexExpClass';\nimport { xComplex } from '../extendedComplexClass';\nimport { cos, sin } from '../../trigo';\n\nexport function expToCartesian(z: ComplexExp): xComplex {\n\treturn new xComplex(cos(z.arg).times(z.mod), sin(z.arg).times(z.mod));\n}\n","import { Polynomial } from '../../core';\nimport { Complex } from '../complexClass';\n\nexport function complexToQuadratic(z: Complex, options?: { variable?: string }): Polynomial {\n\tconst { variable } = {\n\t\tvariable: 'z',\n\t\t...options,\n\t};\n\treturn new Polynomial([1, z.real.times(-2), z.rSquared()], { variable });\n}\n","import { Complex } from '../complexClass';\nimport { Polynomial } from '../../core';\n\nexport function subComplexIntoPoly(z: Complex, poly: Polynomial): Complex {\n\treturn poly.coeffs.reduce((sum, coeff, i) => {\n\t\treturn sum.plus(z.pow(i).times(coeff));\n\t}, new Complex(0, 0));\n}\n","import { Polynomial } from '../core';\n\n/**\n * given p(x)/d(x),\n *\n * @returns {quotient, remainder}\n */\nexport function longDivide(\n\tpoly: Polynomial,\n\tdivisor: Polynomial,\n\tcarryOver?: Polynomial,\n): { quotient: Polynomial; remainder: Polynomial } {\n\tcarryOver = carryOver || new Polynomial([0], { ascending: poly.ascending, variable: poly.variable });\n\tif (divisor.degree === 0) {\n\t\tthrow new Error(`Divisor ${divisor} must have degree > 0`);\n\t}\n\tif (poly.degree < divisor.degree) {\n\t\treturn { quotient: carryOver, remainder: poly };\n\t}\n\tconst a = poly.coeffs[poly.coeffs.length - 1];\n\tconst b = divisor.coeffs[divisor.coeffs.length - 1];\n\tconst ax = new Polynomial([a], { degree: poly.degree, variable: poly.variable });\n\treturn longDivide(\n\t\tpoly.minus(\n\t\t\tdivisor\n\t\t\t\t.divide(b)\n\t\t\t\t.times(a)\n\t\t\t\t.times(new Polynomial([1], { degree: poly.degree - divisor.degree })),\n\t\t),\n\t\tdivisor,\n\t\tcarryOver.plus(new Polynomial([a.divide(b)], { degree: poly.degree - divisor.degree, variable: poly.variable })),\n\t);\n}\n","import { Fraction, numberToFraction, Polynomial } from '../core';\n\n/**\n *\n * @param options pt: [x1,y1] point on the line. Use gradient m (priority) if provided, otherwise uses pt2 to form the line\n */\nexport function linear(options: {\n\tm?: number | Fraction;\n\tpt: [number | Fraction, number | Fraction];\n\tpt2?: [number | Fraction, number | Fraction];\n}): Polynomial {\n\tconst { m, pt, pt2 } = options;\n\tif (m !== undefined) {\n\t\tconst mFrac = numberToFraction(m);\n\t\tconst c = mFrac.times(pt[0]).negative().plus(pt[1]); // y = mx + c; c = y-mx\n\t\treturn new Polynomial([mFrac, c]);\n\t}\n\tif (pt2 !== undefined) {\n\t\tconst x2 = numberToFraction(pt2[0]);\n\t\tconst y2 = numberToFraction(pt2[1]);\n\t\tconst [x1, y1] = pt;\n\t\tif (x2.isEqualTo(x1)) {\n\t\t\tthrow new Error(`x coordinates are the same ${x1}: vertical lines are not supported`);\n\t\t}\n\t\tconst m = x2.minus(x1).reciprocal().times(y2.minus(y1)); // m = (y2-y1)/(x2-x1)\n\t\tconst c = m.times(x1).negative().plus(y1);\n\t\treturn new Polynomial([m, c]);\n\t}\n\tthrow new Error(`either gradient m or second point pt2 must be provided.`);\n}\n","import { Polynomial, SquareRoot, Expression, Fraction } from '../core';\n\nexport function subSurdInPoly(poly: Polynomial, x: SquareRoot): Expression {\n\tlet surd = new SquareRoot(x.radicand, 0);\n\tlet num = new Fraction(0);\n\tpoly.coeffs.forEach((coeff, i) => {\n\t\tconst term = x.pow(i).times(coeff);\n\t\tif (term.isRational()) {\n\t\t\tnum = num.plus(term.coeff);\n\t\t} else {\n\t\t\tsurd = surd.plus(term);\n\t\t}\n\t});\n\treturn new Expression(surd, num);\n}\n","import { Rational } from './rationalClass';\nimport { solveQuadratic, solveLinear } from '../polynomialMethods';\nimport { Fraction, Polynomial } from '../core';\n\n/**\n * solves a rational inequality lhs < rhs\n * @param rhs defaults to `0`\n * @param options defaults to `{lessThan: true, equality: false}`\n *\n * only works for square free polynomials of degree at most 2\n */\nexport function solveRational(\n\tlhs: Rational,\n\trhs: number | Fraction | Polynomial | Rational = 0,\n\toptions?: { lessThan?: boolean; equality?: boolean },\n): {\n\tcombinedAnswer: string;\n\tintervals: string[];\n\tvalues: Fraction[];\n} {\n\tconst values: Fraction[] = [];\n\tconst intervals: string[] = [];\n\tlet combinedAnswer: string;\n\t// set up inequality\n\tlet rational = lhs.minus(rhs);\n\tconst x = rational.num.variable;\n\tconst equality = options?.equality ?? false;\n\tlet lessThan = options?.lessThan ?? true;\n\tif (\n\t\trational.num.coeffs[rational.num.coeffs.length - 1]\n\t\t\t.times(rational.den.coeffs[rational.den.coeffs.length - 1])\n\t\t\t.isLessThan(0)\n\t) {\n\t\trational = rational.negative();\n\t\tlessThan = !lessThan;\n\t}\n\t// zeros\n\tif (rational.num.degree === 1) {\n\t\tvalues.push(solveLinear(rational.num));\n\t} else if (rational.num.degree === 2) {\n\t\tconst roots = solveQuadratic(rational.num);\n\t\tif (roots[0] instanceof Fraction) {\n\t\t\tvalues.push(roots[0], <Fraction>roots[1]);\n\t\t}\n\t} else if (rational.num.degree > 2) {\n\t\tthrow new Error(`numerator of degree more than 2 not supported ${rational.num}`);\n\t}\n\t// poles\n\tvalues.push(...rational.poles);\n\t// sort critical values\n\tvalues.sort((a, b) => a.minus(b).valueOf());\n\tif (values.length === 1) {\n\t\tlet sign: string;\n\t\tif (equality && !rational.den.subIn(values[0]).isEqualTo(0)) {\n\t\t\tsign = lessThan ? '\\\\leq' : '\\\\geq';\n\t\t} else {\n\t\t\tsign = lessThan ? '<' : '>';\n\t\t}\n\t\tintervals.push(`${x} ${sign} ${values[0]}`);\n\t\tcombinedAnswer = `${intervals[0]}.`;\n\t} else if (values.length === 2) {\n\t\tif (lessThan) {\n\t\t\tconst sign1 = !equality || rational.den.subIn(values[0]).isEqualTo(0) ? '<' : '\\\\leq';\n\t\t\tconst sign2 = !equality || rational.den.subIn(values[1]).isEqualTo(0) ? '<' : '\\\\leq';\n\t\t\tintervals.push(`${values[0]} ${sign1} ${x} ${sign2} ${values[1]}`);\n\t\t\tcombinedAnswer = `${intervals[0]}.`;\n\t\t} else {\n\t\t\tconst sign1 = !equality || rational.den.subIn(values[0]).isEqualTo(0) ? '<' : '\\\\leq';\n\t\t\tconst sign2 = !equality || rational.den.subIn(values[1]).isEqualTo(0) ? '>' : '\\\\geq';\n\t\t\tintervals.push(`${x} ${sign1} ${values[0]}`, `${x} ${sign2} ${values[1]}`);\n\t\t\tcombinedAnswer = `{${intervals[0]}} \\allowbreak \\\\textrm{ or } {${intervals[1]}.}`;\n\t\t}\n\t} else if (values.length === 3) {\n\t\tif (lessThan) {\n\t\t\tconst sign1 = !equality || rational.den.subIn(values[0]).isEqualTo(0) ? '<' : '\\\\leq';\n\t\t\tconst sign2 = !equality || rational.den.subIn(values[1]).isEqualTo(0) ? '<' : '\\\\leq';\n\t\t\tconst sign3 = !equality || rational.den.subIn(values[2]).isEqualTo(0) ? '<' : '\\\\leq';\n\t\t\tintervals.push(`${x} ${sign1} ${values[0]}`, `${values[1]} ${sign2} ${x} ${sign3} ${values[2]}`);\n\t\t\tcombinedAnswer = `{${intervals[0]}} \\\\allowbreak \\\\textrm{ or } {${intervals[1]}.}`;\n\t\t} else {\n\t\t\tconst sign1 = !equality || rational.den.subIn(values[0]).isEqualTo(0) ? '<' : '\\\\leq';\n\t\t\tconst sign2 = !equality || rational.den.subIn(values[1]).isEqualTo(0) ? '<' : '\\\\leq';\n\t\t\tconst sign3 = !equality || rational.den.subIn(values[2]).isEqualTo(0) ? '>' : '\\\\geq';\n\t\t\tintervals.push(`${values[0]} ${sign1} ${x} ${sign2} ${values[1]}`, `${x} ${sign3} ${values[2]}`);\n\t\t\tcombinedAnswer = `{${intervals[0]}} \\\\allowbreak \\\\textrm{ or } {${intervals[1]}.}`;\n\t\t}\n\t} else if (values.length === 4) {\n\t\tif (lessThan) {\n\t\t\tconst sign1 = !equality || rational.den.subIn(values[0]).isEqualTo(0) ? '<' : '\\\\leq';\n\t\t\tconst sign2 = !equality || rational.den.subIn(values[1]).isEqualTo(0) ? '<' : '\\\\leq';\n\t\t\tconst sign3 = !equality || rational.den.subIn(values[2]).isEqualTo(0) ? '<' : '\\\\leq';\n\t\t\tconst sign4 = !equality || rational.den.subIn(values[3]).isEqualTo(0) ? '<' : '\\\\leq';\n\t\t\tintervals.push(\n\t\t\t\t`${values[0]} ${sign1} ${x} ${sign2} ${values[1]}`,\n\t\t\t\t`${values[2]} ${sign3} ${x} ${sign4} ${values[3]}`,\n\t\t\t);\n\t\t\tcombinedAnswer = `{${intervals[0]}} \\\\allowbreak \\\\textrm{ or } {${intervals[1]}.}`;\n\t\t} else {\n\t\t\tconst sign1 = !equality || rational.den.subIn(values[0]).isEqualTo(0) ? '<' : '\\\\leq';\n\t\t\tconst sign2 = !equality || rational.den.subIn(values[1]).isEqualTo(0) ? '<' : '\\\\leq';\n\t\t\tconst sign3 = !equality || rational.den.subIn(values[2]).isEqualTo(0) ? '<' : '\\\\leq';\n\t\t\tconst sign4 = !equality || rational.den.subIn(values[3]).isEqualTo(0) ? '>' : '\\\\geq';\n\t\t\tintervals.push(\n\t\t\t\t`${x} ${sign1} ${values[0]}`,\n\t\t\t\t`${values[1]} ${sign2} ${x} ${sign3} ${values[2]}`,\n\t\t\t\t`${x} ${sign4} ${values[3]}`,\n\t\t\t);\n\t\t\tcombinedAnswer = `{${intervals[0]},} \\\\; \\\\allowbreak {${intervals[1]}} \\\\allowbreak \\\\textrm{ or } {${intervals[2]}.}`;\n\t\t}\n\t} else {\n\t\tthrow new Error(`we currently do not support this inequality with critical values ${values}`);\n\t}\n\treturn {\n\t\tcombinedAnswer,\n\t\tintervals,\n\t\tvalues,\n\t};\n}\n","/**\n * applies cover-up rule (only applicable for linear functions)\n *\n * @returns an array of Rational functions\n */\n\nimport { Polynomial, Fraction } from '../core';\nimport { Rational } from './rationalClass';\nimport { solveLinear, factorizeQuadratic } from '../polynomialMethods';\n\nexport function partialFractions(\n\tdenominators: Polynomial | Polynomial[],\n\toptions?: { numerators?: number | Fraction | Polynomial | (number | Fraction | Polynomial)[] },\n): Rational[] {\n\t// make denominators Array\n\tlet unknown: string;\n\tif (!Array.isArray(denominators)) {\n\t\tif (denominators.degree === 1) {\n\t\t\tdenominators = [denominators];\n\t\t} else if (denominators.degree === 2) {\n\t\t\tconst [linear1, linear2] = factorizeQuadratic(denominators);\n\t\t\tdenominators = [linear1, linear2];\n\t\t} else {\n\t\t\tthrow new Error(`only linear or quadratic denominators are supported. ${denominators} received.`);\n\t\t}\n\t}\n\tunknown = denominators[0].variable;\n\t// make numerators Array\n\tconst { numerators: numeratorsProvided } = {\n\t\tnumerators: 1,\n\t\t...options,\n\t};\n\tlet numerators: Polynomial[];\n\tif (Array.isArray(numeratorsProvided)) {\n\t\tnumerators = numeratorsProvided.map((x) => toPolynomial(x));\n\t} else {\n\t\tnumerators = [toPolynomial(numeratorsProvided)];\n\t}\n\t// throws is not proper\n\tif (numerators.length >= denominators.length) {\n\t\tthrow new Error(`partial fractions failure: improper fraction detected`);\n\t}\n\t// iterate over denominator\n\treturn denominators.map((x, i) => {\n\t\tconst denArray = denominators as Polynomial[];\n\t\tconst root = solveLinear(x);\n\t\tconst remainingDenominators = denArray.filter((_, j) => i !== j);\n\t\tconst den = remainingDenominators.reduce((prev, curr) => prev.times(curr.subIn(root)), new Fraction(1));\n\t\tconst num = numerators.reduce((prev, curr) => prev.times(curr.subIn(root)), new Fraction(1));\n\t\tconst A = num.divide(den);\n\t\treturn new Rational(A.num, x.times(A.den));\n\t});\n}\n\nfunction toPolynomial(x: number | Fraction | Polynomial, unknown = 'x') {\n\tif (typeof x === 'number') {\n\t\tx = new Polynomial([x], { variable: unknown });\n\t} else if (x instanceof Fraction) {\n\t\tx = new Polynomial([x.den, -x.num], { variable: unknown });\n\t}\n\treturn x;\n}\n","import { Fraction, Expression, numberToFraction, Term, Polynomial } from '../core';\n\n/**\n * Polynomial class representing \"ax^n + bx^n-1 + ... + k\"\n */\nexport class xPolynomial extends Expression {\n\t/** array of coefficients in ascending order, starting from constant term */\n\tcoeffs: Expression[];\n\t/** whether polynomial in ascending or descending order */\n\tascending: boolean;\n\t/** degree of the polynomial */\n\tdegree: number;\n\t/** variable name (e.g. \"x\") */\n\tvariable: string;\n\n\t/**\n\t * Creates a new Polynomial instance\n\t * @param coeffs array of coefficients. if a number/fraction is provided, will create the polynomial \"kx\".\n\t * @param options defaults to `{ascending: false, degree: coeffs.length-1, variable: 'x'}`\n\t */\n\tconstructor(\n\t\tcoeffs: (number | Fraction | string | Expression)[] | (number | Fraction),\n\t\toptions?: { ascending?: boolean; degree?: number; variable?: string },\n\t) {\n\t\tif (!Array.isArray(coeffs)) {\n\t\t\tcoeffs = options?.ascending ? [0, coeffs] : [coeffs, 0];\n\t\t}\n\t\tconst { variable, ascending, degree } = {\n\t\t\tascending: false,\n\t\t\tdegree: coeffs.length - 1,\n\t\t\tvariable: 'x',\n\t\t\t...options,\n\t\t};\n\t\tif (degree < 0 || degree < coeffs.length - 1) {\n\t\t\tthrow new RangeError('degree must be greater than coefficients.length-1');\n\t\t}\n\t\t// reverse coefficient array if descending order\n\t\tif (!ascending) {\n\t\t\tcoeffs = [...coeffs].reverse();\n\t\t}\n\t\t// add extra zeros to start from constant term\n\t\tif (degree > coeffs.length - 1) {\n\t\t\tconst extraCoeffLength = degree - coeffs.length + 1;\n\t\t\tcoeffs = [...createZeroArray(extraCoeffLength), ...coeffs];\n\t\t}\n\t\t// convert to Fraction type\n\t\tlet coeffsFrac = coeffs.map(toExpression);\n\t\t// remove unnecessary terms (leading coefficients should be non-zero, unless it is a constant polynomial)\n\t\twhile (`${coeffsFrac[coeffsFrac.length - 1]}` === '0' && coeffsFrac.length > 1) {\n\t\t\tcoeffsFrac.pop();\n\t\t}\n\t\t// generate unknown terms\n\t\tconst polynomialTerms = coeffsFrac.map((coeff, n) => {\n\t\t\treturn coeff.times(new Term(variable, n));\n\t\t});\n\t\t// descending order typesetting if necessary;\n\t\tif (!ascending) {\n\t\t\tpolynomialTerms.reverse();\n\t\t}\n\t\tconst polynomialExpressions: Expression[] = [...polynomialTerms];\n\t\tlet terms: Term[] = [];\n\t\tpolynomialExpressions.forEach((e) => {\n\t\t\tterms.push(...e.terms);\n\t\t});\n\t\tsuper(...terms);\n\t\tthis.coeffs = coeffsFrac;\n\t\tthis.degree = coeffsFrac.length - 1;\n\t\tthis.variable = variable;\n\t\tthis.ascending = ascending;\n\t}\n\n\t/** add two polynomials\n\t *\n\t * fraction/numbers will be converted a \"constant polynomial\", while a string will be converted to a polynomial term with coefficient 1\n\t */\n\tplus(p2: number | Fraction | string | Polynomial | xPolynomial | Expression): xPolynomial {\n\t\tconst p2x = toXPolynomial(p2);\n\t\tconst [higherPoly, lowerPoly] = this.degree >= p2x.degree ? [this, p2x] : [p2x, this];\n\t\tconst newCoeffs = higherPoly.coeffs.map((thisCoeff, i) => {\n\t\t\tif (lowerPoly.coeffs[i] === undefined) {\n\t\t\t\treturn thisCoeff;\n\t\t\t} else {\n\t\t\t\treturn thisCoeff.plus(lowerPoly.coeffs[i]);\n\t\t\t}\n\t\t});\n\t\tif (!this.ascending) {\n\t\t\tnewCoeffs.reverse();\n\t\t}\n\t\treturn new xPolynomial(newCoeffs, { variable: this.variable, ascending: this.ascending });\n\t}\n\n\t/** multiplies two polynomials */\n\ttimes(p2: number | Fraction | string | Polynomial | xPolynomial | Expression): xPolynomial {\n\t\tconst p2x = toXPolynomial(p2);\n\t\tconst degree = this.degree + p2x.degree;\n\t\tconst coeffs = createZeroArray(degree + 1);\n\t\tfor (let i = 0; i < this.coeffs.length; i++) {\n\t\t\tfor (let j = 0; j < p2x.coeffs.length; j++) {\n\t\t\t\tcoeffs[i + j] = coeffs[i + j].plus(this.coeffs[i].times(p2x.coeffs[j]));\n\t\t\t}\n\t\t}\n\t\tif (!this.ascending) {\n\t\t\tcoeffs.reverse();\n\t\t}\n\t\treturn new xPolynomial(coeffs, { ascending: this.ascending, degree, variable: this.variable });\n\t}\n\n\t/** negative of this polynomial */\n\tnegative(): xPolynomial {\n\t\treturn this.times(-1);\n\t}\n\n\t/**\n\t * divide by a *scalar*\n\t */\n\tdivide(p2: number | Fraction): xPolynomial {\n\t\tp2 = numberToFraction(p2);\n\t\treturn this.times(p2.reciprocal());\n\t}\n\n\t/** subtracts this by p2 */\n\tminus(p2: number | Fraction | string | Polynomial | xPolynomial): xPolynomial {\n\t\tp2 = toXPolynomial(p2);\n\t\treturn this.plus(p2.times(-1));\n\t}\n\n\t/**\n\t * exponentiation\n\t * @returns this polynomial taken to a power of `n`\n\t */\n\tpow(n: number): xPolynomial {\n\t\tif (!(Number.isInteger(n) && n >= 0)) {\n\t\t\tthrow new RangeError(`only non-negative integers allowed for n (${n} received)`);\n\t\t}\n\t\tlet newPoly = new xPolynomial([1], { variable: this.variable, ascending: this.ascending });\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tnewPoly = newPoly.times(this);\n\t\t}\n\t\treturn newPoly;\n\t}\n\n\t/**\n\t * replace x with a new polynomial\n\t * @param x if string, replaces the unknown\n\t */\n\treplaceXWith(x: string | Polynomial | xPolynomial): xPolynomial {\n\t\tconst xPoly = typeof x === 'string' ? new xPolynomial([1, 0], { variable: x }) : toXPolynomial(x);\n\t\tlet poly = new xPolynomial([0], { ascending: this.ascending, variable: this.variable });\n\t\tthis.coeffs.forEach((coeff, i) => {\n\t\t\tpoly = poly.plus(xPoly.pow(i).times(coeff));\n\t\t});\n\t\treturn poly;\n\t}\n\n\t/**\n\t * square\n\t *\n\t * @returns the square of this polynomial\n\t *  */\n\tsquare(): xPolynomial {\n\t\treturn this.pow(2);\n\t}\n\n\t/**\n\t * @returns an ascending polynomial only up until degree n\n\t */\n\tconcatenate(n: number): xPolynomial {\n\t\tconst coeffs = this.coeffs.slice(0, n + 1);\n\t\treturn new xPolynomial(coeffs, { ascending: this.ascending, variable: this.variable });\n\t}\n\n\t/**\n\t * changes ascending/behavior of polynomial\n\t *\n\t * @param ascending sets ascending behavior. By default, this\n\t * option is set to toggle current ascending/descending behavior\n\t *\n\t * @returns a reference to this polynomial instance\n\t *\n\t * WARNING: mutates current instance\n\t */\n\tchangeAscending(ascending = !this.ascending): this {\n\t\tif (this.ascending === ascending) {\n\t\t\treturn this;\n\t\t}\n\t\tthis.terms.reverse();\n\t\tthis.ascending = ascending;\n\t\treturn this;\n\t}\n\n\t/** derivative of the polynomial */\n\tdifferentiate(): xPolynomial {\n\t\tif (this.degree === 0) {\n\t\t\treturn new xPolynomial([0]);\n\t\t}\n\t\tconst newCoeffs = this.coeffs.map((coeff, i) => coeff.times(i)).slice(1);\n\t\tconst newPoly = new xPolynomial(newCoeffs, { ascending: true, variable: this.variable });\n\t\treturn this.ascending ? newPoly : newPoly.changeAscending();\n\t}\n\n\t///** integral of the polynomial\n\t// * @param options `{c, x1, y1}` where we can put in the integration constant c (defaults to 0),\n\t// * or a point on the curve (x1, y1).\n\t// */\n\t//integrate(options?: { c?: number | Fraction; x1?: number | Fraction; y1?: number | Fraction }): xPolynomial {\n\t//\tif (this.degree === 0) {\n\t//\t\treturn new xPolynomial([0]);\n\t//\t}\n\t//\tconst newCoeffs = [0, ...this.coeffs.map((coeff, i) => coeff.divide(i + 1))];\n\t//\tconst newPoly = new Polynomial(newCoeffs, { ascending: true, variable: this.variable });\n\t//\tconst { x1, y1 } = {\n\t//\t\t...options,\n\t//\t};\n\t//\tlet c = options?.c ?? 0;\n\t//\tif (x1 !== undefined && y1 !== undefined) {\n\t//\t\tc = newPoly.subIn(x1).negative().plus(y1);\n\t//\t}\n\t//\tconst polyWithC = newPoly.plus(c);\n\t//\treturn this.ascending ? polyWithC : polyWithC.changeAscending();\n\t//}\n\n\t/** checks if two polynomials are equal: i.e., coefficient array is the same and same unknown */\n\tisEqualTo(poly2: xPolynomial): boolean {\n\t\tif (this.variable === poly2.variable) {\n\t\t\tif (this.coeffs.length === poly2.coeffs.length) {\n\t\t\t\tlet valid = true;\n\t\t\t\tthis.coeffs.forEach((coeff, i) => {\n\t\t\t\t\tif (!(`${coeff}` === `${poly2.coeffs[i]}`)) {\n\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn valid;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/** clones this polynomial */\n\tclone(): xPolynomial {\n\t\tconst coeffs = [...this.coeffs];\n\t\tif (!this.ascending) {\n\t\t\t// coeffs in ascending by default\n\t\t\tcoeffs.reverse();\n\t\t}\n\t\treturn new xPolynomial(coeffs, { ascending: this.ascending, degree: this.degree, variable: this.variable });\n\t}\n\n\t//\t/**\n\t//\t * toJSON method that allows for quick reconstruction of class instance\n\t//\t * by storing its constructor arguments\n\t//\t */\n\t//\ttoJSON(): { type: string; args: [Fraction[], { ascending: boolean; degree: number; unknown: string }] } {\n\t//\t\tconst coeffs = this.coeffs.map((e) => e.clone());\n\t//\t\tif (!this.ascending) {\n\t//\t\t\tcoeffs.reverse();\n\t//\t\t}\n\t//\t\treturn {\n\t//\t\t\ttype: 'polynomial',\n\t//\t\t\targs: [coeffs, { ascending: this.ascending, degree: this.degree, unknown: this.unknown }],\n\t//\t\t};\n\t//\t}\n}\n\nfunction createZeroArray(n: number): Expression[] {\n\tlet zeroArray: Expression[] = [];\n\tfor (let i = 0; i < n; i++) {\n\t\tzeroArray.push(new Expression(0));\n\t}\n\treturn zeroArray;\n}\n\nfunction toXPolynomial(p2: number | Fraction | string | Polynomial | xPolynomial | Expression): xPolynomial {\n\tif (p2 instanceof xPolynomial) {\n\t\treturn p2;\n\t}\n\tif (p2 instanceof Polynomial) {\n\t\tconst newXPoly = new xPolynomial(p2.coeffs, { ascending: true, variable: p2.variable });\n\t\treturn p2.ascending ? newXPoly : newXPoly.changeAscending();\n\t}\n\treturn new xPolynomial([p2]);\n}\n\nfunction toExpression(x: number | Fraction | string | Expression) {\n\tif (x instanceof Expression) {\n\t\treturn x;\n\t}\n\treturn new Expression(x);\n}\n","import { Expression, Polynomial, Fraction, Term, numberToFraction, SquareRoot } from '../../core';\n\n/**\n * representation of a series including negative exponents\n *\n * a_{-m} x^{-m} + ... + a0 + a1 x + ... + a_n x^n\n *\n * we store them as `negCoeffs: [a_{-1}, a_{-2}, ..., a_{-m}]`\n * and `a0 + ... + a_n x^n` as poly\n */\nexport class Laurent extends Expression {\n\tpoly: Polynomial;\n\tnegCoeffs: Fraction[];\n\n\t/**\n\t * @param negCoeffs [a_{-1}, ... a_{-m}]\n\t */\n\tconstructor(poly: Polynomial | (number | Fraction)[], negCoeffs: (number | Fraction)[]) {\n\t\tif (Array.isArray(poly)) {\n\t\t\tpoly = new Polynomial(poly);\n\t\t}\n\t\tconst x = poly.variable;\n\t\tconst negCoeffsFrac = negCoeffs.map((x) => numberToFraction(x));\n\t\twhile (negCoeffsFrac.at(-1)?.isEqualTo(0)) {\n\t\t\tnegCoeffsFrac.pop();\n\t\t}\n\t\tconst negativeTerms: Term[] = [];\n\t\tnegCoeffsFrac.forEach((coeff, i) => {\n\t\t\tconst sign = coeff.sign();\n\t\t\tconst xPower = i === 0 ? x : `x^{${i + 1}}`;\n\t\t\tconst xPowerTerm = new Term(coeff.den, xPower);\n\t\t\tnegativeTerms.push(new Term(sign, `\\\\frac{${coeff.abs().num}}{${xPowerTerm}}`));\n\t\t});\n\t\tsuper(...poly.terms, ...negativeTerms);\n\t\tthis.poly = poly;\n\t\tthis.negCoeffs = negCoeffsFrac;\n\t}\n\n\tdifferentiate(): Laurent {\n\t\tconst newNegCoeffs = this.negCoeffs.map((a, i) => a.times(-i - 1));\n\t\treturn new Laurent(this.poly.differentiate(), [0, ...newNegCoeffs]);\n\t}\n\n\tmultiplyDenom(): Polynomial {\n\t\tconst powerDen = this.negCoeffs.length;\n\t\tconst poly = this.poly.times(new Polynomial([1], { degree: powerDen }));\n\t\tconst poly2 = new Polynomial(this.negCoeffs);\n\t\treturn poly.plus(poly2);\n\t}\n\n\tsubIn(x: number | Fraction): Fraction {\n\t\tlet result = this.poly.subIn(x);\n\t\tconst xFrac = numberToFraction(x);\n\t\tthis.negCoeffs.forEach((a, i) => {\n\t\t\tresult = result.plus(a.divide(xFrac.pow(i + 1)));\n\t\t});\n\t\treturn result;\n\t}\n\tsubInSurd(x: SquareRoot): Expression {\n\t\tconst surds: SquareRoot[] = [];\n\t\tconst polyTerms = this.poly.subInSurd(x).terms;\n\t\t//this.poly.coeffs.forEach((a, i) => {\n\t\t//\tsurds.push(x.pow(i).times(a));\n\t\t//});\n\t\tthis.negCoeffs.forEach((a, i) => {\n\t\t\tsurds.push(new SquareRoot(1, a).divide(x.pow(i + 1)));\n\t\t});\n\t\treturn new Expression(...polyTerms, ...surds);\n\t}\n\t/**\n\t * toJSON method that allows for quick reconstruction of class instance\n\t * by storing its constructor arguments\n\t */\n\ttoJSON(): { type: 'laurent'; args: [Polynomial, Fraction[]] } {\n\t\treturn {\n\t\t\ttype: 'laurent',\n\t\t\targs: [this.poly.clone(), this.negCoeffs.map((x) => x.clone())],\n\t\t};\n\t}\n}\n","import { Polynomial } from '../core';\nimport { PowerFn, CosFn, SinFn } from './classes/classes';\n\n/**\n * Parametric Eqn class\n */\nexport class Parametric {\n\tx: Polynomial | PowerFn | CosFn | SinFn;\n\ty: Polynomial | PowerFn | CosFn | SinFn;\n\n\tconstructor(x: Polynomial | PowerFn | CosFn | SinFn, y: Polynomial | PowerFn | CosFn | SinFn) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\t/**\n\t * the derivative dydx\n\t * @return `{num, den, string}`\n\t */\n\tdydx(): string {\n\t\tconst dydt = this.y instanceof PowerFn ? this.y.differentiate().string : `${this.y.differentiate()}`;\n\t\tconst dxdt = this.x instanceof PowerFn ? this.x.differentiate().string : `${this.x.differentiate()}`;\n\t\treturn `\\\\frac{${dydt}}{${dxdt}}`;\n\t}\n}\n","import { Rational } from '../algebra';\nimport { PowerFn } from './classes/classes';\n\nexport function rationalToPowerFn(rational: Rational): PowerFn {\n\tif (rational.num.degree > 0) {\n\t\tthrow new Error(`only constant numerators supported ${rational}`);\n\t}\n\tif (rational.den.degree === 1) {\n\t\t// make monic to prepare for integration\n\t\tconst leadingCoeff = rational.den.coeffs[1].abs();\n\t\trational = new Rational(rational.num.divide(leadingCoeff), rational.den.divide(leadingCoeff));\n\t}\n\treturn new PowerFn(-1, { fx: rational.den, coeff: rational.num.coeffs[0] });\n}\n","import { trigo, trigoD } from './trigo';\nimport { mf26 } from './mf26';\nimport { byParts, byPartsD } from './byParts';\nimport type { Angle } from '../../trigo';\nimport type { Fraction, Expression } from '../../core';\n\nexport const integrate = {\n\t/** trigo integrations */\n\ttrigo,\n\t/** by parts integrations */\n\tbyParts,\n\t/** integration of 1/(x^2 \\\\pm a^2) or 1/sqrt(x^2 \\\\pm a^2) */\n\tmf26,\n};\n\nexport const definiteIntegral: {\n\ttrigo: {\n\t\tcos2: (\n\t\t\tlower: number | Fraction | Angle,\n\t\t\tupper: number | Fraction | Angle,\n\t\t\toptions?: {\n\t\t\t\tk?: number | Fraction;\n\t\t\t\tcoeff?: number | Fraction;\n\t\t\t},\n\t\t) => Expression;\n\t\tsin2: (\n\t\t\tlower: number | Fraction | Angle,\n\t\t\tupper: number | Fraction | Angle,\n\t\t\toptions?: {\n\t\t\t\tk?: number | Fraction;\n\t\t\t\tcoeff?: number | Fraction;\n\t\t\t},\n\t\t) => Expression;\n\t\tcosCos: (\n\t\t\tA: number | Fraction,\n\t\t\tB: number | Fraction,\n\t\t\tlower: number | Fraction | Angle,\n\t\t\tupper: number | Fraction | Angle,\n\t\t\toptions?: {\n\t\t\t\tcoeff?: number | Fraction;\n\t\t\t},\n\t\t) => Expression;\n\t\tcosSin: (\n\t\t\tA: number | Fraction,\n\t\t\tB: number | Fraction,\n\t\t\tlower: number | Fraction | Angle,\n\t\t\tupper: number | Fraction | Angle,\n\t\t\toptions?: {\n\t\t\t\tcoeff?: number | Fraction;\n\t\t\t},\n\t\t) => Expression;\n\t\tsinCos: (\n\t\t\tA: number | Fraction,\n\t\t\tB: number | Fraction,\n\t\t\tlower: number | Fraction | Angle,\n\t\t\tupper: number | Fraction | Angle,\n\t\t\toptions?: {\n\t\t\t\tcoeff?: number | Fraction;\n\t\t\t},\n\t\t) => Expression;\n\t\tsinSin: (\n\t\t\tA: number | Fraction,\n\t\t\tB: number | Fraction,\n\t\t\tlower: number | Fraction | Angle,\n\t\t\tupper: number | Fraction | Angle,\n\t\t\toptions?: {\n\t\t\t\tcoeff?: number | Fraction;\n\t\t\t},\n\t\t) => Expression;\n\t};\n\tbyParts: typeof byPartsD;\n} = {\n\t/** trigo integrations */\n\ttrigo: trigoD,\n\t/** by parts integrations */\n\tbyParts: byPartsD,\n};\n","// integration of f'(x) form\n// integration of rationals and squares\n// integration of trig (double angle, factor formula)\n// integration by parts\n\nimport { Expression, Term, Fraction, numberToFraction } from '../../core';\nimport { Angle, sin, cos } from '../../trigo';\n\nexport const trigo = {\n\t/** integration of cos^2 (kx) */\n\tcos2: (options?: { k?: number | Fraction; coeff?: number | Fraction; variable?: string }) =>\n\t\tdoubleAngle(true, options),\n\t/** integration of sin^2 (kx) */\n\tsin2: (options?: { k?: number | Fraction; coeff?: number | Fraction; variable?: string }) =>\n\t\tdoubleAngle(false, options),\n\tsinSin: (A: number | Fraction, B: number | Fraction, options?: { variable?: string; coeff?: number | Fraction }) =>\n\t\tfactor('sinSin', A, B, options),\n\tcosCos: (A: number | Fraction, B: number | Fraction, options?: { variable?: string; coeff?: number | Fraction }) =>\n\t\tfactor('cosCos', A, B, options),\n\tsinCos: (A: number | Fraction, B: number | Fraction, options?: { variable?: string; coeff?: number | Fraction }) =>\n\t\tfactor('sinCos', A, B, options),\n\tcosSin: (A: number | Fraction, B: number | Fraction, options?: { variable?: string; coeff?: number | Fraction }) =>\n\t\tfactor('cosSin', A, B, options),\n};\n\nexport const trigoD = {\n\t/** definite integral of cos^2 (kx) */\n\tcos2: (\n\t\tlower: number | Fraction | Angle,\n\t\tupper: number | Fraction | Angle,\n\t\toptions?: { k?: number | Fraction; coeff?: number | Fraction },\n\t) => doubleAngleD(true, lower, upper, options),\n\t/** definite integral of sin^2 (kx) */\n\tsin2: (\n\t\tlower: number | Fraction | Angle,\n\t\tupper: number | Fraction | Angle,\n\t\toptions?: { k?: number | Fraction; coeff?: number | Fraction },\n\t) => doubleAngleD(false, lower, upper, options),\n\tsinSin: (\n\t\tA: number | Fraction,\n\t\tB: number | Fraction,\n\t\tlower: number | Fraction | Angle,\n\t\tupper: number | Fraction | Angle,\n\t\toptions?: { coeff?: number | Fraction },\n\t) => factorD('sinSin', A, B, lower, upper, options),\n\tcosCos: (\n\t\tA: number | Fraction,\n\t\tB: number | Fraction,\n\t\tlower: number | Fraction | Angle,\n\t\tupper: number | Fraction | Angle,\n\t\toptions?: { coeff?: number | Fraction },\n\t) => factorD('cosCos', A, B, lower, upper, options),\n\tsinCos: (\n\t\tA: number | Fraction,\n\t\tB: number | Fraction,\n\t\tlower: number | Fraction | Angle,\n\t\tupper: number | Fraction | Angle,\n\t\toptions?: { coeff?: number | Fraction },\n\t) => factorD('sinCos', A, B, lower, upper, options),\n\tcosSin: (\n\t\tA: number | Fraction,\n\t\tB: number | Fraction,\n\t\tlower: number | Fraction | Angle,\n\t\tupper: number | Fraction | Angle,\n\t\toptions?: { coeff?: number | Fraction },\n\t) => factorD('cosSin', A, B, lower, upper, options),\n};\n\n/**\n * integration of coeff cos^2 (kx)\n */\nfunction doubleAngle(\n\tcos: boolean,\n\toptions?: { k?: number | Fraction; coeff?: number | Fraction; variable?: string },\n): Expression {\n\tlet { k, coeff, variable } = {\n\t\tk: 1,\n\t\tcoeff: 1,\n\t\tvariable: 'x',\n\t\t...options,\n\t};\n\tk = numberToFraction(k);\n\tcoeff = numberToFraction(coeff);\n\tconst xOver2 = new Term(new Fraction(1, 2), variable).times(coeff);\n\tconst twoKX = new Term(2, k, variable);\n\tconst sineTwoKX = `\\\\sin ${twoKX}`;\n\tconst sineTerm = new Term(k.reciprocal().divide(4).times(coeff), sineTwoKX);\n\t// x/2 - 1/4k sin (2kx)\n\treturn new Expression(xOver2, cos ? sineTerm : sineTerm.times(-1));\n}\n\n/**\n * definite integration of coeff cos^2 (kx)\n */\nfunction doubleAngleD(\n\tcos: boolean,\n\tlower: number | Fraction | Angle,\n\tupper: number | Fraction | Angle,\n\toptions?: { k?: number | Fraction; coeff?: number | Fraction; variable?: string },\n): Expression {\n\tlet { k, coeff, variable } = {\n\t\tk: 1,\n\t\tcoeff: 1,\n\t\tvariable: 'x',\n\t\t...options,\n\t};\n\tk = numberToFraction(k);\n\tcoeff = numberToFraction(coeff);\n\tlower = lower instanceof Angle ? lower : new Angle(lower, { domain: 'all' });\n\tupper = upper instanceof Angle ? upper : new Angle(upper, { domain: 'all' });\n\tconst xOver2 = upper.minus(lower).divide(2);\n\tconst sineTerm1 = sin(upper.times(2).times(k)).divide(4).divide(k).times(coeff);\n\tconst sineTerm2 = sin(lower.times(2).times(k)).divide(4).divide(k).times(coeff);\n\t// x/2 - 1/4k sin (2kx)\n\treturn new Expression(xOver2, cos ? sineTerm1 : sineTerm1.times(-1), cos ? sineTerm2.times(-1) : sineTerm2);\n}\n\nfunction factor(\n\tmode: 'sinSin' | 'cosCos' | 'sinCos' | 'cosSin',\n\tA: number | Fraction,\n\tB: number | Fraction,\n\toptions?: {\n\t\tvariable?: string;\n\t\tcoeff?: number | Fraction;\n\t},\n): Expression {\n\tA = numberToFraction(A);\n\tB = numberToFraction(B);\n\tconst { variable, coeff: coeffNum } = {\n\t\tvariable: 'x',\n\t\tcoeff: 1,\n\t\t...options,\n\t};\n\tconst coeff = numberToFraction(coeffNum);\n\tconst P = A.plus(B);\n\tconst Q = A.minus(B);\n\tconst Px = new Term(P, variable);\n\tconst Qx = new Term(Q, variable);\n\tlet firstTerm: Term, secondTerm: Term;\n\tif (mode === 'sinSin') {\n\t\t// sin A sin B = 1/2 ( -cos(A+B) + cos(A-B) )\n\t\t// integration gives\n\t\t// -sin(A+B)/2(A+B) + sin(A-B)/2(A-B)\n\t\tfirstTerm = new Term(-1, `\\\\sin ${Px}`).times(P.reciprocal()).times(new Fraction(1, 2));\n\t\tsecondTerm = new Term(`\\\\sin ${Qx}`).times(Q.reciprocal()).times(new Fraction(1, 2));\n\t} else if (mode === 'cosCos') {\n\t\t// cos A cos B = 1/2 ( cos(A+B) + cos(A-B) )\n\t\t// integration gives\n\t\t// sin(A+B)/2(A+B) + sin(A-B)/2(A-B)\n\t\tfirstTerm = new Term(`\\\\sin ${Px}`).times(P.reciprocal()).times(new Fraction(1, 2));\n\t\tsecondTerm = new Term(`\\\\sin ${Qx}`).times(Q.reciprocal()).times(new Fraction(1, 2));\n\t} else if (mode === 'sinCos') {\n\t\t// sin A cos B = 1/2 ( sin(A+B) + sin(A-B) )\n\t\t// integration gives\n\t\t// -cos(A+B)/2(A+B) - cos(A-B)/2(A-B)\n\t\tfirstTerm = new Term(-1, `\\\\cos ${Px}`).times(P.reciprocal()).times(new Fraction(1, 2));\n\t\tsecondTerm = new Term(-1, `\\\\cos ${Qx}`).times(Q.reciprocal()).times(new Fraction(1, 2));\n\t} else if (mode === 'cosSin') {\n\t\t// cos A sin B = 1/2 ( sin(A+B) - sin(A-B) )\n\t\t// integration gives\n\t\t// -cos(A+B)/2(A+B) + cos(A-B)/2(A-B)\n\t\tfirstTerm = new Term(-1, `\\\\cos ${Px}`).times(P.reciprocal()).times(new Fraction(1, 2));\n\t\tsecondTerm = new Term(`\\\\cos ${Qx}`).times(Q.reciprocal()).times(new Fraction(1, 2));\n\t} else {\n\t\tthrow new Error(`invalid mode`);\n\t}\n\treturn new Expression(firstTerm, secondTerm).times(coeff);\n}\n\nfunction factorD(\n\tmode: 'sinSin' | 'cosCos' | 'sinCos' | 'cosSin',\n\tA: number | Fraction,\n\tB: number | Fraction,\n\tlower: number | Fraction | Angle,\n\tupper: number | Fraction | Angle,\n\toptions?: {\n\t\tcoeff?: number | Fraction;\n\t},\n): Expression {\n\tA = numberToFraction(A);\n\tB = numberToFraction(B);\n\tconst { coeff: coeffNum } = {\n\t\tcoeff: 1,\n\t\t...options,\n\t};\n\tconst coeff = numberToFraction(coeffNum);\n\tconst P = A.plus(B);\n\tconst Q = A.minus(B);\n\tlet firstTerm: Term, secondTerm: Term;\n\tlower = lower instanceof Angle ? lower : new Angle(lower, { domain: 'all' });\n\tupper = upper instanceof Angle ? upper : new Angle(upper, { domain: 'all' });\n\tconst angle1Upper = upper.times(P);\n\tconst angle1Lower = lower.times(P);\n\tconst angle2Upper = upper.times(Q);\n\tconst angle2Lower = lower.times(Q);\n\tif (mode === 'sinSin') {\n\t\t// sin A sin B = 1/2 ( -cos(A+B) + cos(A-B) )\n\t\t// integration gives\n\t\t// -sin(A+B)/2(A+B) + sin(A-B)/2(A-B)\n\t\tconst ratio1Upper = sin(angle1Upper);\n\t\tconst term1Upper = ratio1Upper.divide(-2).divide(P);\n\t\tconst ratio1Lower = sin(angle1Lower);\n\t\tconst term1Lower = ratio1Lower.divide(-2).divide(P);\n\t\tconst ratio2Upper = sin(angle2Upper);\n\t\tconst term2Upper = ratio2Upper.divide(2).divide(Q);\n\t\tconst ratio2Lower = sin(angle2Lower);\n\t\tconst term2Lower = ratio2Lower.divide(2).divide(Q);\n\t\treturn new Expression(term1Upper, term2Upper, term1Lower.negative(), term2Lower.negative()).times(coeff);\n\t} else if (mode === 'cosCos') {\n\t\t// cos A cos B = 1/2 ( cos(A+B) + cos(A-B) )\n\t\t// integration gives\n\t\t// sin(A+B)/2(A+B) + sin(A-B)/2(A-B)\n\t\tconst ratio1Upper = sin(angle1Upper);\n\t\tconst term1Upper = ratio1Upper.divide(2).divide(P);\n\t\tconst ratio1Lower = sin(angle1Lower);\n\t\tconst term1Lower = ratio1Lower.divide(2).divide(P);\n\t\tconst ratio2Upper = sin(angle2Upper);\n\t\tconst term2Upper = ratio2Upper.divide(2).divide(Q);\n\t\tconst ratio2Lower = sin(angle2Lower);\n\t\tconst term2Lower = ratio2Lower.divide(2).divide(Q);\n\t\treturn new Expression(term1Upper, term2Upper, term1Lower.negative(), term2Lower.negative()).times(coeff);\n\t} else if (mode === 'sinCos') {\n\t\t// sin A cos B = 1/2 ( sin(A+B) + sin(A-B) )\n\t\t// integration gives\n\t\t// -cos(A+B)/2(A+B) - cos(A-B)/2(A-B)\n\t\tconst ratio1Upper = cos(angle1Upper);\n\t\tconst term1Upper = ratio1Upper.divide(-2).divide(P);\n\t\tconst ratio1Lower = cos(angle1Lower);\n\t\tconst term1Lower = ratio1Lower.divide(-2).divide(P);\n\t\tconst ratio2Upper = cos(angle2Upper);\n\t\tconst term2Upper = ratio2Upper.divide(-2).divide(Q);\n\t\tconst ratio2Lower = cos(angle2Lower);\n\t\tconst term2Lower = ratio2Lower.divide(-2).divide(Q);\n\t\treturn new Expression(term1Upper, term2Upper, term1Lower.negative(), term2Lower.negative()).times(coeff);\n\t} else if (mode === 'cosSin') {\n\t\t// cos A sin B = 1/2 ( sin(A+B) - sin(A-B) )\n\t\t// integration gives\n\t\t// -cos(A+B)/2(A+B) + cos(A-B)/2(A-B)\n\t\tconst ratio1Upper = cos(angle1Upper);\n\t\tconst term1Upper = ratio1Upper.divide(-2).divide(P);\n\t\tconst ratio1Lower = cos(angle1Lower);\n\t\tconst term1Lower = ratio1Lower.divide(-2).divide(P);\n\t\tconst ratio2Upper = cos(angle2Upper);\n\t\tconst term2Upper = ratio2Upper.divide(2).divide(Q);\n\t\tconst ratio2Lower = cos(angle2Lower);\n\t\tconst term2Lower = ratio2Lower.divide(2).divide(Q);\n\t\treturn new Expression(term1Upper, term2Upper, term1Lower.negative(), term2Lower.negative()).times(coeff);\n\t} else {\n\t\tthrow new Error(`invalid mode`);\n\t}\n}\n","import {\n\tlcm,\n\tPolynomial,\n\tFraction,\n\tSquareRoot,\n\tnumberToFraction,\n\tTerm,\n\tnumberToSquareRoot,\n\tExpression,\n} from '../../core';\nimport { completeSquareParams } from '../../polynomialMethods';\nimport { Angle, atan, asin } from '../../trigo';\n\n/**\n * integrates 1/quadratic or 1/sqrt(quadratic)\n * @param options defaults to `{squareRootMode: false, modulus: true, initial: undefined}`.\n * initial only valid for finding particular solution in DE qns for ln qns\n */\nexport function mf26(\n\tquadratic: Polynomial,\n\toptions?: { squareRootMode?: boolean; initial?: number | Fraction; modulus?: boolean; flip?: boolean },\n): ArcFunction | LnFunction {\n\tconst { a, completedSquare, c } = completeSquareParams(quadratic);\n\tconst { squareRootMode, initial, modulus, flip } = {\n\t\tsquareRootMode: false,\n\t\tmodulus: true,\n\t\tflip: false,\n\t\t...options,\n\t};\n\tif (squareRootMode) {\n\t\treturn arcsin(completedSquare, c, { coeff: a });\n\t}\n\tif (a.isGreaterThan(0) && c.isGreaterThan(0)) {\n\t\treturn arctan(completedSquare, c, { coeff: a });\n\t} else if (a.times(c).isLessThan(0)) {\n\t\treturn ln(completedSquare, c, { coeff: a, initial, modulus, flip });\n\t} else {\n\t\tthrow new Error(`1/(-x^2 - a^2) not supported at the moment. Consider trying again after factoring out -1.`);\n\t}\n}\n\n/**\n * integrates 1 / ( coeff (x+b)^2 + a2 )\n * @param x represents x+b\n */\nfunction arctan(x: Polynomial, a2: number | Fraction, options?: { coeff?: number | Fraction }): ArcFunction {\n\tlet { coeff } = {\n\t\tcoeff: 1,\n\t\t...options,\n\t};\n\tcoeff = numberToFraction(coeff);\n\ta2 = numberToFraction(a2).divide(coeff);\n\tconst a = new SquareRoot(a2);\n\tlet xTerm: string;\n\tif (a.isEqualTo(1)) {\n\t\txTerm = `${x}`;\n\t} else {\n\t\tconst x0Coeff = x.coeffs[0];\n\t\tconst multiple = lcm(a.coeff.den, x0Coeff.den);\n\t\tconst aWithoutDen = a.times(multiple);\n\t\tconst xWithoutDen = x.times(multiple);\n\t\txTerm = `\\\\frac{${xWithoutDen}}{${aWithoutDen}}`;\n\t}\n\tconst poly = x;\n\treturn {\n\t\ttoString(): string {\n\t\t\tconst term = a.reciprocal().divide(coeff).times(`\\\\tan^{-1} \\\\left( ${xTerm} \\\\right)`);\n\t\t\treturn `${term}`;\n\t\t},\n\t\tsubIn(x: number | Fraction | SquareRoot): Angle {\n\t\t\tconst b = poly.coeffs[1];\n\t\t\tif (!b.isEqualTo(0)) {\n\t\t\t\tthrow new Error(`sub in only implemented for b \\\\neq 0 in (x+b)^2`);\n\t\t\t}\n\t\t\tif (!a.isRational) {\n\t\t\t\tthrow new Error(`sub in only implemented for a rational in c(x+b)^2 + a2`);\n\t\t\t}\n\t\t\treturn atan(numberToSquareRoot(x).divide(a.coeff)).divide(a.coeff).divide(coeff);\n\t\t},\n\t};\n}\n\n/**\n * integrates 1 / ( coeff (x+b)^2 - a2 )\n * @param x represents x+b\n */\nfunction ln(\n\tx: Polynomial,\n\ta2: number | Fraction,\n\toptions?: { coeff?: number | Fraction; initial?: number | Fraction; modulus?: boolean; flip?: boolean },\n): LnFunction {\n\tlet { coeff, initial, modulus, flip } = {\n\t\tcoeff: 1,\n\t\tmodulus: true,\n\t\tflip: false,\n\t\t...options,\n\t};\n\tcoeff = numberToFraction(coeff);\n\ta2 = numberToFraction(a2).divide(coeff);\n\tconst positiveCoeff = coeff.isGreaterThan(0);\n\tcoeff = coeff.abs();\n\tconst a = new SquareRoot(a2.abs());\n\tconst poly = x;\n\treturn {\n\t\ttoString(): string {\n\t\t\tconst x0Coeff = x.coeffs[0];\n\t\t\tconst multiple = lcm(a.coeff.den, x0Coeff.den);\n\t\t\tconst aWithoutDen = a.times(multiple);\n\t\t\tconst xWithoutDen = x.times(multiple);\n\t\t\tlet xNum: Expression, xDen: Expression;\n\t\t\tif (initial) {\n\t\t\t\tif (!a.isRational()) {\n\t\t\t\t\tthrow new Error(`sub in only implemented for rational a in 1/(x^2 + a^2)`);\n\t\t\t\t}\n\t\t\t\tconst aCoeff = a.coeff;\n\t\t\t\tconst integrationConstant = positiveCoeff\n\t\t\t\t\t? x.subIn(initial).minus(aCoeff).divide(x.subIn(initial).plus(aCoeff))\n\t\t\t\t\t: aCoeff.plus(x.subIn(initial)).divide(aCoeff.minus(x.subIn(initial)));\n\t\t\t\txNum = positiveCoeff\n\t\t\t\t\t? new Expression(...xWithoutDen.terms, aWithoutDen.negative()).times(integrationConstant.den)\n\t\t\t\t\t: new Expression(aWithoutDen, ...xWithoutDen.terms).times(integrationConstant.den);\n\t\t\t\txDen = positiveCoeff\n\t\t\t\t\t? new Expression(...xWithoutDen.terms, aWithoutDen).times(integrationConstant.num)\n\t\t\t\t\t: new Expression(aWithoutDen, ...xWithoutDen.negative().terms).times(integrationConstant.num);\n\t\t\t} else {\n\t\t\t\txNum = positiveCoeff\n\t\t\t\t\t? new Expression(...xWithoutDen.terms, aWithoutDen.negative())\n\t\t\t\t\t: new Expression(aWithoutDen, ...xWithoutDen.terms);\n\t\t\t\txDen = positiveCoeff\n\t\t\t\t\t? new Expression(...xWithoutDen.terms, aWithoutDen)\n\t\t\t\t\t: new Expression(aWithoutDen, ...xWithoutDen.negative().terms);\n\t\t\t}\n\t\t\tconst open = modulus ? `|` : `(`;\n\t\t\tconst close = modulus ? `|` : `)`;\n\t\t\tif (flip) {\n\t\t\t\t[xNum, xDen] = [xDen, xNum];\n\t\t\t}\n\t\t\tconst term = a\n\t\t\t\t.reciprocal()\n\t\t\t\t.divide(2)\n\t\t\t\t.divide(coeff)\n\t\t\t\t.times(`\\\\ln \\\\left${open} \\\\frac{${xNum}}{${xDen}} \\\\right${close}`);\n\t\t\treturn `${term}`;\n\t\t},\n\t\tsubIn(x: number | Fraction): LnValue {\n\t\t\tif (!a.isRational()) {\n\t\t\t\tthrow new Error(`sub in only implemented for rational a in 1/(x^2 + a^2)`);\n\t\t\t}\n\t\t\tconst aFrac = a.coeff;\n\t\t\tconst lnCoeff = aFrac.reciprocal().divide(2).divide(coeff);\n\t\t\treturn positiveCoeff\n\t\t\t\t? new LnValue(poly.subIn(x).minus(aFrac).divide(poly.subIn(x).plus(aFrac)), { coeff: lnCoeff })\n\t\t\t\t: new LnValue(poly.subIn(x).plus(aFrac).divide(poly.subIn(x).negative().plus(aFrac)), { coeff: lnCoeff });\n\t\t},\n\t\tsubInSurdCase(x: number | Fraction): string {\n\t\t\tconst x0Coeff = poly.coeffs[0];\n\t\t\tconst multiple = lcm(a.coeff.den, x0Coeff.den);\n\t\t\tconst x1 = poly.times(multiple).subIn(x);\n\t\t\tconst xWithoutDen = x1.times(x1.den);\n\t\t\tconst aWithoutDen = a.times(multiple).times(x1.den);\n\t\t\tlet xNum = positiveCoeff\n\t\t\t\t? new Expression(xWithoutDen, aWithoutDen.negative())\n\t\t\t\t: new Expression(aWithoutDen, xWithoutDen);\n\t\t\tlet xDen = positiveCoeff\n\t\t\t\t? new Expression(xWithoutDen, aWithoutDen)\n\t\t\t\t: new Expression(aWithoutDen, xWithoutDen.negative());\n\t\t\tconst open = modulus ? `|` : `(`;\n\t\t\tconst close = modulus ? `|` : `)`;\n\t\t\tif (flip) {\n\t\t\t\t[xNum, xDen] = [xDen, xNum];\n\t\t\t}\n\t\t\tconst term = a\n\t\t\t\t.reciprocal()\n\t\t\t\t.divide(2)\n\t\t\t\t.divide(coeff)\n\t\t\t\t.times(`\\\\ln \\\\left${open} \\\\frac{${xNum}}{${xDen}} \\\\right${close}`);\n\t\t\treturn `${term}`;\n\t\t},\n\t};\n}\n\n/**\n * integrates 1 / sqrt( a2 - coeff (x+b)^2 )\n * @param x represents x+b\n */\nfunction arcsin(x: Polynomial, a2: number | Fraction, options?: { coeff?: number | Fraction }): ArcFunction {\n\tlet { coeff } = {\n\t\tcoeff: 1,\n\t\t...options,\n\t};\n\tcoeff = numberToFraction(coeff);\n\ta2 = numberToFraction(a2).divide(coeff);\n\tconst a = new SquareRoot(a2);\n\tlet xTerm: string;\n\tif (a.isEqualTo(1)) {\n\t\txTerm = `${x}`;\n\t} else {\n\t\tconst x0Coeff = x.coeffs[0];\n\t\tconst multiple = lcm(a.coeff.den, x0Coeff.den);\n\t\tconst aWithoutDen = a.times(multiple);\n\t\tconst xWithoutDen = x.times(multiple);\n\t\txTerm = `\\\\frac{${xWithoutDen}}{${aWithoutDen}}`;\n\t}\n\tconst poly = x;\n\tconst sinCoeff = new SquareRoot(coeff.reciprocal());\n\treturn {\n\t\ttoString(): string {\n\t\t\tconst term = sinCoeff.times(`\\\\sin^{-1} \\\\left( ${xTerm} \\\\right)`);\n\t\t\treturn `${term}`;\n\t\t},\n\t\tsubIn(x: number | Fraction | SquareRoot): Angle {\n\t\t\tconst b = poly.coeffs[1];\n\t\t\tif (!b.isEqualTo(0)) {\n\t\t\t\tthrow new Error(`sub in only implemented for b \\\\neq 0 in (x+b)^2`);\n\t\t\t}\n\t\t\tif (!sinCoeff.isRational()) {\n\t\t\t\tthrow new Error(`sub in only implemented for sqrt(c) rational in c(x+b)^2 + a2`);\n\t\t\t}\n\t\t\treturn asin(numberToSquareRoot(x).divide(a)).divide(sinCoeff.coeff);\n\t\t},\n\t};\n}\n\ninterface ArcFunction {\n\ttoString(): string;\n\tsubIn(x: number | Fraction | SquareRoot): Angle;\n}\ninterface LnFunction {\n\ttoString(): string;\n\tsubIn(x: number | Fraction): LnValue;\n\tsubInSurdCase(x: number | Fraction): string;\n}\n\n/**\n * a ln x\n */\nclass LnValue {\n\tcoeff: Fraction;\n\tx: Fraction;\n\n\tconstructor(x: number | Fraction, options?: { coeff?: number | Fraction }) {\n\t\tconst { coeff } = {\n\t\t\tcoeff: 1,\n\t\t\t...options,\n\t\t};\n\t\tx = numberToFraction(x);\n\t\tif (x.isAtMost(0)) {\n\t\t\tthrow new RangeError(`logarithm argument must be positive: ${x} received`);\n\t\t}\n\t\tthis.coeff = numberToFraction(coeff);\n\t\tthis.x = x;\n\t}\n\n\ttoString(): string {\n\t\tif (this.x.isEqualTo(1)) {\n\t\t\treturn `0`;\n\t\t}\n\t\tconst term = new Term(this.coeff, `\\\\ln ${this.x}`);\n\t\treturn `${term}`;\n\t}\n\tvalueOf(): number {\n\t\treturn this.coeff.valueOf() * Math.log(this.x.valueOf());\n\t}\n}\n","import { PowerFn, CosFn, SinFn, ExpFn } from '../classes/classes';\nimport { Expression, Term, Fraction, numberToFraction } from '../../core';\nimport { Angle, cos, sin } from '../../trigo';\n\n/**\n * integration by parts:\n * (1a) x^n cos x\n * (1b) x^n sin x\n * (1c) x^n exp x\n */\nexport function byParts(u: PowerFn, vPrime: CosFn | SinFn | ExpFn): Expression {\n\tif (u instanceof PowerFn) {\n\t\tif (vPrime instanceof CosFn || vPrime instanceof SinFn || vPrime instanceof ExpFn) {\n\t\t\treturn powerTrigo(u, vPrime);\n\t\t}\n\t}\n\tthrow new Error(`integration type not supported`);\n}\n\nfunction powerTrigo(u: PowerFn, vPrime: CosFn | SinFn | ExpFn, firstTerms?: Expression, sign = 1): Expression {\n\tif (!u.n.isInteger() || u.n.isLessThan(0)) {\n\t\tthrow new Error(`power ${u.n} not supported`);\n\t}\n\tconst v = vPrime.integrate();\n\tif (u.n.isEqualTo(0)) {\n\t\tconst vTerm = new Term(v.coeff, u.coeff, `${v.removeCoeff()}`);\n\t\treturn firstTerms ? firstTerms.plus(vTerm.times(sign)) : new Expression(vTerm);\n\t}\n\tconst uPrime = u.differentiate().power;\n\tconst uvTerm = new Term(u.coeff, v.coeff, `${u.removeCoeff()}`, `${v.removeCoeff()}`);\n\tconst frontTerms = firstTerms ? firstTerms.plus(uvTerm.times(sign)) : new Expression(uvTerm);\n\treturn powerTrigo(uPrime, v, frontTerms, sign * -1);\n}\n\n/**\n * integration by parts:\n * (1a) x^n cos x\n * (1b) x^n sin x\n * (1c) x^n exp x\n */\nexport function byPartsD(\n\tu: PowerFn,\n\tvPrime: CosFn | SinFn,\n\tlower: number | Fraction | Angle,\n\tupper: number | Fraction | Angle,\n): Expression;\nexport function byPartsD(u: PowerFn, vPrime: ExpFn, lower: number | Fraction, upper: number | Fraction): Expression;\nexport function byPartsD(\n\tu: PowerFn,\n\tvPrime: CosFn | SinFn | ExpFn,\n\tlower: number | Fraction | Angle,\n\tupper: number | Fraction | Angle,\n): Expression {\n\tif (u instanceof PowerFn) {\n\t\tif (vPrime instanceof CosFn || vPrime instanceof SinFn) {\n\t\t\treturn powerTrigoD(u, vPrime, lower, upper);\n\t\t} else if (vPrime instanceof ExpFn) {\n\t\t\treturn powerExpD(u, vPrime, lower as number | Fraction, upper as number | Fraction);\n\t\t}\n\t}\n\tthrow new Error(`integration type not supported`);\n}\n\nfunction powerTrigoD(\n\tu: PowerFn,\n\tvPrime: CosFn | SinFn,\n\tlower: number | Fraction | Angle,\n\tupper: number | Fraction | Angle,\n\tfirstTerms?: Expression,\n\tsign = 1,\n): Expression {\n\tif (!u.n.isInteger() || u.n.isLessThan(0)) {\n\t\tthrow new Error(`power ${u.n} not supported`);\n\t}\n\tconst v = vPrime.integrate();\n\tconst vTermLower = (v instanceof CosFn ? cos(lower) : sin(lower)).times(v.coeff);\n\tconst vTermUpper = (v instanceof CosFn ? cos(upper) : sin(upper)).times(v.coeff);\n\tif (u.n.isEqualTo(0)) {\n\t\treturn firstTerms\n\t\t\t? firstTerms.plus(vTermUpper.times(sign).times(u.coeff)).minus(vTermLower.times(sign).times(u.coeff))\n\t\t\t: new Expression(vTermUpper, vTermLower.negative());\n\t}\n\tconst uPrime = u.differentiate().power;\n\tlower = new Angle(lower instanceof Angle ? lower.k : lower, { domain: 'all' });\n\tupper = new Angle(upper instanceof Angle ? upper.k : upper, { domain: 'all' });\n\tconst uTermLower = new Term(u.coeff, lower.k.pow(u.n.num), u.n.isEqualTo(1) ? `\\\\pi` : `\\\\pi^{${u.n}}`);\n\tconst uTermUpper = new Term(u.coeff, upper.k.pow(u.n.num), u.n.isEqualTo(1) ? `\\\\pi` : `\\\\pi^{${u.n}}`);\n\tconst uvTermUpper = uTermUpper.times(vTermUpper);\n\tconst uvTermLower = uTermLower.times(vTermLower);\n\tconst frontTerms = firstTerms\n\t\t? firstTerms.plus(uvTermUpper.times(sign)).minus(uvTermLower.times(sign))\n\t\t: new Expression(uvTermUpper, uvTermLower.negative());\n\treturn powerTrigoD(uPrime, v, lower, upper, frontTerms, sign * -1);\n}\nfunction powerExpD(\n\tu: PowerFn,\n\tvPrime: ExpFn,\n\tlower: number | Fraction,\n\tupper: number | Fraction,\n\tfirstTerms?: Expression,\n\tsign = 1,\n): Expression {\n\tif (!u.n.isInteger() || u.n.isLessThan(0)) {\n\t\tthrow new Error(`power ${u.n} not supported`);\n\t}\n\tlower = numberToFraction(lower);\n\tupper = numberToFraction(upper);\n\tconst v = vPrime.integrate();\n\tconst vTermUpper = upper.isEqualTo(0)\n\t\t? new Term(v.coeff)\n\t\t: new Term(v.coeff, upper.isEqualTo(1) ? `\\\\mathrm{e}` : `\\\\mathrm{e}^{${upper}}`);\n\tconst vTermLower = lower.isEqualTo(0)\n\t\t? new Term(v.coeff)\n\t\t: new Term(v.coeff, lower.isEqualTo(1) ? `\\\\mathrm{e}` : `\\\\mathrm{e}^{${lower}}`);\n\tif (u.n.isEqualTo(0)) {\n\t\treturn firstTerms\n\t\t\t? firstTerms.plus(vTermUpper.times(sign).times(u.coeff)).minus(vTermLower.times(sign).times(u.coeff))\n\t\t\t: new Expression(vTermUpper, vTermLower.negative());\n\t}\n\tconst uPrime = u.differentiate().power;\n\tconst uvTermUpper = vTermUpper.times(u.subIn(upper));\n\tconst uvTermLower = vTermLower.times(u.subIn(lower));\n\tconst frontTerms = firstTerms\n\t\t? firstTerms.plus(uvTermUpper.times(sign)).minus(uvTermLower.times(sign))\n\t\t: new Expression(uvTermUpper, uvTermLower.negative());\n\treturn powerExpD(uPrime, v, lower, upper, frontTerms, sign * -1);\n}\n","/**\n * implementation of Simpson's 1/3 rule for numerical integration.\n *\n * @param intervals number of intervals (defaults to 100)\n */\nexport function simpsons(f: (x: number) => number, lower: number, upper: number, intervals = 100): number {\n\tlet result = 0;\n\tconst stepSize = (upper - lower) / intervals;\n\tlet i: number;\n\tfor (i = 0; i < intervals; i++) {\n\t\tresult += simpson_step(f, lower + i * stepSize, lower + (i + 1) * stepSize);\n\t}\n\treturn result;\n}\n\nconst simpson_step = function (f: (x: number) => number, a: number, b: number): number {\n\treturn ((b - a) / 8) * (f(a) + 3 * f((2 * a + b) / 3) + 3 * f((a + 2 * b) / 3) + f(b));\n};\n","export function finiteDifference(f: (x: number) => number, x: number, precision = 5): number {\n\tconst h = Math.pow(10, -precision);\n\treturn (f(x + h) - f(x - h)) / 2 / h;\n}\n","import { type1a } from './type1';\n\nexport const de = {\n\ttype1a,\n};\n","import { Polynomial, Expression, Fraction, Term } from '../../core';\n\n/**\n * Solves DE of the form dxdt = a + b t\n * @param poly a + bt as a Polynomial, or [a, b] as an array or b if a=0.\n * @param options `{variable, initial}`. variable is used as 't'\n * @returns solution of the DE in expression form A/b exp(bt) - a/b.\n * general solution in terms of 'A' if no initial provided,\n * particular solution otherwise\n */\nexport function type1a(\n\tpoly: number | Fraction | [number | Fraction, number | Fraction] | Polynomial,\n\toptions?: {\n\t\tvariable?: string;\n\t\tinitial?: number | Fraction;\n\t},\n): Expression {\n\tlet variable = options?.variable ?? 't';\n\tif (Array.isArray(poly)) {\n\t\tpoly = new Polynomial(poly, { ascending: true, variable });\n\t}\n\tif (typeof poly === 'number' || poly instanceof Fraction) {\n\t\tpoly = new Polynomial([0, poly], { ascending: true, variable });\n\t}\n\tconst [a, b] = poly.coeffs;\n\tconst bt = new Polynomial(b, { variable });\n\t// a + b x = A exp( b t )\n\t// x = (A exp(bt) - a) / b\n\tif (options?.initial === undefined) {\n\t\tconst bReciprocal = b.reciprocal();\n\t\treturn new Expression(new Term(bReciprocal, `A \\\\mathrm{e}^{ ${bt} }`), a.negative().divide(b));\n\t} else {\n\t\tconst A = poly.subIn(options.initial);\n\t\treturn new Expression(new Term(A.divide(b), `\\\\mathrm{e}^{ ${bt} }`), a.negative().divide(b));\n\t}\n}\n","import { Term, Fraction, VariableTerm, SquareRoot, Imaginary, Expression, numberToFraction } from '../core';\n\n/**\n * returns an unsimplified expression string\n */\nexport class UnsimplifiedExpression {\n\tterms: (Term | VariableTerm | Fraction | number | string | SquareRoot | Imaginary)[];\n\n\tconstructor(...args: (Term | VariableTerm | Fraction | number | string | SquareRoot | Imaginary)[]) {\n\t\tthis.terms = args;\n\t}\n\n\tsimplify(): Expression {\n\t\treturn new Expression(...this.terms);\n\t}\n\n\ttoString(): string {\n\t\tif (this.terms.length === 0) {\n\t\t\treturn '0';\n\t\t}\n\t\tlet outputString = '';\n\t\tthis.terms.forEach((term, i) => {\n\t\t\tif (typeof term === 'string' || typeof term === 'number' || term instanceof Fraction) {\n\t\t\t\tterm = new Term(term);\n\t\t\t}\n\t\t\tif (i !== 0) {\n\t\t\t\toutputString += term.coeff.isAtLeast(0) ? ' + ' : ' ';\n\t\t\t}\n\t\t\toutputString += term.toString();\n\t\t});\n\t\treturn outputString;\n\t}\n\n\tclone(): UnsimplifiedExpression {\n\t\tconst newTerms = this.terms.map((x) => {\n\t\t\tif (typeof x === 'string' || typeof x === 'number') {\n\t\t\t\treturn x;\n\t\t\t} else {\n\t\t\t\treturn x.clone();\n\t\t\t}\n\t\t});\n\t\treturn new UnsimplifiedExpression(...newTerms);\n\t}\n}\n\n/**\n * representation of k(ax+...+by) where k is a Fraction and ax+...+by is an Expression\n */\nexport class BracketedTerm extends Term {\n\tinnerExpression: Expression | UnsimplifiedExpression;\n\t/**\n\t * Creates a new BracketedTerm\n\t * representing k(ax+...+by)\n\t */\n\tconstructor(\n\t\tcoeff: number | Fraction,\n\t\tinnerExpression: UnsimplifiedExpression | Expression | Term | Fraction | number | string,\n\t) {\n\t\tif (!(innerExpression instanceof Expression) && !(innerExpression instanceof UnsimplifiedExpression)) {\n\t\t\tinnerExpression = new Expression(innerExpression);\n\t\t}\n\t\tcoeff = numberToFraction(coeff);\n\t\tconst variableString = coeff.isEqualTo(1) ? `${innerExpression}` : `(${innerExpression})`;\n\t\tsuper(coeff, variableString);\n\t\tthis.innerExpression = innerExpression.clone();\n\t}\n\n\t/**\n\t * if innerExpression is a WorkingExpression, simplify it\n\t */\n\tsimplifyInnerExpression(): BracketedTerm {\n\t\tif (this.innerExpression instanceof UnsimplifiedExpression) {\n\t\t\treturn new BracketedTerm(this.coeff, this.innerExpression.simplify());\n\t\t}\n\t\treturn this.clone();\n\t}\n\n\t/**\n\t * multiplies k in, returning the expanded expression\n\t */\n\tsimplify(): Expression {\n\t\tconst innerExpression =\n\t\t\tthis.innerExpression instanceof UnsimplifiedExpression ? this.innerExpression.simplify() : this.innerExpression;\n\t\treturn innerExpression.times(this.coeff);\n\t}\n\n\tclone(): BracketedTerm {\n\t\treturn new BracketedTerm(this.coeff.clone(), this.innerExpression.clone());\n\t}\n}\n","import { getRandomInt } from './getRandomInt';\nimport { Fraction, numberToFraction } from '../core/index';\n\n/**\n * Generates a random Fraction\n *\n * @param options defaults to `{ numRange: [-9,9], denRange: [1,9], avoid: [] }`\n * where numRange and denRange specifies the minimum and maximum values for the numerator and denominator, respectively\n * and avoid is an Array of numbers/Fractions that will not be generated\n */\nexport function getRandomFrac(options?: {\n\tnumRange?: [number, number];\n\tdenRange?: [number, number];\n\tavoid?: number | Fraction | (number | Fraction)[];\n}): Fraction {\n\tlet avoidArray = options?.avoid ?? [];\n\tif (!Array.isArray(avoidArray)) {\n\t\tavoidArray = [avoidArray];\n\t}\n\tconst fractionOptions = {\n\t\tnumRange: options?.numRange ?? [-9, 9],\n\t\tdenRange: options?.denRange ?? [1, 9],\n\t\tavoid: avoidArray.map((e) => numberToFraction(e)),\n\t};\n\tlet num = getRandomInt(...fractionOptions.numRange);\n\tlet den = getRandomInt(...fractionOptions.denRange);\n\tlet frac = new Fraction(num, den),\n\t\tcounter = 0;\n\twhile (fractionOptions.avoid.some((e) => e.isEqualTo(frac))) {\n\t\tcounter++;\n\t\tif (counter > 1000) {\n\t\t\tthrow new Error('Could not generate a random Fraction within 1000 attempts that is not in the avoid Array');\n\t\t}\n\t\tnum = getRandomInt(...fractionOptions.numRange);\n\t\tden = getRandomInt(...fractionOptions.denRange);\n\t\tfrac = new Fraction(num, den);\n\t}\n\treturn frac;\n}\n","import { getRandomInt } from './getRandomInt';\nimport { shuffle } from './shuffle';\n\n/**\n * picks a random element in an array\n */\nexport function sample<T>(arr: T[]): T {\n\tif (arr.length === 0) {\n\t\tthrow new Error(`pick does not work with empty array.`);\n\t}\n\treturn arr[getRandomInt(0, arr.length - 1)];\n}\n\n/**\n * picks n random elements *without* replacement\n */\nexport function sampleN<T>(n: number, arr: T[]): T[] {\n\tif (!Number.isInteger(n) || n <= 0) {\n\t\tthrow new Error(`n must be a positive integer.`);\n\t}\n\tif (arr.length < n) {\n\t\tthrow new Error(`n must be bigger than the size of the array.`);\n\t}\n\tlet arrDuplicate = [...arr];\n\tconst samples: T[] = [];\n\tfor (let i = 0; i < n; i++) {\n\t\tarrDuplicate = shuffle(arrDuplicate);\n\t\tsamples.push(arrDuplicate.pop()!);\n\t}\n\treturn samples;\n}\n","import { getRandomInt } from './getRandomInt';\nimport { Fraction } from '../core';\nimport { heads } from './coinFlip';\n\n/**\n * generates k in k pi, such that k pi is a special angle\n * @param options defaults to `{ allowReal: false, allowImag: false }` where we allow angles 0,pi for the first option\n * and \\pm pi/2 for the second option\n *\n * @param options.avoid Fraction[] to avoid\n */\nexport function getRandomAngle(options?: { allowReal?: boolean; allowImag?: boolean; avoid?: Fraction[] }): Fraction {\n\t// 2: 1/2, 3: k/3, 4: k/4, 5: k/6, 6: 0, pi\n\tconst { allowReal, allowImag, avoid } = {\n\t\tallowReal: false,\n\t\tallowImag: false,\n\t\tavoid: [],\n\t\t...options,\n\t};\n\tlet den = getRandomInt(allowImag ? 2 : 3, allowReal ? 6 : 5);\n\tif (den === 6) {\n\t\tden = 1;\n\t} else if (den === 5) {\n\t\tden = 6;\n\t}\n\tif (den === 2 && heads()) {\n\t\t// equalizes the probability of getting any angle\n\t\treturn getRandomAngle(options);\n\t}\n\tlet num = heads() ? 1 : den - 1;\n\tif (heads()) {\n\t\tnum = num * -1;\n\t}\n\tconst k = new Fraction(num, den);\n\tif (avoid.some((e) => e.isEqualTo(k))) {\n\t\treturn getRandomAngle(options);\n\t}\n\treturn k;\n}\n","export { AP } from './apClass';\nexport { GP } from './gpClass';\nexport { solveGpSN, solveGpSNNumber } from './utils';\n","import { Fraction, numberToFraction, Polynomial } from '../core';\n\n/**\n * Arithmetic progression\n */\nexport class AP {\n\ta: Fraction;\n\td: Fraction;\n\n\t/**\n\t * creates new AP instance\n\t */\n\tconstructor(a: number | Fraction, d: number | Fraction) {\n\t\tthis.a = numberToFraction(a);\n\t\tthis.d = numberToFraction(d);\n\t}\n\n\t/**\n\t * nth term, u_n = a + (n-1)d\n\t */\n\tu(n: number): Fraction {\n\t\tif (!Number.isInteger(n) || n < 1) {\n\t\t\tthrow new Error(`Only valid for positive integers n ${n}`);\n\t\t}\n\t\treturn this.a.plus(this.d.times(n - 1));\n\t}\n\n\t/**\n\t * nth term as a polynomial: u_n = nd + a-d\n\t */\n\tuNPoly(): Polynomial {\n\t\treturn new Polynomial([this.d, this.a.minus(this.d)], { variable: 'n' });\n\t}\n\n\t/**\n\t * sum of n terms, S_n = n/2 * (2a + (n-1)d)\n\t */\n\tS(n: number): Fraction {\n\t\tif (!Number.isInteger(n) || n < 1) {\n\t\t\tthrow new Error(`Only valid for positive integers n ${n}`);\n\t\t}\n\t\treturn this.a.times(n).plus(\n\t\t\tthis.d\n\t\t\t\t.times(n - 1)\n\t\t\t\t.times(n)\n\t\t\t\t.divide(2),\n\t\t);\n\t}\n\n\t/**\n\t * sum of n terms as a polynomial: S_n = n/2 * (2a + (n-1)d)\n\t */\n\tsNPoly(): Polynomial {\n\t\treturn new Polynomial([this.d.divide(2), this.a.minus(this.d.divide(2)), 0], { variable: 'n' });\n\t}\n}\n","import { Fraction, numberToFraction } from '../core';\n\n/**\n * Geometric progression\n */\nexport class GP {\n\ta: Fraction;\n\tr: Fraction;\n\n\t/**\n\t * creates new GP instance\n\t */\n\tconstructor(a: number | Fraction, r: number | Fraction) {\n\t\tthis.a = numberToFraction(a);\n\t\tthis.r = numberToFraction(r);\n\t}\n\n\t/**\n\t * nth term, u_n = a r^(n-1)\n\t */\n\tu(n: number): Fraction {\n\t\tif (!Number.isInteger(n) || n < 1) {\n\t\t\tthrow new Error(`Only valid for positive integers n ${n}`);\n\t\t}\n\t\treturn this.a.times(this.r.pow(n - 1));\n\t}\n\n\t/**\n\t * sum of n terms, S_n = a (1 - r^n)/(1-r)\n\t */\n\tS(n: number): Fraction {\n\t\tif (!Number.isInteger(n) || n < 1) {\n\t\t\tthrow new Error(`Only valid for positive integers n ${n}`);\n\t\t}\n\t\tif (this.r.abs().isEqualTo(1)) {\n\t\t\treturn this.r.isEqualTo(1) ? this.a.times(n) : n % 2 === 0 ? Fraction.ZERO : this.a.clone();\n\t\t}\n\t\treturn this.a.times(Fraction.ONE.minus(this.r.pow(n)).divide(Fraction.ONE.minus(this.r)));\n\t}\n\n\t/**\n\t * sum to infinity, S_infty = a / (1-r)\n\t */\n\tSInfty(): Fraction {\n\t\tif (this.r.abs().isAtLeast(1)) {\n\t\t\tthrow new Error(`GP does not converge for  |r| >= 1, ${this.r}`);\n\t\t}\n\t\treturn this.a.divide(Fraction.ONE.minus(this.r));\n\t}\n\n\t/**\n\t * u_n formula to be used for floats\n\t */\n\tstatic u(a: number, r: number, n: number): number {\n\t\tif (!Number.isInteger(n) || n < 1) {\n\t\t\tthrow new Error(`GP error: n must be positive integer, ${n} received.`);\n\t\t}\n\t\treturn a * Math.pow(r, n - 1);\n\t}\n\t/**\n\t * S_n formula to be used for floats\n\t */\n\tstatic S(a: number, r: number, n: number): number {\n\t\tif (!Number.isInteger(n) || n < 1) {\n\t\t\tthrow new Error(`GP error: n must be positive integer, ${n} received.`);\n\t\t}\n\t\tif (r === 1) {\n\t\t\tthrow new Error(`GP Sum error: r must not be 1.`);\n\t\t}\n\t\treturn (a * (Math.pow(r, n) - 1)) / (r - 1);\n\t}\n\t/**\n\t * S_infty formula to be used for floats\n\t */\n\tstatic SInfty(a: number, r: number): number {\n\t\tif (Math.abs(r) >= 1) {\n\t\t\tthrow new Error(`GP S_Infty error: |r| must not be less than 1.`);\n\t\t}\n\t\treturn a / (1 - r);\n\t}\n}\n","export { solveGpSN, solveGpSNNumber } from './solveGpSN';\n","import { Fraction } from '../../core';\nimport { GP } from '../gpClass';\n\n/**\n * solve for sN > k (or less than by configuring options)\n * @param options defaults to `{moreThan: true}`\n */\nexport function solveGpSN(gp: GP, k: number | Fraction, options?: { moreThan?: boolean }): number {\n\tif (gp.r.isEqualTo(1)) {\n\t\tthrow new Error(`constant sequence not currently supported`);\n\t}\n\t// k(1-r)/a\n\tconst k1 = Fraction.ONE.minus(gp.r).divide(gp.a).times(k);\n\tconst logTerm = Math.log(Fraction.ONE.minus(k1).valueOf());\n\tconst n = logTerm / Math.log(gp.r.valueOf());\n\tconst { moreThan } = {\n\t\tmoreThan: true,\n\t\t...options,\n\t};\n\tif ((moreThan && gp.a.isGreaterThan(0)) || (!moreThan && gp.a.isLessThan(0))) {\n\t\treturn Math.ceil(n);\n\t} else {\n\t\treturn Math.floor(n);\n\t}\n}\n\n/**\n * solve for sN > k (or less than by configuring options)\n * @param options defaults to `{moreThan: true}`\n */\nexport function solveGpSNNumber(a: number, r: number, k: number, options?: { moreThan?: boolean }): number {\n\tif (r === 1 || r < 0) {\n\t\tthrow new Error(`solveGPSNNumber error: we don't support negative r or r===1 currently`);\n\t}\n\t// k(1-r)/a\n\tconst k1 = 1 + (k * (r - 1)) / a;\n\tconst n = Math.log(k1) / Math.log(r);\n\tconst { moreThan } = {\n\t\tmoreThan: true,\n\t\t...options,\n\t};\n\tif ((moreThan && a > 0) || (!moreThan && a < 0)) {\n\t\treturn Math.ceil(n);\n\t} else {\n\t\treturn Math.floor(n);\n\t}\n}\n","export { Maclaurin } from './maclaurin';\n\nexport { xMaclaurin } from './xMaclaurin';\n","import { Fraction, Polynomial, numberToFraction } from '../core';\nimport { factorial } from '../stats/simple-statistics/factorial';\n\nexport const Maclaurin = {\n\t/**\n\t * binomial expansion of (1+x)^n\n\t *\n\t * @param degree: highest power to include in power series\n\t * @param options defaults to {x: 'x'}\n\t */\n\tbinomial(degree: number, n: number | Fraction, options?: { x?: string | Polynomial }): Polynomial {\n\t\tconst { x: xOptions } = {\n\t\t\tx: 'x',\n\t\t\t...options,\n\t\t};\n\t\tconst x = typeof xOptions === 'string' ? new Polynomial([1, 0], { variable: xOptions }) : xOptions;\n\t\tn = numberToFraction(n);\n\t\tconst coeffs: Fraction[] = [];\n\t\tfor (let i = 0; i <= degree; i++) {\n\t\t\tlet coeff = Fraction.ONE;\n\t\t\tfor (let j = 0; j < i; j++) {\n\t\t\t\tcoeff = coeff.times(n.minus(j)).divide(j + 1);\n\t\t\t}\n\t\t\tcoeffs.push(coeff);\n\t\t}\n\t\treturn new Polynomial(coeffs, { ascending: true, variable: x.variable }).replaceXWith(x);\n\t},\n\n\t/**\n\t * power series for e^x\n\t */\n\texp(degree: number, options?: { x?: string | Polynomial }): Polynomial {\n\t\tconst { x: xOptions } = {\n\t\t\tx: 'x',\n\t\t\t...options,\n\t\t};\n\t\tconst x = typeof xOptions === 'string' ? new Polynomial([1, 0], { variable: xOptions }) : xOptions;\n\t\tconst coeffs: Fraction[] = [];\n\t\tfor (let i = 0; i <= degree; i++) {\n\t\t\tconst coeff = new Fraction(1, factorial(i));\n\t\t\tcoeffs.push(coeff);\n\t\t}\n\t\treturn new Polynomial(coeffs, { ascending: true, variable: x.variable }).replaceXWith(x);\n\t},\n\n\t/**\n\t * power series for sin(x)\n\t */\n\tsin(degree: number, options?: { x?: string | Polynomial }): Polynomial {\n\t\tconst { x: xOptions } = {\n\t\t\tx: 'x',\n\t\t\t...options,\n\t\t};\n\t\tconst x = typeof xOptions === 'string' ? new Polynomial([1, 0], { variable: xOptions }) : xOptions;\n\t\tconst coeffs: Fraction[] = [];\n\t\tfor (let i = 0; i <= degree; i++) {\n\t\t\tconst coeff = i % 2 === 0 ? Fraction.ZERO : new Fraction(1, factorial(i)).times(Math.pow(-1, (i - 1) / 2));\n\t\t\tcoeffs.push(coeff);\n\t\t}\n\t\treturn new Polynomial(coeffs, { ascending: true, variable: x.variable }).replaceXWith(x);\n\t},\n\n\t/**\n\t * power series for cos(x)\n\t */\n\tcos(degree: number, options?: { x?: string | Polynomial }): Polynomial {\n\t\tconst { x: xOptions } = {\n\t\t\tx: 'x',\n\t\t\t...options,\n\t\t};\n\t\tconst x = typeof xOptions === 'string' ? new Polynomial([1, 0], { variable: xOptions }) : xOptions;\n\t\tconst coeffs: Fraction[] = [];\n\t\tfor (let i = 0; i <= degree; i++) {\n\t\t\tconst coeff = i % 2 === 0 ? new Fraction(1, factorial(i)).times(Math.pow(-1, i / 2)) : Fraction.ZERO;\n\t\t\tcoeffs.push(coeff);\n\t\t}\n\t\treturn new Polynomial(coeffs, { ascending: true, variable: x.variable }).replaceXWith(x);\n\t},\n\n\t/**\n\t * power series for ln(1+x)\n\t */\n\tln(degree: number, options?: { x?: string | Polynomial }): Polynomial {\n\t\tconst { x: xOptions } = {\n\t\t\tx: 'x',\n\t\t\t...options,\n\t\t};\n\t\tconst x = typeof xOptions === 'string' ? new Polynomial([1, 0], { variable: xOptions }) : xOptions;\n\t\tconst coeffs: Fraction[] = [];\n\t\tfor (let i = 0; i <= degree; i++) {\n\t\t\tconst coeff = i === 0 ? Fraction.ZERO : new Fraction(1, i).times(Math.pow(-1, i + 1));\n\t\t\tcoeffs.push(coeff);\n\t\t}\n\t\treturn new Polynomial(coeffs, { ascending: true, variable: x.variable }).replaceXWith(x);\n\t},\n};\n","// The following code is from [simple-statistics package](https://simplestatistics.org/)\n// taken on 21st September 2022 and modified to include types\n\n/**\n * A [Factorial](https://en.wikipedia.org/wiki/Factorial), usually written n!, is the product of all positive\n * integers less than or equal to n. Often factorial is implemented\n * recursively, but this iterative approach is significantly faster\n * and simpler.\n *\n * @param {number} n input, must be an integer number 1 or greater\n * @returns {number} factorial: n!\n * @throws {Error} if n is less than 0 or not an integer\n * @example\n * factorial(5); // => 120\n */\nexport function factorial(n: number): number {\n\t// factorial is mathematically undefined for negative numbers\n\tif (n < 0) {\n\t\tthrow new Error('factorial requires a non-negative value');\n\t}\n\n\tif (Math.floor(n) !== n) {\n\t\tthrow new Error('factorial requires an integer input');\n\t}\n\n\t// typically you'll expand the factorial function going down, like\n\t// 5! = 5 * 4 * 3 * 2 * 1. This is going in the opposite direction,\n\t// counting from 2 up to the number in question, and since anything\n\t// multiplied by 1 is itself, the loop only needs to start at 2.\n\tlet accumulator = 1;\n\tfor (let i = 2; i <= n; i++) {\n\t\t// for each number up to and including the number `n`, multiply\n\t\t// the accumulator my that number.\n\t\taccumulator *= i;\n\t}\n\treturn accumulator;\n}\n","import { Fraction, Polynomial, numberToFraction } from '../core';\nimport { factorial } from '../stats/simple-statistics/factorial';\nimport { xPolynomial } from '../algebra';\n\nexport const xMaclaurin = {\n\t/**\n\t * binomial expansion of (1+x)^n\n\t *\n\t * @param degree: highest power to include in power series\n\t * @param options defaults to {x: 'x'}\n\t */\n\tbinomial(degree: number, n: number | Fraction, options?: { x?: string | Polynomial | xPolynomial }): xPolynomial {\n\t\tconst { x: xOptions } = {\n\t\t\tx: 'x',\n\t\t\t...options,\n\t\t};\n\t\tconst x =\n\t\t\ttypeof xOptions === 'string'\n\t\t\t\t? new xPolynomial([1, 0], { variable: xOptions })\n\t\t\t\t: xOptions instanceof xPolynomial\n\t\t\t\t? xOptions\n\t\t\t\t: new xPolynomial(xOptions.coeffs, { ascending: true, variable: xOptions.variable }).changeAscending(\n\t\t\t\t\t\txOptions.ascending,\n\t\t\t\t  );\n\t\tn = numberToFraction(n);\n\t\tconst coeffs: Fraction[] = [];\n\t\tfor (let i = 0; i <= degree; i++) {\n\t\t\tlet coeff = Fraction.ONE;\n\t\t\tfor (let j = 0; j < i; j++) {\n\t\t\t\tcoeff = coeff.times(n.minus(j)).divide(j + 1);\n\t\t\t}\n\t\t\tcoeffs.push(coeff);\n\t\t}\n\t\treturn new xPolynomial(coeffs, { ascending: true, variable: x.variable }).replaceXWith(x);\n\t},\n\n\t/**\n\t * power series for e^x\n\t */\n\texp(degree: number, options?: { x?: string | Polynomial | xPolynomial }): xPolynomial {\n\t\tconst { x: xOptions } = {\n\t\t\tx: 'x',\n\t\t\t...options,\n\t\t};\n\t\tconst x =\n\t\t\ttypeof xOptions === 'string'\n\t\t\t\t? new xPolynomial([1, 0], { variable: xOptions })\n\t\t\t\t: xOptions instanceof xPolynomial\n\t\t\t\t? xOptions\n\t\t\t\t: new xPolynomial(xOptions.coeffs, { ascending: true, variable: xOptions.variable }).changeAscending(\n\t\t\t\t\t\txOptions.ascending,\n\t\t\t\t  );\n\t\tconst coeffs: Fraction[] = [];\n\t\tfor (let i = 0; i <= degree; i++) {\n\t\t\tconst coeff = new Fraction(1, factorial(i));\n\t\t\tcoeffs.push(coeff);\n\t\t}\n\t\treturn new xPolynomial(coeffs, { ascending: true, variable: x.variable }).replaceXWith(x);\n\t},\n\n\t/**\n\t * power series for sin(x)\n\t */\n\tsin(degree: number, options?: { x?: string | Polynomial | xPolynomial }): xPolynomial {\n\t\tconst { x: xOptions } = {\n\t\t\tx: 'x',\n\t\t\t...options,\n\t\t};\n\t\tconst x =\n\t\t\ttypeof xOptions === 'string'\n\t\t\t\t? new xPolynomial([1, 0], { variable: xOptions })\n\t\t\t\t: xOptions instanceof xPolynomial\n\t\t\t\t? xOptions\n\t\t\t\t: new xPolynomial(xOptions.coeffs, { ascending: true, variable: xOptions.variable }).changeAscending(\n\t\t\t\t\t\txOptions.ascending,\n\t\t\t\t  );\n\t\tconst coeffs: Fraction[] = [];\n\t\tfor (let i = 0; i <= degree; i++) {\n\t\t\tconst coeff = i % 2 === 0 ? Fraction.ZERO : new Fraction(1, factorial(i)).times(Math.pow(-1, (i - 1) / 2));\n\t\t\tcoeffs.push(coeff);\n\t\t}\n\t\treturn new xPolynomial(coeffs, { ascending: true, variable: x.variable }).replaceXWith(x);\n\t},\n\n\t/**\n\t * power series for cos(x)\n\t */\n\tcos(degree: number, options?: { x?: string | Polynomial | xPolynomial }): xPolynomial {\n\t\tconst { x: xOptions } = {\n\t\t\tx: 'x',\n\t\t\t...options,\n\t\t};\n\t\tconst x =\n\t\t\ttypeof xOptions === 'string'\n\t\t\t\t? new xPolynomial([1, 0], { variable: xOptions })\n\t\t\t\t: xOptions instanceof xPolynomial\n\t\t\t\t? xOptions\n\t\t\t\t: new xPolynomial(xOptions.coeffs, { ascending: true, variable: xOptions.variable }).changeAscending(\n\t\t\t\t\t\txOptions.ascending,\n\t\t\t\t  );\n\t\tconst coeffs: Fraction[] = [];\n\t\tfor (let i = 0; i <= degree; i++) {\n\t\t\tconst coeff = i % 2 === 0 ? new Fraction(1, factorial(i)).times(Math.pow(-1, i / 2)) : Fraction.ZERO;\n\t\t\tcoeffs.push(coeff);\n\t\t}\n\t\treturn new xPolynomial(coeffs, { ascending: true, variable: x.variable }).replaceXWith(x);\n\t},\n\n\t/**\n\t * power series for ln(1+x)\n\t */\n\tln(degree: number, options?: { x?: string | Polynomial | xPolynomial }): xPolynomial {\n\t\tconst { x: xOptions } = {\n\t\t\tx: 'x',\n\t\t\t...options,\n\t\t};\n\t\tconst x =\n\t\t\ttypeof xOptions === 'string'\n\t\t\t\t? new xPolynomial([1, 0], { variable: xOptions })\n\t\t\t\t: xOptions instanceof xPolynomial\n\t\t\t\t? xOptions\n\t\t\t\t: new xPolynomial(xOptions.coeffs, { ascending: true, variable: xOptions.variable }).changeAscending(\n\t\t\t\t\t\txOptions.ascending,\n\t\t\t\t  );\n\t\tconst coeffs: Fraction[] = [];\n\t\tfor (let i = 0; i <= degree; i++) {\n\t\t\tconst coeff = i === 0 ? Fraction.ZERO : new Fraction(1, i).times(Math.pow(-1, i + 1));\n\t\t\tcoeffs.push(coeff);\n\t\t}\n\t\treturn new xPolynomial(coeffs, { ascending: true, variable: x.variable }).replaceXWith(x);\n\t},\n};\n","export { binomPdf, binomCdf, binomCdfRange } from './binomial';\nexport { normCdf, invNorm, zTest } from './normalFns';\nexport { Normal } from './normalClass';\nexport { factorial } from './simple-statistics/factorial';\nexport { nCr, NCR } from './nCr';\nexport { Regression } from './regression';\n","import { nCr } from './nCr';\n\n/**\n * binomPdf(n,p,x)\n *\n * @returns P(X=x)\n *\n */\nfunction binomPdf(n: number, p: number, x: number): number {\n\tif (Number.isInteger(n) && n > 0 && p >= 0 && p <= 1 && Number.isInteger(x) && x >= 0 && x <= n) {\n\t\treturn nCr(n, x) * Math.pow(p, x) * Math.pow(1 - p, n - x);\n\t}\n\tthrow new Error(`unexpected behavior for binomPDF ${n},${p},${x}}`);\n}\n\n/**\n * binomCdf(n,p,x)\n *\n * @returns P(X \\leq x)\n *\n */\nfunction binomCdf(n: number, p: number, x: number): number {\n\tconst epsilon = 1e-10;\n\tx = Math.floor(x);\n\tlet sum = 0;\n\tlet i = 0;\n\twhile (i <= x && sum < 1 - epsilon) {\n\t\t// second condition stops loop early to prevent possible overflow problems in nCr\n\t\tsum += binomPdf(n, p, i);\n\t\ti++;\n\t}\n\treturn sum >= 1 - epsilon ? 1 : sum;\n}\n\n/**\n * binomCdfRange(n,p,x1,x2)\n *\n * @returns P(x1 \\\\leq X \\leq x2)\n *\n */\nfunction binomCdfRange(n: number, p: number, lower: number, upper: number): number {\n\tlower = Math.ceil(lower);\n\tupper = Math.floor(upper);\n\tconst p2 = binomCdf(n, p, upper);\n\tconst p1 = binomCdf(n, p, lower - 1);\n\treturn p2 - p1;\n}\n\nexport { binomPdf, binomCdf, binomCdfRange };\n","import { factorial } from './simple-statistics/factorial';\n\n/**\n * n choose r\n *\n * uses a multiplication algorithm: beware of potential overflow for large numbers;\n */\nexport function nCr(n: number, r: number): number {\n\tif (!(Number.isInteger(n) && n >= 0 && Number.isInteger(r) && r >= 0 && r <= n)) {\n\t\tthrow new Error(`${n}C${r} not valid`);\n\t}\n\tif (r > n - r) {\n\t\tr = n - r;\n\t}\n\tlet ans = 1;\n\tfor (let i = 1; i <= r; i++) {\n\t\tans = (ans * (n - r + i)) / i;\n\t}\n\treturn ans;\n}\n\n/**\n * typesets and calculate nCr via toString and valueOf\n */\nexport class NCR {\n\tn: number;\n\tr: number;\n\tordered: boolean;\n\n\tconstructor(n: number, r: number, ordered = false) {\n\t\tthis.n = n;\n\t\tthis.r = r;\n\t\tthis.ordered = ordered;\n\t}\n\n\ttoString(): string {\n\t\treturn `{${this.n} \\\\choose ${this.r}}${this.ordered ? `\\\\times ${this.r}!` : ''}`;\n\t}\n\n\tvalueOf(): number {\n\t\tlet ncr = nCr(this.n, this.r);\n\t\tif (this.ordered) {\n\t\t\tncr *= factorial(this.r);\n\t\t}\n\t\treturn ncr;\n\t}\n}\n","import { errorFunction } from './simple-statistics/errorFunction';\nimport { erfinv } from './math-erfinv/math-erfinv';\n\n/**\n * normCdf(mu, sigma, limits)\n *\n * @param limits defaults to {lower: -infinity, upper: infinity} (implemented by the MAX_VALUE property)\n *\n * @returns P(lower < X < upper)\n *\n * uses the implementation of the error function by [simple-statistics package](https://simplestatistics.org/)\n */\nexport function normCdf(mu: number, sigma: number, limits: Limits): number {\n\tconst defaultLimits = { lower: -Number.MAX_VALUE, upper: Number.MAX_VALUE };\n\tconst { lower, upper } = { ...defaultLimits, ...limits };\n\tconst z1 = z(lower, mu, sigma);\n\tconst z2 = z(upper, mu, sigma);\n\treturn (errorFunction(z2 / Math.SQRT2) - errorFunction(z1 / Math.SQRT2)) / 2;\n}\n\n/**\n * invNorm(p, mu, sigma, mode)\n *\n * @param mu mean. defaults to 0\n * @param sigma standard deviation. defaults to 1\n * @param mode defaults to 'left' for left tail. Alternatives: 'right', 'center' for right and center\n *\n * @returns x such that P(X < x) = p for left tail. for 'center' mode, P(x1 < X < x2) = p, only x2 will be returned.\n *\n * uses the implementation of the inverse error function from [math-erfinv](https://github.com/math-io/erfinv)\n */\nexport function invNorm(\n\tp: number,\n\tmu = 0,\n\tsigma = 1,\n\tmode: 'left' | 'right' | 'center' | 'r' | 'c' | 'l' = 'left',\n): number {\n\tif (mode === 'right' || mode === 'r') {\n\t\tp = 1 - p;\n\t} else if (mode === 'center' || mode === 'c') {\n\t\tp = p + (1 - p) / 2;\n\t}\n\t//const z = (2 * p - 1 > 0.5) ? probit(p) : Math.SQRT2 * inverseErrorFunction(2 * p - 1);\n\tconst z = erfinv(2 * p - 1) * Math.SQRT2;\n\treturn z * sigma + mu;\n}\n\n/**\n * zTest(mu, sigma, xBar, n, tail)\n *\n * @param tail `'left'`(default), `'right'` or `'two'`\n * @returns p-value\n *\n * uses  the implementation by [simple-statistics package](https://simplestatistics.org/)\n */\nexport function zTest(mu: number, sigma: number, xBar: number, n: number, tail = 'left'): number {\n\tif (tail === 'left' || tail === 'l') {\n\t\treturn normCdf(mu, sigma / Math.sqrt(n), { upper: xBar });\n\t} else if (tail === 'right' || tail === 'r') {\n\t\treturn normCdf(mu, sigma / Math.sqrt(n), { lower: xBar });\n\t} else {\n\t\t// tail === 'two'/'center'\n\t\tconst halfP = normCdf(mu, sigma / Math.sqrt(n), xBar <= mu ? { upper: xBar } : { lower: xBar });\n\t\treturn 2 * halfP;\n\t}\n}\n\ninterface Limits {\n\tlower?: number;\n\tupper?: number;\n}\n\nfunction z(x: number, mu: number, sigma: number): number {\n\treturn (x - mu) / sigma;\n}\n","// The following code is from [simple-statistics package](https://simplestatistics.org/)\n// taken on 21st August 2022 and modified to include types\n\n/**\n * **[Gaussian error function](http://en.wikipedia.org/wiki/Error_function)**\n *\n * The `errorFunction(x/(sd * Math.sqrt(2)))` is the probability that a value in a\n * normal distribution with standard deviation sd is within x of the mean.\n *\n * This function returns a numerical approximation to the exact value.\n * It uses Horner's method to evaluate the polynomial of τ (tau).\n *\n * @param {number} x input\n * @return {number} error estimation\n * @example\n * errorFunction(1).toFixed(2); // => '0.84'\n */\nexport function errorFunction(x: number): number {\n\tconst t = 1 / (1 + 0.5 * Math.abs(x));\n\tconst tau =\n\t\tt *\n\t\tMath.exp(\n\t\t\t-x * x +\n\t\t\t\t((((((((0.17087277 * t - 0.82215223) * t + 1.48851587) * t - 1.13520398) * t + 0.27886807) * t - 0.18628806) *\n\t\t\t\t\tt +\n\t\t\t\t\t0.09678418) *\n\t\t\t\t\tt +\n\t\t\t\t\t0.37409196) *\n\t\t\t\t\tt +\n\t\t\t\t\t1.00002368) *\n\t\t\t\t\tt -\n\t\t\t\t1.26551223,\n\t\t);\n\tif (x >= 0) {\n\t\treturn 1 - tau;\n\t} else {\n\t\treturn tau - 1;\n\t}\n}\n","type MathFunction = (x: number) => number;\n\nfunction evalRational(P: number[], Q: number[]): MathFunction {\n\treturn (x: number) => {\n\t\tconst num = P.reduce((prev, p, i) => {\n\t\t\treturn prev + p * Math.pow(x, i);\n\t\t}, 0);\n\t\tconst den = Q.reduce((prev, p, i) => {\n\t\t\treturn prev + p * Math.pow(x, i);\n\t\t}, 0);\n\t\treturn num / den;\n\t};\n}\n\nfunction sqrt(x: number): number {\n\treturn Math.sqrt(x);\n}\nfunction ln(x: number): number {\n\treturn Math.log(x);\n}\n\nconst pInf = Number.POSITIVE_INFINITY;\nconst nInf = Number.NEGATIVE_INFINITY;\n\n/**\n * NOTE: the code below is modified starting from the code in [math-io/math-erfinv]{https://github.com/math-io/erfinv}.\n * The code has been modified in the following ways:\n * - Typescript definitions and let/const vs var\n * - Modifying the sqrt,ln,positive infinity and negative infinity implementations by relying on the Javascript version\n * - My own custom implementation of the \"evalrational\" function above\n *\n * This implementation follows the original, but has been modified for JavaScript.\n */\n\n/**\n * The MIT License (MIT)\n *\n * Copyright (c) 2016 The Compute.io Authors.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n */\n\n/**\n * NOTE: the original C++ code and copyright notice is from the [Boost library]{http://www.boost.org/doc/libs/1_48_0/boost/math/special_functions/detail/erf_inv.hpp}.\n *\n * This implementation follows the original, but has been modified for JavaScript.\n */\n\n/**\n * (C) Copyright John Maddock 2006.\n * Use, modification and distribution are subject to the\n * Boost Software License, Version 1.0. (See accompanying file\n * LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)\n */\n\n// NOTES //\n\n/**\n * erfinv( x )\n *\n * Method:\n *   1. For `|x| <= 0.5`, evaluate inverse erf using the rational approximation:\n *\n *        erfinv = x(x+10)(Y+R(x))\n *\n *      where `Y` is a constant and `R(x)` is optimized for a low absolute error compared to `|Y|`. Max error `2.001849e-18`. Maximum deviation found (error term at infinite precision) `8.030e-21`.\n *\n *   2. For `0.5 > 1-|x| >= 0`, evaluate inverse erf using the rational approximation:\n *\n *        erfinv = sqrt(-2*log(1-x)) / (Y + R(1-x))\n *\n *      where `Y `is a constant, and R(q) is optimized for a low absolute error compared to `Y`. Max error `7.403372e-17`. Maximum deviation found (error term at infinite precision) `4.811e-20`.\n *\n *   3. For `1-|x| < 0.25`, we have a series of rational approximations all of the general form:\n *\n *        p = sqrt(-log(1-x))\n *\n *      Then the result is given by:\n *\n *        erfinv = p(Y+R(p-B))\n *\n *      where `Y` is a constant, `B` is the lowest value of `p` for which the approximation is valid, and `R(x-B)` is optimized for a low absolute error compared to `Y`.\n *\n *   Notes:\n *     - Almost all code will really go through the first or maybe second approximation.  After that we are dealing with very small input values.\n *\n *       If `p < 3`, max error `1.089051e-20`.\n *       If `p < 6`, max error `8.389174e-21`.\n *       If `p < 18`, max error `1.481312e-19`.\n *       If `p < 44`, max error `5.697761e-20`.\n *       If `p >= 44`, max error `1.279746e-20`.\n *\n *     - The Boost library can accommodate 80 and 128 bit long doubles. JavaScript only supports a 64 bit double (IEEE754). Accordingly, the smallest `p` (in JavaScript at the time of this writing) is `sqrt(-log(~5e-324)) = 27.284429111150214`.\n */\n\n// Coefficients for erfinv on [0, 0.5]:\nconst Y1 = 8.91314744949340820313e-2;\nconst P1 = [\n\t-5.08781949658280665617e-4, -8.36874819741736770379e-3, 3.34806625409744615033e-2, -1.26926147662974029034e-2,\n\t-3.65637971411762664006e-2, 2.19878681111168899165e-2, 8.22687874676915743155e-3, -5.38772965071242932965e-3, 0.0,\n\t0.0,\n];\nconst Q1 = [\n\t1.0, -9.70005043303290640362e-1, -1.56574558234175846809, 1.56221558398423026363, 6.62328840472002992063e-1,\n\t-7.1228902341542847553e-1, -5.27396382340099713954e-2, 7.95283687341571680018e-2, -2.33393759374190016776e-3,\n\t8.86216390456424707504e-4,\n];\n\n// Coefficients for erfinv for 0.5 > 1-x >= 0:\nconst Y2 = 2.249481201171875;\nconst P2 = [\n\t-2.02433508355938759655e-1, 1.05264680699391713268e-1, 8.37050328343119927838, 1.76447298408374015486e1,\n\t-1.88510648058714251895e1, -4.46382324441786960818e1, 1.7445385985570866523e1, 2.11294655448340526258e1,\n\t-3.67192254707729348546,\n];\nconst Q2 = [\n\t1.0, 6.24264124854247537712, 3.9713437953343869095, -2.86608180499800029974e1, -2.01432634680485188801e1,\n\t4.85609213108739935468e1, 1.08268667355460159008e1, -2.26436933413139721736e1, 1.72114765761200282724,\n];\n\n// Coefficients for erfinv for sqrt( -log(1-x) ):\nconst Y3 = 8.07220458984375e-1;\nconst P3 = [\n\t-1.31102781679951906451e-1, -1.63794047193317060787e-1, 1.17030156341995252019e-1, 3.87079738972604337464e-1,\n\t3.37785538912035898924e-1, 1.42869534408157156766e-1, 2.90157910005329060432e-2, 2.14558995388805277169e-3,\n\t-6.79465575181126350155e-7, 2.85225331782217055858e-8, -6.81149956853776992068e-10,\n];\nconst Q3 = [\n\t1.0, 3.46625407242567245975, 5.38168345707006855425, 4.77846592945843778382, 2.59301921623620271374,\n\t8.48854343457902036425e-1, 1.52264338295331783612e-1, 1.105924229346489121e-2, 0.0, 0.0, 0.0,\n];\n\nconst Y4 = 9.3995571136474609375e-1;\nconst P4 = [\n\t-3.50353787183177984712e-2, -2.22426529213447927281e-3, 1.85573306514231072324e-2, 9.50804701325919603619e-3,\n\t1.87123492819559223345e-3, 1.57544617424960554631e-4, 4.60469890584317994083e-6, -2.30404776911882601748e-10,\n\t2.66339227425782031962e-12,\n];\nconst Q4 = [\n\t1.0, 1.3653349817554063097, 7.62059164553623404043e-1, 2.20091105764131249824e-1, 3.41589143670947727934e-2,\n\t2.63861676657015992959e-3, 7.64675292302794483503e-5, 0.0, 0.0,\n];\n\nconst Y5 = 9.8362827301025390625e-1;\nconst P5 = [\n\t-1.67431005076633737133e-2, -1.12951438745580278863e-3, 1.05628862152492910091e-3, 2.09386317487588078668e-4,\n\t1.49624783758342370182e-5, 4.49696789927706453732e-7, 4.62596163522878599135e-9, -2.81128735628831791805e-14,\n\t9.9055709973310326855e-17,\n];\nconst Q5 = [\n\t1.0, 5.91429344886417493481e-1, 1.38151865749083321638e-1, 1.60746087093676504695e-2, 9.64011807005165528527e-4,\n\t2.75335474764726041141e-5, 2.82243172016108031869e-7, 0.0, 0.0,\n];\n\n// FUNCTIONS //\n\n// Compile functions for evaluating rational functions...\nconst rationalFcnR2 = evalRational(P2, Q2);\nconst rationalFcnR1 = evalRational(P1, Q1);\nconst rationalFcnR3 = evalRational(P3, Q3);\nconst rationalFcnR4 = evalRational(P4, Q4);\nconst rationalFcnR5 = evalRational(P5, Q5);\n\n// ERFINV //\n\n/**\n * FUNCTION: erfinv( x )\n *\tEvaluates the inverse error function.\n *\n * @param {Number} x - input value\n * @returns {Number} evaluated inverse error function\n */\nexport function erfinv(x: number): number {\n\tlet sign: number;\n\tlet ax: number; // absolute value of x\n\tlet qs: number;\n\tlet q: number;\n\tlet g: number;\n\tlet r: number;\n\n\t// Special case: NaN\n\tif (x !== x) {\n\t\treturn NaN;\n\t}\n\t// Special case: 1\n\tif (x === 1) {\n\t\treturn pInf;\n\t}\n\t// Special case: -1\n\tif (x === -1) {\n\t\treturn nInf;\n\t}\n\t// Special case: +-0\n\tif (x === 0) {\n\t\treturn x;\n\t}\n\t// Special case: |x| > 1 (range error)\n\tif (x > 1 || x < -1) {\n\t\tthrow new RangeError(\n\t\t\t'invalid input argument. Input argument must be on the interval `[-1,1]`. Value: `' + x + '`.',\n\t\t);\n\t}\n\t// Argument reduction (reduce to interval [0,1]). If `x` is negative, we can safely negate the value, taking advantage of the error function being an odd function; i.e., `erf(-x) = -erf(x)`.\n\tif (x < 0) {\n\t\tsign = -1.0;\n\t\tax = -x;\n\t} else {\n\t\tsign = 1.0;\n\t\tax = x;\n\t}\n\tq = 1.0 - ax;\n\n\t// |x| <= 0.5\n\tif (ax <= 0.5) {\n\t\tg = ax * (ax + 10.0);\n\t\tr = rationalFcnR1(ax);\n\t\treturn sign * (g * Y1 + g * r);\n\t}\n\t// 1-|x| >= 0.25\n\tif (q >= 0.25) {\n\t\tg = sqrt(-2.0 * ln(q));\n\t\tq -= 0.25;\n\t\tr = rationalFcnR2(q);\n\t\treturn sign * (g / (Y2 + r));\n\t}\n\tq = sqrt(-ln(q));\n\n\t// q < 3\n\tif (q < 3) {\n\t\tqs = q - 1.125;\n\t\tr = rationalFcnR3(qs);\n\t\treturn sign * (Y3 * q + r * q);\n\t}\n\t// q < 6\n\tif (q < 6) {\n\t\tqs = q - 3.0;\n\t\tr = rationalFcnR4(qs);\n\t\treturn sign * (Y4 * q + r * q);\n\t}\n\t// q < 18\n\tqs = q - 6.0;\n\tr = rationalFcnR5(qs);\n\treturn sign * (Y5 * q + r * q);\n} // end FUNCTION erfinv()\n","import { normCdf, invNorm } from './normalFns';\n\nexport class Normal {\n\t/**\n\t * class representing normally distributed random variable X ~ N(mu, sigma^2)\n\t */\n\tmean: number;\n\tsd: number;\n\tvariance: number;\n\tsdMode: boolean;\n\tname: string;\n\n\t////\n\t// constructor\n\t////\n\t/**\n\t * Creates a new normal r.v. instance\n\t *\n\t * @param mean population mean mu\n\t * @param variance population variance sigma^2\n\t * @param options default to {name: 'X', sdMode: false} where sdMode indicate sd instead of\n\t * variance is provided\n\t *\n\t */\n\tconstructor(mean: number, variance = 1, options?: { name?: string; sdMode?: boolean }) {\n\t\tconst { name, sdMode } = {\n\t\t\tname: 'X',\n\t\t\tsdMode: false,\n\t\t\t...options,\n\t\t};\n\t\tthis.mean = mean;\n\t\tif (variance < 0) {\n\t\t\tthrow new RangeError('variance must be non-negative');\n\t\t}\n\t\tthis.variance = sdMode ? variance * variance : variance;\n\t\tthis.sd = sdMode ? variance : Math.sqrt(variance);\n\t\tthis.sdMode = sdMode;\n\t\tthis.name = name;\n\t}\n\n\t/**\n\t * adds two independently distributed normal r.v.\n\t *\n\t */\n\tplus(Y: number | Normal, options?: { name?: string }): Normal {\n\t\tif (typeof Y === 'number') {\n\t\t\tY = new Normal(Y, 0);\n\t\t}\n\t\tconst { name } = {\n\t\t\tname: `${this.name}+${Y.name}`,\n\t\t\t...options,\n\t\t};\n\t\treturn new Normal(this.mean + Y.mean, this.variance + Y.variance, { name });\n\t}\n\t/**\n\t * multiplies by a scalar, nX ~ (n mu, n^2 sigma^2)\n\t *\n\t */\n\ttimes(n: number, options?: { name?: string }): Normal {\n\t\tconst { name } = {\n\t\t\tname: `${n}${this.name}`,\n\t\t\t...options,\n\t\t};\n\t\treturn new Normal(this.mean * n, this.variance * n * n, { name });\n\t}\n\t/**\n\t * divides by a scalar, 1/n X ~ (mu/n, sigma^2/n^2)\n\t *\n\t */\n\tdivide(n: number, options?: { name?: string }): Normal {\n\t\tif (n === 0) {\n\t\t\tthrow new RangeError('cannot divide by 0');\n\t\t}\n\t\tconst { name } = {\n\t\t\tname: `\\\\frac{1}{${n}} ${this.name}`,\n\t\t\t...options,\n\t\t};\n\t\treturn this.times(1 / n, { name });\n\t}\n\t/**\n\t * subtracts independently distributed normal r.v., this - Y\n\t *\n\t */\n\tminus(Y: number | Normal, options?: { name?: string }): Normal {\n\t\tif (typeof Y === 'number') {\n\t\t\tY = new Normal(Y, 0);\n\t\t}\n\t\tconst { name } = {\n\t\t\tname: `${this.name}-${Y.name}`,\n\t\t\t...options,\n\t\t};\n\t\treturn this.plus(Y.times(-1), { name });\n\t}\n\t/**\n\t * sum X1 + ... + Xn ~ N(n mu, n sigma^2)\n\t */\n\tsum(n: number, options?: { name?: string }): Normal {\n\t\tconst { name } = {\n\t\t\tname: `${this.name}_1 + \\\\cdots + ${this.name}_{${n}}`,\n\t\t\t...options,\n\t\t};\n\t\treturn new Normal(this.mean * n, this.variance * n, { name });\n\t}\n\t/**\n\t * sample mean XBar ~ N (mu, sigma^2 / n)\n\t */\n\tbar(n: number): Normal {\n\t\treturn new Normal(this.mean, this.variance / n);\n\t}\n\n\t//// probability methods\n\t/**\n\t * less than\n\t *\n\t * @returns P(X < x)\n\t */\n\tlessThan(x: number): number {\n\t\treturn normCdf(this.mean, Math.sqrt(this.variance), { upper: x });\n\t}\n\t/**\n\t * more than\n\t *\n\t * @returns P(X > x)\n\t */\n\tmoreThan(x: number): number {\n\t\treturn normCdf(this.mean, Math.sqrt(this.variance), { lower: x });\n\t}\n\t/**\n\t * between\n\t *\n\t * @returns P(x1 < X < x2)\n\t */\n\tbetween(x1: number, x2: number): number {\n\t\treturn normCdf(this.mean, Math.sqrt(this.variance), { lower: x1, upper: x2 });\n\t}\n\t/**\n\t * invNorm\n\t *\n\t * @mode defaults to 'left' for left tail, accepts 'right' or 'center'\n\t *\n\t * @return x such that P(X < x) = p\n\t */\n\tinvNorm(p: number, mode: 'center' | 'left' | 'right' | 'l' | 'c' | 'r' = 'left'): number {\n\t\treturn invNorm(p, this.mean, Math.sqrt(this.variance), mode);\n\t}\n\n\t/**\n\t * toString: returns `X ~ N(mu, sigma^2)`\n\t *\n\t * @param name symbol representing the r.v. (default `X`)\n\t */\n\ttoString(): string {\n\t\tconst mean = `${this.mean}`.length > 5 ? this.mean.toPrecision(5) : this.mean;\n\t\tlet variance: string | number;\n\t\tif (this.sdMode) {\n\t\t\tvariance = `${this.sd}^2`;\n\t\t} else {\n\t\t\tvariance = `${this.variance}`.length > 5 ? this.variance.toPrecision(5) : this.variance;\n\t\t}\n\t\treturn `${this.name} \\\\sim N( ${mean},${variance} )`;\n\t}\n}\n","export class Regression {\n\tx: string;\n\ty: string;\n\txData: number[];\n\tyData: number[];\n\n\tconstructor(xData: number[], yData: number[], options?: { x?: string; y?: string }) {\n\t\tthis.xData = xData;\n\t\tthis.yData = yData;\n\t\tthis.x = options?.x || 'x';\n\t\tthis.y = options?.y || 'y';\n\t}\n\n\txBar(): number {\n\t\treturn sumX(this.xData) / this.xData.length;\n\t}\n\tyBar(): number {\n\t\treturn sumX(this.yData) / this.yData.length;\n\t}\n\tr(): number {\n\t\treturn sXY(this.xData, this.yData) / Math.sqrt(sXX(this.xData) * sXX(this.yData));\n\t}\n\tr2(): number {\n\t\treturn Math.pow(this.r(), 2);\n\t}\n\n\t/**\n\t * @returns [a, b] such that y = a + bx\n\t */\n\tyOnX(): [number, number] {\n\t\tconst b = sXY(this.xData, this.yData) / sXX(this.xData);\n\t\tconst a = this.yBar() - b * this.xBar();\n\t\treturn [a, b];\n\t}\n\n\tyOnXAt(x: number): number {\n\t\tconst [a, b] = this.yOnX();\n\t\treturn a + b * x;\n\t}\n\t/**\n\t * @returns [a, b] such that x = a + by\n\t */\n\txOnY(): [number, number] {\n\t\tconst b = sXY(this.xData, this.yData) / sXX(this.yData);\n\t\tconst a = this.xBar() - b * this.yBar();\n\t\treturn [a, b];\n\t}\n\n\ttoString(precision = 3, options?: { dpMode?: boolean }): string {\n\t\tconst dpMode = options?.dpMode || false;\n\t\tconst [a, b] = this.yOnX();\n\t\tconst aString = dpMode ? a.toFixed(precision) : a.toPrecision(precision);\n\t\tconst sign = b > 0 ? '+' : '';\n\t\tconst bString = dpMode ? b.toFixed(precision) : b.toPrecision(precision);\n\t\treturn `${this.y} = ${aString}${sign}${bString}${this.x}`;\n\t}\n\n\tlinearize(functions?: {\n\t\txFn?: ((x1: number) => number) | 'ln' | 'reciprocal' | 'square';\n\t\tyFn?: ((y1: number) => number) | 'ln' | 'reciprocal' | 'square';\n\t\tx?: string;\n\t\ty?: string;\n\t}): Regression {\n\t\tconst { xFn, yFn, x, y } = {\n\t\t\txFn: (x1: number) => x1,\n\t\t\tyFn: (y1: number) => y1,\n\t\t\tx: this.x,\n\t\t\ty: this.y,\n\t\t\t...functions,\n\t\t};\n\t\tlet xFnFinal: (x: number) => number;\n\t\tlet yFnFinal: (x: number) => number;\n\t\tif (typeof xFn === 'string') {\n\t\t\tif (xFn === 'ln') {\n\t\t\t\txFnFinal = ln;\n\t\t\t} else if (xFn === 'reciprocal') {\n\t\t\t\txFnFinal = reciprocal;\n\t\t\t} else if (xFn === 'square') {\n\t\t\t\txFnFinal = square;\n\t\t\t} else {\n\t\t\t\tthrow new Error(`Invalid function name ${xFn}`);\n\t\t\t}\n\t\t} else {\n\t\t\txFnFinal = xFn;\n\t\t}\n\t\tif (typeof yFn === 'string') {\n\t\t\tif (yFn === 'ln') {\n\t\t\t\tyFnFinal = ln;\n\t\t\t} else if (yFn === 'reciprocal') {\n\t\t\t\tyFnFinal = reciprocal;\n\t\t\t} else if (yFn === 'square') {\n\t\t\t\tyFnFinal = square;\n\t\t\t} else {\n\t\t\t\tthrow new Error(`Invalid function name ${xFn}`);\n\t\t\t}\n\t\t} else {\n\t\t\tyFnFinal = yFn;\n\t\t}\n\t\tconst xData = this.xData.map(xFnFinal);\n\t\tconst yData = this.yData.map(yFnFinal);\n\t\treturn new Regression(xData, yData, { x, y });\n\t}\n}\n\nconst sumX = (xData: number[]) => xData.reduce((a, b) => a + b, 0);\nconst sumX2 = (xData: number[]) => xData.reduce((a, b) => a + b * b, 0);\nconst sumXY = (xData: number[], yData: number[]) => xData.reduce((a, b, i) => a + b * yData[i], 0);\nconst sXX = (xData: number[]) => sumX2(xData) - (sumX(xData) * sumX(xData)) / xData.length;\nconst sXY = (xData: number[], yData: number[]) => sumXY(xData, yData) - (sumX(xData) * sumX(yData)) / xData.length;\n\nfunction ln(x: number): number {\n\treturn Math.log(x);\n}\nfunction reciprocal(x: number): number {\n\treturn 1 / x;\n}\nfunction square(x: number): number {\n\treturn x * x;\n}\n"],"names":[],"version":3,"file":"index.mjs.map"}